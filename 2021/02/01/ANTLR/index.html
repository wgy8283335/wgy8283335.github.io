<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta name="description" content="实例入门在安装完 antlr 之后，可以编写简单的 g4 文件 1234grammar Hello;r:&#39;hello&#39; ID ;ID:[a-z]+ ;WS:[\t\r\n]+ -&gt; skip;  运行如下命令  antlr4 Hello.g4 javac *.java alias grun&#x3D;‘java org.antlr.v4.runtime.misc.TestRig’ Te">
<meta property="og:type" content="article">
<meta property="og:title" content="Antlr相关">
<meta property="og:url" content="http://yoursite.com/2021/02/01/ANTLR/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="实例入门在安装完 antlr 之后，可以编写简单的 g4 文件 1234grammar Hello;r:&#39;hello&#39; ID ;ID:[a-z]+ ;WS:[\t\r\n]+ -&gt; skip;  运行如下命令  antlr4 Hello.g4 javac *.java alias grun&#x3D;‘java org.antlr.v4.runtime.misc.TestRig’ Te">
<meta property="og:locale">
<meta property="og:image" content="http://yoursite.com/images/antlr/2-2.png">
<meta property="og:image" content="http://yoursite.com/images/antlr/2-3.png">
<meta property="og:image" content="http://yoursite.com/images/antlr/2-5.png">
<meta property="og:image" content="http://yoursite.com/images/antlr/2-6.png">
<meta property="og:image" content="http://yoursite.com/images/antlr/4-4.png">
<meta property="og:image" content="http://yoursite.com/images/antlr/9-6.png">
<meta property="og:image" content="http://yoursite.com/images/antlr/9-11.png">
<meta property="article:published_time" content="2021-02-01T13:00:00.000Z">
<meta property="article:modified_time" content="2021-03-07T02:36:21.177Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="ss">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/antlr/2-2.png">


<link rel="canonical" href="http://yoursite.com/2021/02/01/ANTLR/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>
<title>Antlr相关 | Hexo</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%85%A5%E9%97%A8"><span class="nav-number">1.</span> <span class="nav-text">实例入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="nav-number">1.1.</span> <span class="nav-text">调试工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ANTLR4-%E7%9A%84-IntelliJ-%E6%8F%92%E4%BB%B6"><span class="nav-number">1.2.</span> <span class="nav-text">ANTLR4 的 IntelliJ 插件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">语法分析器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%A7%A3%E6%9E%90"><span class="nav-number">2.1.</span> <span class="nav-text">顺序解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E5%88%86%E6%94%AF%E8%A7%A3%E6%9E%90"><span class="nav-number">2.2.</span> <span class="nav-text">多分支解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A7%E4%B9%89"><span class="nav-number">2.3.</span> <span class="nav-text">歧义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91"><span class="nav-number">2.4.</span> <span class="nav-text">语法分析树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91%E7%9A%84%E8%AE%BF%E9%97%AE-%E7%9B%91%E5%90%AC%E5%99%A8%E3%80%81%E8%AE%BF%E9%97%AE%E5%99%A8"><span class="nav-number">2.5.</span> <span class="nav-text">语法分析树的访问-监听器、访问器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-number">2.5.1.</span> <span class="nav-text">监听器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%99%A8"><span class="nav-number">2.5.2.</span> <span class="nav-text">访问器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%BA%8B%E4%BB%B6%E6%96%B9%E6%B3%95%E4%B8%AD%E5%85%B1%E4%BA%AB%E4%BF%A1%E6%81%AF"><span class="nav-number">2.5.3.</span> <span class="nav-text">在事件方法中共享信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="nav-number">2.6.</span> <span class="nav-text">语法规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="nav-number">2.6.1.</span> <span class="nav-text">例子 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ANTLR-%E8%AF%AD%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A0%87%E8%AE%B0"><span class="nav-number">2.6.2.</span> <span class="nav-text">ANTLR 语法基本标记</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99-1"><span class="nav-number">2.6.3.</span> <span class="nav-text">语法规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E9%80%92%E5%BD%92"><span class="nav-number">2.6.3.1.</span> <span class="nav-text">左递归</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99"><span class="nav-number">2.6.4.</span> <span class="nav-text">词法规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ANTLR-%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">2.7.</span> <span class="nav-text">ANTLR 解析过程的异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E8%AF%AD%E6%B3%95%E5%92%8C%E8%AF%8D%E6%B3%95%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%8A%A8%E4%BD%9C"><span class="nav-number">2.8.</span> <span class="nav-text">在语法和词法文件中添加动作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">2.8.1.</span> <span class="nav-text">定制语法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">2.8.2.</span> <span class="nav-text">定制词法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E7%94%9F%E6%88%90%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E4%B8%8E-Java-%E7%A8%8B%E5%BA%8F%E9%9B%86%E6%88%90%EF%BC%8C%E5%B9%B6%E4%BD%BF%E7%94%A8%E7%9B%91%E5%90%AC%E5%99%A8%E9%81%8D%E5%8E%86%E5%A4%84%E7%90%86"><span class="nav-number">2.9.</span> <span class="nav-text">将生成的语法分析器与 Java 程序集成，并使用监听器遍历处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90-1-1"><span class="nav-number">2.9.1.</span> <span class="nav-text">例子 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90-2"><span class="nav-number">2.9.2.</span> <span class="nav-text">例子 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90-3-%E8%AE%BF%E9%97%AE%E5%99%A8"><span class="nav-number">2.9.3.</span> <span class="nav-text">例子 3 访问器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90-4"><span class="nav-number">2.9.4.</span> <span class="nav-text">例子 4</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="nav-number">2.10.</span> <span class="nav-text">错误报告与恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A5%E9%97%A8"><span class="nav-number">2.10.1.</span> <span class="nav-text">入门</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%92%8C%E8%BD%AC%E5%8F%91-ANTLR-%E7%9A%84%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF"><span class="nav-number">2.10.2.</span> <span class="nav-text">修改和转发 ANTLR 的错误消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF"><span class="nav-number">2.10.2.1.</span> <span class="nav-text">处理语法错误信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%9C%89%E6%AD%A7%E4%B9%89%E7%9A%84%E8%AF%AD%E6%B3%95%E4%BF%A1%E6%81%AF"><span class="nav-number">2.10.2.2.</span> <span class="nav-text">处理有歧义的语法信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%94%99%E8%AF%AF%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6"><span class="nav-number">2.10.3.</span> <span class="nav-text">自动错误恢复机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8B%98%E8%AF%AF%E5%A4%87%E9%80%89%E5%88%86%E6%94%AF"><span class="nav-number">2.10.4.</span> <span class="nav-text">勘误备选分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9-ANTLR-%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="nav-number">2.10.5.</span> <span class="nav-text">修改 ANTLR 的错误处理策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E8%87%AA%E8%BA%AB%E7%9A%84%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81"><span class="nav-number">2.11.</span> <span class="nav-text">在语法分析过程中执行自身的逻辑代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%92%8C%E5%8A%A8%E4%BD%9C"><span class="nav-number">2.12.</span> <span class="nav-text">属性和动作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%8A%A8%E4%BD%9C"><span class="nav-number">2.12.1.</span> <span class="nav-text">添加动作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7%E5%92%8C%E8%A7%84%E5%88%99%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">2.12.2.</span> <span class="nav-text">访问词法符号和规则的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%86%E5%88%AB"><span class="nav-number">2.12.3.</span> <span class="nav-text">关键字识别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%AD%E4%B9%89%E5%88%A4%E5%AE%9A%E4%BF%AE%E6%94%B9%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="nav-number">2.13.</span> <span class="nav-text">使用语义判定修改语法分析过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%8C%E6%8F%A1%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%9A%84%E2%80%9C%E9%BB%91%E9%AD%94%E6%B3%95%E2%80%9D"><span class="nav-number">2.14.</span> <span class="nav-text">掌握词法分析的“黑魔法”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7%E9%80%81%E5%85%A5%E4%B8%8D%E5%90%8C%E9%80%9A%E9%81%93"><span class="nav-number">2.14.1.</span> <span class="nav-text">将词法符号送入不同通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AF%8D%E6%B3%95%E9%97%AE%E9%A2%98"><span class="nav-number">2.14.2.</span> <span class="nav-text">上下文相关的词法问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%9A%84%E5%AD%A4%E5%B2%9B"><span class="nav-number">2.14.3.</span> <span class="nav-text">字符流中的孤岛</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9-XML-%E8%BF%9B%E8%A1%8C%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">2.14.4.</span> <span class="nav-text">对 XML 进行语法分析和词法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%8F%82%E8%80%83"><span class="nav-number">2.15.</span> <span class="nav-text">语法参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E8%AF%8D%E6%B1%87%E8%A1%A8"><span class="nav-number">2.15.1.</span> <span class="nav-text">语法词汇表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84"><span class="nav-number">2.15.2.</span> <span class="nav-text">语法结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%B3%95%E8%A7%84%E5%88%99"><span class="nav-number">2.15.3.</span> <span class="nav-text">文法规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E4%BD%9C%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="nav-number">2.15.4.</span> <span class="nav-text">动作和属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99-1"><span class="nav-number">2.15.5.</span> <span class="nav-text">词法规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E9%9D%9E%E8%B4%AA%E5%A9%AA%E5%AD%90%E8%A7%84%E5%88%99"><span class="nav-number">2.15.6.</span> <span class="nav-text">通配符和非贪婪子规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E4%B9%89%E5%88%A4%E5%AE%9A"><span class="nav-number">2.15.7.</span> <span class="nav-text">语义判定</span></a></li></ol></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/01/ANTLR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Antlr相关
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-01 21:00:00" itemprop="dateCreated datePublished" datetime="2021-02-01T21:00:00+08:00">2021-02-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-07 10:36:21" itemprop="dateModified" datetime="2021-03-07T10:36:21+08:00">2021-03-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="实例入门"><a href="#实例入门" class="headerlink" title="实例入门"></a>实例入门</h1><p>在安装完 antlr 之后，可以编写简单的 g4 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grammar Hello;</span><br><span class="line">r:&#39;hello&#39; ID ;</span><br><span class="line">ID:[a-z]+ ;</span><br><span class="line">WS:[\t\r\n]+ -&gt; skip;</span><br></pre></td></tr></table></figure>

<p>运行如下命令</p>
<ul>
<li><code>antlr4 Hello.g4</code></li>
<li><code>javac *.java</code></li>
<li><code>alias grun=‘java org.antlr.v4.runtime.misc.TestRig’</code> TestRig 是一个调试工具，使用 alias 给它起了一个别名。直接执行<code>grun</code>可以得到帮助信息。</li>
<li><code>grun Hello r -tokens</code></li>
<li><code>hello parrt</code></li>
<li><code>EOF</code></li>
</ul>
<p>得到如下结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[@0,0:4&#x3D;&#39;hello&#39;,&lt;&#39;hello&#39;&gt;,1:0]</span><br><span class="line">[@1,6:10&#x3D;&#39;parrt&#39;,&lt;ID&gt;,1:6]</span><br><span class="line">[@2,12:11&#x3D;&#39;&lt;EOF&gt;&#39;,&lt;EOF&gt;,2:0]</span><br></pre></td></tr></table></figure>

<p>解析结果：比如 parrt。@1 表明该词法符号在第 2 个位置，parrt 位于第 6 个到第 10 个位置之间，词法符号类型是 ID，位于输入文本的第 1 行，第 6 个位置处。</p>
<h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><p>TestRig 是一个调试工具。<br><code>alias grun=‘java org.antlr.v4.runtime.misc.TestRig’</code> TestRig 是一个调试工具，使用 alias 给它起了一个别名。直接执行<code>grun</code>可以得到帮助信息。</p>
<ul>
<li>对于<code>Hello</code>语法，执行<code>grun Hello r -tokens</code>可以得到解析的各个 token 的信息。</li>
<li>对于<code>Hello</code>语法，执行<code>grun Hello r -tree</code>可以得到解析的树信息。</li>
<li>对于<code>Hello</code>语法，执行<code>grun Hello r -gui</code>可以得到解析的树的图形信息。<br>通过执行 grun，可以查看可以使用的选项。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ grun</span><br><span class="line">java org.antlr.v4.gui.TestRig GrammarName startRuleName</span><br><span class="line">  [-tokens] [-tree] [-gui] [-ps file.ps] [-encoding encodingname]</span><br><span class="line">  [-trace] [-diagnostics] [-SLL]</span><br><span class="line">  [input-filename(s)]</span><br><span class="line">Use startRuleName&#x3D;&#39;tokens&#39; if GrammarName is a lexer grammar.</span><br></pre></td></tr></table></figure>

<p>-ps files.ps 以 PostScript 格式生成可视化语法分析树，然后将其存储于 file.ps。本章中的语法分析树的图片就是使用-ps 选项生成的。<br>-encoding encodingname 若当前的区域设定无法正确读取输入，使用这个选项指定测试组件输入文件的编码。例如，在 12.4 节中我们需要通过这个选项来解析日语 XML 文件。<br>-trace 打印规则的名字以及进入和离开该规则时的词法符号。</p>
<ul>
<li>diagnostics 开启解析过程中的调试信息输出。通常仅在一些罕见情况下使用它产生信息，例如输入的文本有歧义。</li>
<li>SLL 使用另外一种更快但是功能稍弱的解析策略。</li>
</ul>
<h2 id="ANTLR4-的-IntelliJ-插件"><a href="#ANTLR4-的-IntelliJ-插件" class="headerlink" title="ANTLR4 的 IntelliJ 插件"></a>ANTLR4 的 IntelliJ 插件</h2><p>打开 g4 文件，选择特定的规则名字，然后右键选择 Test Rule ****。<br>会在底部弹出框，左侧显示输入的 sql 语句，右侧显示分析的后 tree 以及 Hierarchy，Profiler。</p>
<h1 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h1><p>Antlr 依据我们定义的语法规则，产生一个递归下降的语法分析器。下降过程就是从语法分析树的根节点开始，朝着叶节点进行解析的过程。递归下降的语法分析其实际是若干方法的结合，每个方法对应一条规则。递归下降属于自上而下的语法分析器的一种实现。<br>首先调用的规则，即语义符号的起始点，就会成为语法分析树的根节点。比如：调用上面的 r()方法，作为起始点。<br>语法分析数的构造过程：识别匹配的规则，将对应规则的方法映射到语法分析树中。<br>一般规则分为：单一分支，多分支。例如：多个规则 assign，ifstat<br>单一分支，如：<code>stat: assign;</code><br>多分支，如:<code>stat: assign|ifstat;</code></p>
<h2 id="顺序解析"><a href="#顺序解析" class="headerlink" title="顺序解析"></a>顺序解析</h2><p>单一分支，只需要顺序匹配词汇符号。</p>
<h2 id="多分支解析"><a href="#多分支解析" class="headerlink" title="多分支解析"></a>多分支解析</h2><p>多分支，需要检查下一个词法符号或者多个词法符号，来决定选择哪个备选分支。这个过程成为预测或语法分析决策。<br>如果在预测过程中，发现多个分支都匹配的话，则出现了规则的定义出现了歧义，需要解决。</p>
<h2 id="歧义"><a href="#歧义" class="headerlink" title="歧义"></a>歧义</h2><p>例如下面这个语法就存在歧义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stat: expr &#39;;&#39;</span><br><span class="line">    | ID &#39;(&#39; &#39;)&#39; &#39;;&#39;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expr: ID &#39;(&#39; &#39;)&#39;</span><br><span class="line">    | INT</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>一般情况下要确保语法分析器能够选择唯一匹配的备选分支。不过当存在多个备选分支时，ANTLR 会选取备选分支中的第一条。比如本例中就会选择<code>expr &#39;;&#39;</code><br>如下存在词法歧义,begin 是一个关键字，同时也是一个标识符。<br>词法分析器会匹配最长字符串，如果输入文本 beginner 只会匹配上例中的 ID 这条词法规则。ANTLR 词法分析器不会把它匹配为关键字 BEGIN 后跟着标识符 ner</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BEGIN : &#39;begin&#39; ;</span><br><span class="line">ID    : [a-z]+ ;</span><br></pre></td></tr></table></figure>

<h2 id="语法分析树"><a href="#语法分析树" class="headerlink" title="语法分析树"></a>语法分析树</h2><p>构建应用逻辑和语法松耦合的语言类应用程序的关键在于，令语法分析器建立一颗语法分析树，然后在遍历该树的过程中触发应用逻辑代码。<br>语法分析树的建造过程：词法分析器处理字符序列并将生成的词法符号提供给语法分析器，语法分析器随即根据这些细信息来检查语法的正确性并建造出一颗语法分析树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharStream-&gt;(Lexer)-&gt;TokenStream-&gt;(Parser)-&gt;ParseTree(RuleNode子类+TerminalNode)</span><br></pre></td></tr></table></figure>

<p><img src="/images/antlr/2-2.png"><br><img src="/images/antlr/2-3.png"></p>
<p>ANTLR 使用共享数据结构节约内存，具体办法是：语法分析树中的叶子节点仅仅是盛放词法符号流中的词法符号的容器。每个词法符号都记录了自己在字符序列中的开始位置和结束位置，而非保存子字符串的拷贝。<br>ParseTree 有两个子类：RuleNode 的子类（非叶子） 和 TerminalNode（叶子）。 RuleNode 的子类包括：StatContext 和 ExprContext.Context 对象知道自己识别的词组中，开始和结束位置处的词法符号，同时提供访问该词组全部元素的方法比如 statContext 类有 ID（）和 expr()方法。有了这些方法，我们就可以遍历并操作树中节点。实际上遍历树的机制都是由 ANTLR 生成的代码</p>
<h2 id="语法分析树的访问-监听器、访问器"><a href="#语法分析树的访问-监听器、访问器" class="headerlink" title="语法分析树的访问-监听器、访问器"></a>语法分析树的访问-监听器、访问器</h2><p>为了构建一个语言类应用程序，语法分析器需要在遇到特定的输入语句、词组或者词法符号时触发特定的行为。这样的词组-&gt;行为的集合构成了我们的语言类应用程序，或者，至少担任了语法和外围程序间接口的角色。<br>监听器和访问器的区别在于，监听器方法不负责显示调用子节点的访问方法(visit())。访问器必须显式触发对子节点的访问，树的遍历过程才能正常进行，所以访问器可以控制访问的顺序以及节点被访问的次数。</p>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>ANTLR 提供了 ParseTree-Walker 类，自动遍历树然后生成事件并调用监听器。<br>每个语法文件都会生成一个 ParseTreeLisener 的子类，里面每个规则都有对应的 enter 方法和 exit 方法()，这些方法也称为”事件方法”。这些方法的入参是 ×××Context，提供该方法所需要的所有信息。监听器的操作逻辑在这些 enter 和 exit 方法内添加。下图显示了 ParseTreeWalker 对监听器方法的完整的调用顺序。<br><img src="/images/antlr/2-5.png"></p>
<h3 id="访问器"><a href="#访问器" class="headerlink" title="访问器"></a>访问器</h3><p>有时候我们希望手动控制遍历数的过程，通过显示的方法调用来访问子节点。在命令行中加入-visitor 选项可以指示 ANTLR 为一个语法生成访问器接口，语法中的每条规则对应接口中的一个 visit 方法。ANTRL 提供了访问器接口和一个默认实现类，这样我们自己只需要覆盖接口中我们感兴趣的方法。<br><img src="/images/antlr/2-6.png"></p>
<p>调用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ParseTree tree &#x3D; ...;&#x2F;&#x2F;语法分析数</span><br><span class="line">MyVisitor v &#x3D; new MyVisitor();&#x2F;&#x2F;访问器接口的实现类</span><br><span class="line">v.visit(tree);&#x2F;&#x2F;visitor访问tree</span><br></pre></td></tr></table></figure>

<h3 id="在事件方法中共享信息"><a href="#在事件方法中共享信息" class="headerlink" title="在事件方法中共享信息"></a>在事件方法中共享信息</h3><ol>
<li><p>使用访问器遍历语法分析树,使用访问器方法来返回值。优缺点：无法传递参数，访问器方法只能返回值。</p>
</li>
<li><p>使用类成员在事件方法之间共享数据，使用栈来模拟返回值。在上下文类中维护一个栈字段，以与 java 调用栈相同的方式，模拟参数和返回值的入和出栈。优缺点：手工操作栈存在失误的可能性，不过栈比较节省空间，所有局部结果的存储在树遍历完成后都会被释放。</p>
</li>
<li><p>通过对语法分析树的节点进行标注来存储相关数据，通过规则参数和返回值为节点添加字段。在上下文中维护一个 Map 字段，用对应的值来标注节点。优缺点：树标注是我个人的首选解决方案，因为它允许我向事件方法提供任意信息来操纵语法分析树中的各个节点。通过该方案，我可以传递多个任意类型的参数值。在很多情况下，标注比存储转瞬即逝的值的栈更好。使用它，在众多方法中来回传递数据也更不容易事务。这种方案的唯一缺点是，在整个遍历过程中，局部结果都会被保留，因此具有更大的内存消耗。另一方面，某些程序恰好需要标注语法分析树的方案，例如 8.4 节。该程序需要对语法分析树进行多次遍历，将第一趟遍历得到的数据完整地存储在树中是合理的，这样，第二趟遍历就能非常容易地获取这些数据。总之，对数进行标注的方案异常灵活，同时内存占用也处于可接受的范围。</p>
<ul>
<li><strong>为规则添加返回值</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e returns [int value]</span><br><span class="line">    : e &#39;*&#39; e  # Mult</span><br><span class="line">    | e &#39;+&#39; e  # Add</span><br><span class="line">    | INT      # Int</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>ANTLR 会将所有的参数和返回值放入相关的上下文对象中，这样，value 就成为 EContext 的一个字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static class AddContext extends ParserRuleContext &#123;</span><br><span class="line">    public int value;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在对监听器方法进行实现的时候，就可以按照如下方式存储值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void exitAdd(LExprParser.AddContext ctx) &#123;</span><br><span class="line">    &#x2F;&#x2F; e(0).value 是备选分支中的第一个e子表达式的值</span><br><span class="line">    ctx.value &#x3D; ctx.e(0).value + ctx.e(1).value; &#x2F;&#x2F; e &#39;+&#39; e #Add</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 ParseTreeProperty 类来存储各个节点及对应的值</strong><br>定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static class EvaluatorWithProps extends LExprBaseListener &#123;</span><br><span class="line">    &#x2F;** 使用Map&lt;ParseTree,Inteer&gt;将节点映射到对应的整数值 **&#x2F;</span><br><span class="line">    ParseTreeProperty&lt;Integer&gt; values &#x3D; new ParseTreeProperty&lt;Integer&gt;();</span><br><span class="line">    public void setValue(ParseTree node, int value) &#123; values.put(node,value);&#125;</span><br><span class="line">    public int getValue(ParseTree node) &#123;return values.get(node);&#125;</span><br><span class="line">    public void exitAdd(LExprParser.AddContext ctx) &#123;</span><br><span class="line">        int left &#x3D; getValue(ctx.e(0));</span><br><span class="line">        int right &#x3D; getValue(ctx.e(1));</span><br><span class="line">        setValue(ctx, left+right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ParseTreeWalker walker &#x3D; new ParseTreeWalker();</span><br><span class="line">EvaluatorWithProps evalProp &#x3D; new EvaluatorWithProps();</span><br><span class="line">walker.walk(evalProp, tree);</span><br><span class="line">System.out.println(&quot;properties result &#x3D; &quot;+ evalProp.getValue(tree));</span><br></pre></td></tr></table></figure>
</li>
<li><p>总结。为获取可复用的语法，我们需要使其与用户自定义的动作分离。这意味着将所有程序自身的逻辑代码放到语法之外的某种监听器或者访问器中。监听器和访问器通过操纵语法分析树来完成工作，ANTLR 会自动生成合适的接口和默认实现类，以便对语法分析树进行遍历。但是，由于事件方法的签名是固定的，无法由程序自行决定，我们找到了三种在事件方法中共享数据的方案。</p>
</li>
</ol>
<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h3><p>文件 ArrayInit.g4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 语法文件通常以grammar关键字开头</span><br><span class="line"> *  这是一个名为ArrayInit的语法，它必须和文件名ArrayInit.g4相匹配</span><br><span class="line"> *&#x2F;</span><br><span class="line">grammar ArrayInit;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;一条名为init的规则，它匹配一对花括号中的、逗号分隔的value</span><br><span class="line">init: &#39;&#123;&#39; value (&#39;,&#39; value)* &#39;)&#39;; &#x2F;&#x2F;必须匹配至少一个value。其中*号用来修饰小括号里的内容，表示任意个。</span><br><span class="line">&#x2F;&#x2F; 一个value可以是嵌套的花括号结构，也可以是一个简单的整数，即INT词法符号</span><br><span class="line">value: init</span><br><span class="line">     | INIT</span><br><span class="line">     ;</span><br><span class="line">&#x2F;&#x2F;语法分析器的规则必须以小写字母开头，词法分析器的规则必须用大写字母开头</span><br><span class="line">INT： [0-9]+;  &#x2F;&#x2F;定义词法符号INT, 它由一个或多个数字组成</span><br><span class="line">WS: [\t\r\n]+ -&gt; skip;     &#x2F;&#x2F;定义词法规则“空白符号”，丢弃之。-&gt; skip表示跳过丢弃的意思。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ANTLR 对 g4 文件解析后，会生成如下文件:ArrayInitParser.java, ArrayInitLexer.java,ArrayInit.tokens,ArrayInitLexer.tokens,ArrayInitListener.java:ArrayBaseListener.java.<br>1 ArrayInitParser.java:对应语法 ArrayInit，每条规则对应里面一个方法。<br>2 ArrayInitLexer.java:用于识别词法规则和文法规则。它是通过 ANTLR 分析词法规则 INT 和 WS，以及语法中的字面值‘{’ ‘}‘ ‘,’生成的。<br>3 ArrrayInit.tokens: ANTLR 会给每个我们定义的词法付豪指定一个数字形式的类型，然后将他们的对应关系存储于该文件中。<br>4 ArrayInitListener.java 和 ArrayBaseListener.java: 在遍历 AST 时,遍历器能够触发一系列事件，并通知我们提供的监听器对象。ArrayInitListener 接口给出了这些回调方法的定义，ArrayBaseListener 是该接口的默认实现类，为其中的每个方法提供了一个空实现。</p>
<h3 id="ANTLR-语法基本标记"><a href="#ANTLR-语法基本标记" class="headerlink" title="ANTLR 语法基本标记"></a>ANTLR 语法基本标记</h3><ul>
<li>语法包含一系列描述语言结构的规则。这些规则既包括类似 stat 和 expr 的描述语法结构的规则，也包括描述标识符和整数之类的词汇符号的规则</li>
<li>语法分析器的规则以小写字母开头</li>
<li>词法分析器的规则以大写字母开头</li>
</ul>
<h3 id="语法规则-1"><a href="#语法规则-1" class="headerlink" title="语法规则"></a>语法规则</h3><ul>
<li>我们使用|来分隔同一个语言规则的若干备选分支，使用圆括号把一些符号组合成自规则。例如，子规则(‘*‘|’/‘)匹配一个乘法符号或者触发符号。</li>
<li>使用?表达一个或 0 个，使用*表达多个或 0 个，使用+表达至少 1 个。</li>
<li>词法符号依赖，比如(),[],{}等。成对出现的符号。符号使用’’包裹起来。</li>
<li>处理嵌套模式可以使用递归规则处理，规则的定义中包含对自身的调用。有规则直接引用自身称为直接递归，规则间接引用自身称为间接递归。</li>
<li>处理优先级，左结合。ANTLR 在解析输入的语句的时候采用左结合的特性，当处理“1+2*3”的时候，就会先处理加法。这样是有问题的，解决这个问题的办法是在定义语法的时候，乘法的语法写在加法前面，这样，ANTLR 会优先匹配乘法，然后再匹配除法。</li>
<li>#标签可以标注备选分支，为每个备选分支单独生成一个监听器方法。如果没有#进行标注，则之后语法规则名对应的一个监听器方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expr: &lt;assign&#x3D;right&gt; expr &#39;^&#39; expr #Index</span><br><span class="line">      | expr &#39;*&#39; expr #Mult</span><br><span class="line">      | expr &#39;+&#39; expr #Add</span><br><span class="line">      | INT</span><br><span class="line">      ;</span><br></pre></td></tr></table></figure>

<p>但是，向指数运算这种右结合的情况，就需要使用<code>&lt;assign=right&gt;</code>单独指定。</p>
<h4 id="左递归"><a href="#左递归" class="headerlink" title="左递归"></a>左递归</h4><ul>
<li>左递归规则含义：在某个备选分支的最左侧位置，直接或间接调用了自身。例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr: INT|ID|&#39;(&#39;expr&#39;)&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>带有优先级的左递归。在面对 1+2<em>3 这样的输入是，根据优先级原则，会按照 1+(2</em>3)来处理。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expr: expr &#39;*&#39; expr</span><br><span class="line">    | expr &#39;+&#39; expr</span><br><span class="line">    | INT</span><br><span class="line">    | ID</span><br><span class="line">    ；</span><br></pre></td></tr></table></figure>

<ul>
<li>ANTLR 通过下列四种子表达式运算模式来认定一条规则为左递归规则。<ul>
<li>二元。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr: ...</span><br><span class="line">    | expr (&#39;&lt;&#39; | &#39;&gt;&#39; | &#39;&#x3D; &#39;) expr</span><br><span class="line">    ...</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure></li>
<li>三元<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr: ...</span><br><span class="line">    | expr &#39;?&#39; expr &#39;:&#39; expr</span><br><span class="line">    ...</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure></li>
<li>一元前缀<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expr:...</span><br><span class="line">    |&#39;(&#39; type &#39;)&#39; expr</span><br><span class="line">    ...</span><br><span class="line">    |(&#39;+&#39;|&#39;-&#39;|&#39;++&#39;|&#39;--&#39;) expr</span><br><span class="line">    ...</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure></li>
<li>一元后缀<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expr:...</span><br><span class="line">    |expr ‘.’ Identifier</span><br><span class="line">    ...</span><br><span class="line">    |expr &#39;.&#39; &#39;super&#39; &#39;(&#39; exprList? &#39;)&#39;</span><br><span class="line">    ...</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="词法规则"><a href="#词法规则" class="headerlink" title="词法规则"></a>词法规则</h3><ul>
<li><p>匹配标识符<code>ID: [a-zA-Z]+;</code></p>
</li>
<li><p>匹配数字<code>ID: [0-9]+;</code></p>
</li>
<li><p>匹配字符串常量。<code>STINRG: &#39;&quot;&#39; .*? &#39;&quot;&#39;</code>。点通配符匹配任意的单个字符。因此，*.就是一个循环，它匹配零个或多个字符组成的任意字符序列。显然，它可以一直匹配到文件结束，但这没有任何意义。为解决这个问题，ANTLR 通过标准正则表达式的标记‘？’，提供了对非贪婪匹配子规则的支持。非贪婪匹配的基本含义是：“获取一些字符，直到发现匹配后续子规则的字符为止”。更准确的描述是，在保证整个父规则完成匹配的前提下，非贪婪子规则匹配数量最少的字符。不过目前这个字符串不支持字符串内包含双引号。</p>
</li>
<li><p>匹配注释并丢弃。<code>COMMENT:&#39;/*&#39; ,*? &#39;*/&#39; -&gt; skip;</code>. skip 是丢弃的含义。</p>
</li>
<li><p>匹配空白字符并丢弃。 <code>WS:[\t\n\r]+ -&gt; skip</code></p>
</li>
</ul>
<h2 id="ANTLR-解析过程的异常处理"><a href="#ANTLR-解析过程的异常处理" class="headerlink" title="ANTLR 解析过程的异常处理"></a>ANTLR 解析过程的异常处理</h2><p>ANTLR 语法分析器能够自动报告语法错误并从错误中恢复继续工作。比如前一个错误的表达式，则输出错误信息。然后继续正确地解析第二个表达式。<br>ANTLR 的错误处理机制有很高的灵活性。我们可以修改输出的错误信息，捕获识别过程中的异常，甚至改变基本的异常处理策略。</p>
<h2 id="在语法和词法文件中添加动作"><a href="#在语法和词法文件中添加动作" class="headerlink" title="在语法和词法文件中添加动作"></a>在语法和词法文件中添加动作</h2><h3 id="定制语法分析"><a href="#定制语法分析" class="headerlink" title="定制语法分析"></a>定制语法分析</h3><ul>
<li>在语法中嵌入任意动作<br>我们创建一个构造器，这样我们就能传入希望提取的列号；另外，我们需要在 row 规则的”(…)+”循环中放置一些动作。<br>下面的例子，是将输入文本中的指定列显示出来。<br>详细的内容，会在第 10 章。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">grammar Rows;</span><br><span class="line"></span><br><span class="line">@parser::members &#123; &#x2F;&#x2F; add members to generated RowsParser</span><br><span class="line">int col;</span><br><span class="line">public RowsParser(TokenStream input, int col) &#123; &#x2F;&#x2F; custom constructor</span><br><span class="line">this(input);</span><br><span class="line">this.col &#x3D; col;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file: (row NL)+ ;</span><br><span class="line"></span><br><span class="line">row</span><br><span class="line">locals [int i&#x3D;0]</span><br><span class="line">: ( STUFF</span><br><span class="line">&#123;</span><br><span class="line">$i++;</span><br><span class="line">          if ( $i &#x3D;&#x3D; col ) System.out.println(\$STUFF.text);</span><br><span class="line">&#125;</span><br><span class="line">)+</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">TAB : &#39;\t&#39; -&gt; skip ; &#x2F;&#x2F; match but don&#39;t pass to the parser</span><br><span class="line">NL : &#39;\r&#39;? &#39;\n&#39; ; &#x2F;&#x2F; match and pass to the parser</span><br><span class="line">STUFF: ~[\t\r\n]+ ; &#x2F;&#x2F; match any chars except tab, newline</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用语义判定改变语法分析过程(第 11 章)<br>下面的语法用来处理一组整数”2 9 10 3 1 2 3”。第一个数字 2 代表接下来匹配两个数组 9 和 10。紧接着数字 3 告诉我们匹配接下来的三个数字。<br>我们的目标是创建一份名为 Data 的语法，将 9 和 10 分为一组，然后 1,2,3 分为一组。<br>Data 语法的关键在于一段动作，它的值是布尔类型的，称为一个语义判定:{$i&lt;=$n&gt;}?。它的值在匹配到 n 个输入整数之前保持为 true,其中 n 是 sequence<br>语法中的参数。当语义判定的值为 false 时，对应的备选分支就从语法中“消失”了，因此，它也就从生成的语法分析器中“消失”了。在本例中，语义判定的值为 false 使得”(…)*“循环终止，从 sequence 规则返回。<br><img src="/images/antlr/4-4.png"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">grammar Data;</span><br><span class="line"></span><br><span class="line">file : group+ ;</span><br><span class="line"></span><br><span class="line">group: INT sequence[$INT.int] ;</span><br><span class="line"></span><br><span class="line">sequence[int n]</span><br><span class="line">locals [int i &#x3D; 1;]</span><br><span class="line">: ( &#123;$i&lt;&#x3D;$n&#125;? INT &#123;\$i++;&#125; )\* &#x2F;&#x2F; match n integers</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">INT : [0-9]+ ; &#x2F;&#x2F; match integers</span><br><span class="line">WS : [ \t\n\r]+ -&gt; skip ; &#x2F;&#x2F; toss out all whitespace</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="定制词法分析"><a href="#定制词法分析" class="headerlink" title="定制词法分析"></a>定制词法分析</h3><ul>
<li>孤岛语法:处理相同文件中的不同格式<br>mode INSIDE 定义模式，INSIDE 模式用于识别 XML 标签，默认模式用于识别标签之外的文本。<br>-&gt;定义了动作进入到 INSIDE 模式下<br>-&gt;定义了动作 popMode，从 INSIDE 模式下退出。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">lexer grammar XMLLexer;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Default &quot;mode&quot;: Everything OUTSIDE of a tag</span><br><span class="line">OPEN : &#39;&lt;&#39; -&gt; pushMode(INSIDE) ;</span><br><span class="line">COMMENT : &#39;&lt;!--&#39; .*? &#39;--&gt;&#39; -&gt; skip ;</span><br><span class="line">EntityRef : &#39;&amp;&#39; [a-z]+ &#39;;&#39; ;</span><br><span class="line">TEXT : ~(&#39;&lt;&#39;|&#39;&amp;&#39;)+ ; &#x2F;&#x2F; match any 16 bit char minus &lt; and &amp;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------------- Everything INSIDE of a tag ---------------------</span><br><span class="line">mode INSIDE;</span><br><span class="line"></span><br><span class="line">CLOSE : &#39;&gt;&#39; -&gt; popMode ; &#x2F;&#x2F; back to default mode</span><br><span class="line">SLASH_CLOSE : &#39;&#x2F;&gt;&#39; -&gt; popMode ;</span><br><span class="line">EQUALS : &#39;&#x3D;&#39; ;</span><br><span class="line">STRING : &#39;&quot;&#39; ._? &#39;&quot;&#39; ;</span><br><span class="line">SlashName : &#39;&#x2F;&#39; Name ;</span><br><span class="line">Name : ALPHA (ALPHA|DIGIT)_ ;</span><br><span class="line">S : [ \t\r\n] -&gt; skip ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">ALPHA : [a-zA-Z] ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">DIGIT : [0-9] ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>重写输入流<br>TokenStreamRewriter 对象可以改写输入的 TokenStream。关键之处，TokenStreamRewriter 对象实际上修改的是词法符号流的“视图”而非词法符号流本身。它认为所有对修改方法的调用都只是一个“指令”，然后将这些修改放入一个队列；在未来词法符号流被重新渲染为文本时，这些修改才会被执行。在每次我们调用 getText()的时候，rewriter 对象都会执行上述队列中的指令。</p>
<p>这样的方法在源代码插桩或者重构等场合下非常有效。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class InsertSerialIDListener extends JavaBaseListener &#123;</span><br><span class="line">TokenStreamRewriter rewriter;</span><br><span class="line">public InsertSerialIDListener(TokenStream tokens) &#123;</span><br><span class="line">rewriter &#x3D; new TokenStreamRewriter(tokens);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void enterClassBody(JavaParser.ClassBodyContext ctx) &#123;</span><br><span class="line">        String field &#x3D; &quot;\n\tpublic static final long serialVersionUID &#x3D; 1L;&quot;;</span><br><span class="line">        rewriter.insertAfter(ctx.start, field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>将词法符号送入不同通道<br>忽略却保留注释和空白字符的秘诀是将这些词法符号送入一个“隐藏通道”。语法分析器只处理一个通道，因此我们可以将希望保留的词法符号送入其他通道内。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">COMMENT</span><br><span class="line">: &#39;&#x2F;_&#39; ._? &#39;_&#x2F;&#39; -&gt; channel(HIDDEN) &#x2F;&#x2F; match anything between &#x2F;_ and \*&#x2F;</span><br><span class="line">;</span><br><span class="line">WS : [ \r\t\u000C\n]+ -&gt; channel(HIDDEN)</span><br><span class="line">;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="将生成的语法分析器与-Java-程序集成，并使用监听器遍历处理"><a href="#将生成的语法分析器与-Java-程序集成，并使用监听器遍历处理" class="headerlink" title="将生成的语法分析器与 Java 程序集成，并使用监听器遍历处理"></a>将生成的语法分析器与 Java 程序集成，并使用监听器遍历处理</h2><h3 id="例子-1-1"><a href="#例子-1-1" class="headerlink" title="例子 1"></a>例子 1</h3><p>Test.java<br>此例子的目标是将 Java 中，类似{99, 3, 451}的 short 数组翻译成”\u0063\u0003\u01c3”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.antlr.v4.runtime._;</span><br><span class="line">import org.antlr.v4.runtime.tree._;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void amin(String[] args) throws Exception&#123;</span><br><span class="line">&#x2F;&#x2F;新建一个 CharStream，从标准输入读取数据</span><br><span class="line">ANTLRInputStream input &#x3D; new ANTLRInputStream(System.in);</span><br><span class="line">&#x2F;&#x2F;新建一个词法分析器，处理输入的 CharStream</span><br><span class="line">ArrayInitLexer lexer &#x3D; new ArrayInitLexer(input);</span><br><span class="line">&#x2F;&#x2F;新建一个词法符号的缓冲区，用于存储词法分析器将生成的词法符号</span><br><span class="line">CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">&#x2F;&#x2F;新建一个语法分析器，处理词法符号缓冲区中的内容</span><br><span class="line">ArrayInitParser parser &#x3D; new ArrayInitParser(tokens);</span><br><span class="line">ParseTree tree &#x3D; parser.init(); &#x2F;&#x2F;针对 init 规则，开始语法分析。因为 init 规则是这些规则中根规则，所以适合从 init 开始分析</span><br><span class="line">&#x2F;_System.out.println(tree.toStringTree(parser));&#x2F;&#x2F;用 LISP 风格打印生成的树_&#x2F;</span><br><span class="line">&#x2F;&#x2F;新建一个通用的、能够触发回调函数的语法分析树遍历器</span><br><span class="line">ParseTreeWalker walker &#x3D; new ParseTreeWalker();</span><br><span class="line">&#x2F;&#x2F;遍历语法分析过程中生成的语法分析树，触发回调</span><br><span class="line">walker.walk(new ShortToUnicodeString(), tree);</span><br><span class="line">System.out.println();&#x2F;&#x2F;翻译完成后，打印一个\n</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ShortToUnicodeString.java<br>当遍历 AST 的时候，会对监听器里的方法进行回调。ArrayInitBaseListener 实现了 ArrayInitListener 接口的每个方法，我们只需要继承 ArrayInitBaseListener 并重写自己感兴趣的方法，就可以达到目的。ShortToUnicodeString 中的方法将翻译输入数据的一部分并将结果打印出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;将类似&#123;1,2,3&#125;的 short 数组初始化语句翻译为&quot;\u0001\u0002\u0003&quot;</span><br><span class="line">public class ShortToUnicodeString extends ArrayInitBaseListener &#123;</span><br><span class="line">&#x2F;&#x2F;将&#123;翻译为&quot;</span><br><span class="line">@Override</span><br><span class="line">public void enterInit(ArrayInitParser.InitContext ctx)&#123;</span><br><span class="line">System.out.print(&#39;&quot;&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将&#125;翻译为&quot;</span><br><span class="line">@Override</span><br><span class="line">public void exitInit(ArrayInitParser.InitContext ctx)&#123;</span><br><span class="line">System.out.print(&#39;&quot;&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将每个整数翻译为四位的十六进制形式，然后加前缀\u</span><br><span class="line">@Override</span><br><span class="line">public void enterValue(ArrrayInitParser.ValueContext ctx) &#123;</span><br><span class="line">&#x2F;&#x2F;假定不存在嵌套结构</span><br><span class="line">int value &#x3D; Integer.valueOf(ctx.INT().getText());&#x2F;&#x2F;ctx 是 value 的上下文对象，它获取 INT 词法符号对应的整数值。</span><br><span class="line">System.out.printf(&quot;\\u%04x&quot;, value);&#x2F;&#x2F;输出 16 进制数，总共占 4 为，前面的空位补 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h3><p>LibExpr.g4<br>此例子用来展示，将语法词法规则分布到多个不同文件中。<br>使用 import 功能，可以将一个大的语法文件分隔成小的，然后 import 导入连到一起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">grammar LibExpr; &#x2F;&#x2F; Rename to distinguish from original</span><br><span class="line">import CommonLexerRules; &#x2F;&#x2F; includes all rules from CommonLexerRules.g4</span><br><span class="line">&#x2F;\*_ The start rule; begin parsing here. _&#x2F;</span><br><span class="line">prog: stat+ ;</span><br><span class="line"></span><br><span class="line">stat: expr NEWLINE</span><br><span class="line">| ID &#39;&#x3D;&#39; expr NEWLINE</span><br><span class="line">| NEWLINE</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr: expr (&#39;\*&#39;|&#39;&#x2F;&#39;) expr &#x2F;&#x2F;左递归</span><br><span class="line">| expr (&#39;+&#39;|&#39;-&#39;) expr</span><br><span class="line">| INT</span><br><span class="line">| ID</span><br><span class="line">| &#39;(&#39; expr &#39;)&#39;</span><br><span class="line">;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>CommonLexerRules.g4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">lexer grammar CommonLexerRules; &#x2F;&#x2F; note &quot;lexer grammar&quot;</span><br><span class="line"></span><br><span class="line">ID : [a-zA-Z]+ ; &#x2F;&#x2F; match identifiers</span><br><span class="line">INT : [0-9]+ ; &#x2F;&#x2F; match integers</span><br><span class="line">NEWLINE:&#39;\r&#39;? &#39;\n&#39; ; &#x2F;&#x2F; return newlines to parser (end-statement signal)</span><br><span class="line">WS : [ \t]+ -&gt; skip ; &#x2F;&#x2F; toss out whitespace. &#39;-&gt; skip&#39;是丢弃操作。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ExprJoyRide.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.antlr.v4.runtime._;</span><br><span class="line">import org.antlr.v4.runtime.tree._;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">public class ExprJoyRide &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F;新建输入流</span><br><span class="line">String inputFile &#x3D; null;</span><br><span class="line">if ( args.length&gt;0 ) inputFile &#x3D; args[0];</span><br><span class="line">InputStream is &#x3D; System.in;</span><br><span class="line">if ( inputFile!&#x3D;null ) is &#x3D; new FileInputStream(inputFile);</span><br><span class="line">ANTLRInputStream input &#x3D; new ANTLRInputStream(is);</span><br><span class="line">&#x2F;&#x2F;新建词法分析器和语法分析器</span><br><span class="line">ExprLexer lexer &#x3D; new ExprLexer(input);</span><br><span class="line">CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">ExprParser parser &#x3D; new ExprParser(tokens);</span><br><span class="line">&#x2F;&#x2F;启动语法分析器开始解析</span><br><span class="line">ParseTree tree &#x3D; parser.prog();</span><br><span class="line">&#x2F;&#x2F;用文本形式将该规则方法 prog()返回的语法分析树打印出来</span><br><span class="line">System.out.println(tree.toStringTree(parser));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="例子-3-访问器"><a href="#例子-3-访问器" class="headerlink" title="例子 3 访问器"></a>例子 3 访问器</h3><p>LabeledExpr.g4<br>为每个备选分支定义一个标签，标签以#开头。这样 ANTLR 会为每个备选分支生成不同的访问器方法。这样我们就可以对每种输入都获得一个不同的事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">grammar LabeledExpr; &#x2F;&#x2F; rename to distinguish from Expr.g4</span><br><span class="line"></span><br><span class="line">prog: stat+ ;</span><br><span class="line"></span><br><span class="line">stat: expr NEWLINE # printExpr</span><br><span class="line">| ID &#39;&#x3D;&#39; expr NEWLINE # assign</span><br><span class="line">| NEWLINE # blank</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr: expr op&#x3D;(&#39;_&#39;|&#39;&#x2F;&#39;) expr # MulDiv</span><br><span class="line">| expr op&#x3D;(&#39;+&#39;|&#39;-&#39;) expr # AddSub</span><br><span class="line">| INT # int</span><br><span class="line">| ID # id</span><br><span class="line">| &#39;(&#39; expr &#39;)&#39; # parens</span><br><span class="line">;</span><br><span class="line">&#x2F;&#x2F;接下来我们为运算符词法符号定义一些名字，这样在随后的访问器中，我们就可以将这些词法符号的名字当做 JAVA 常量来引用。</span><br><span class="line">MUL : &#39;_&#39; ; &#x2F;&#x2F; assigns token name to &#39;\*&#39; used above in grammar</span><br><span class="line">DIV : &#39;&#x2F;&#39; ;</span><br><span class="line">ADD : &#39;+&#39; ;</span><br><span class="line">SUB : &#39;-&#39; ;</span><br><span class="line">ID : [a-zA-Z]+ ; &#x2F;&#x2F; match identifiers</span><br><span class="line">INT : [0-9]+ ; &#x2F;&#x2F; match integers</span><br><span class="line">NEWLINE:&#39;\r&#39;? &#39;\n&#39; ; &#x2F;&#x2F; return newlines to parser (is end-statement signal)</span><br><span class="line">WS : [ \t]+ -&gt; skip ; &#x2F;&#x2F; toss out whitespace</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Calc &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">String inputFile &#x3D; null;</span><br><span class="line">if ( args.length&gt;0 ) inputFile &#x3D; args[0];</span><br><span class="line">InputStream is &#x3D; System.in;</span><br><span class="line">if ( inputFile!&#x3D;null ) is &#x3D; new FileInputStream(inputFile);</span><br><span class="line">ANTLRInputStream input &#x3D; new ANTLRInputStream(is);</span><br><span class="line">LabeledExprLexer lexer &#x3D; new LabeledExprLexer(input);</span><br><span class="line">CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">LabeledExprParser parser &#x3D; new LabeledExprParser(tokens);</span><br><span class="line">ParseTree tree &#x3D; parser.prog(); &#x2F;&#x2F; parse</span><br><span class="line">&#x2F;&#x2F;实例化一个自定义的访问器，然后访问 tree</span><br><span class="line">EvalVisitor eval &#x3D; new EvalVisitor();</span><br><span class="line">eval.visit(tree);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用如下命令可以生成 visitor<br><code>antlr4 -no-listener -visitor LabeledExpr.g4</code><br>可以生成，LabeledExprBaseVisitor.java,LabeledExprParse.java,LabeledExprLexer.java,LabeledExprVisitor.java。<br>LabeledExprVisitor 是接口，LabeledExprBaseVisitor 是默认实现类。我们可以继承 LabeledExprBaseVisitor 然后重写里面的函数来实现自定义的逻辑。<br>EvalVisitor 内重写的方法对应备选分支的标签。里面引用的 JAVA 常量如：MUL，DIV 等。也是在语法文件中定义的词法符号名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class EvalVisitor extends LabeledExprBaseVisitor&lt;Integer&gt; &#123;</span><br><span class="line">&#x2F;\*_ &quot;memory&quot; for our calculator; variable&#x2F;value pairs go here _&#x2F;</span><br><span class="line">Map&lt;String, Integer&gt; memory &#x3D; new HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;** ID &#39;&#x3D;&#39; expr NEWLINE *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitAssign(LabeledExprParser.AssignContext ctx) &#123;</span><br><span class="line">        String id &#x3D; ctx.ID().getText();  &#x2F;&#x2F; id is left-hand side of &#39;&#x3D;&#39;</span><br><span class="line">        int value &#x3D; visit(ctx.expr());   &#x2F;&#x2F; compute value of expression on right</span><br><span class="line">        memory.put(id, value);           &#x2F;&#x2F; store it in our memory</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** expr NEWLINE *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitPrintExpr(LabeledExprParser.PrintExprContext ctx) &#123;</span><br><span class="line">        Integer value &#x3D; visit(ctx.expr()); &#x2F;&#x2F; evaluate the expr child</span><br><span class="line">        System.out.println(value);         &#x2F;&#x2F; print the result</span><br><span class="line">        return 0;                          &#x2F;&#x2F; return dummy value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** INT *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitInt(LabeledExprParser.IntContext ctx) &#123;</span><br><span class="line">        return Integer.valueOf(ctx.INT().getText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** ID *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitId(LabeledExprParser.IdContext ctx) &#123;</span><br><span class="line">        String id &#x3D; ctx.ID().getText();</span><br><span class="line">        if ( memory.containsKey(id) ) return memory.get(id);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** expr op&#x3D;(&#39;*&#39;|&#39;&#x2F;&#39;) expr *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitMulDiv(LabeledExprParser.MulDivContext ctx) &#123;</span><br><span class="line">        int left &#x3D; visit(ctx.expr(0));  &#x2F;&#x2F; get value of left subexpression</span><br><span class="line">        int right &#x3D; visit(ctx.expr(1)); &#x2F;&#x2F; get value of right subexpression</span><br><span class="line">        if ( ctx.op.getType() &#x3D;&#x3D; LabeledExprParser.MUL ) return left * right;</span><br><span class="line">        return left &#x2F; right; &#x2F;&#x2F; must be DIV</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** expr op&#x3D;(&#39;+&#39;|&#39;-&#39;) expr *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitAddSub(LabeledExprParser.AddSubContext ctx) &#123;</span><br><span class="line">        int left &#x3D; visit(ctx.expr(0));  &#x2F;&#x2F; get value of left subexpression</span><br><span class="line">        int right &#x3D; visit(ctx.expr(1)); &#x2F;&#x2F; get value of right subexpression</span><br><span class="line">        if ( ctx.op.getType() &#x3D;&#x3D; LabeledExprParser.ADD ) return left + right;</span><br><span class="line">        return left - right; &#x2F;&#x2F; must be SUB</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** &#39;(&#39; expr &#39;)&#39; *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitParens(LabeledExprParser.ParensContext ctx) &#123;</span><br><span class="line">        return visit(ctx.expr()); &#x2F;&#x2F; return child expr&#39;s value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子 4"></a>例子 4</h3><p>使用监听器来对 java 语法进行分析，根据实现类可以生成对应的接口定义，并保留注释<br>Java.g4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">classDeclaration</span><br><span class="line">: &#39;class&#39; Identifier typeParameters? (&#39;extends&#39; type)?</span><br><span class="line">(&#39;implements&#39; typeList)?</span><br><span class="line">classBody</span><br><span class="line">;</span><br><span class="line">methodDeclaration</span><br><span class="line">: type Identifier formalParameters (&#39;[&#39; &#39;]&#39;)\* methodDeclarationRest</span><br><span class="line">| &#39;void&#39; Identifier formalParameters methodDeclarationRest</span><br><span class="line">;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ExtractInterfaceListener.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ExtractInterfaceListener extends JavaBaseListener &#123;</span><br><span class="line">JavaParser parser;</span><br><span class="line">public ExtractInterfaceListener(JavaParser parser) &#123;this.parser &#x3D; parser;&#125;</span><br><span class="line">&#x2F;\*_ Listen to matches of classDeclaration _&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public void enterClassDeclaration(JavaParser.ClassDeclarationContext ctx)&#123;</span><br><span class="line">System.out.println(&quot;interface I&quot;+ctx.Identifier()+&quot; &#123;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void exitClassDeclaration(JavaParser.ClassDeclarationContext ctx) &#123;</span><br><span class="line">System.out.println(&quot;&#125;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Listen to matches of methodDeclaration *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void enterMethodDeclaration(</span><br><span class="line">        JavaParser.MethodDeclarationContext ctx</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; need parser to get tokens</span><br><span class="line">        TokenStream tokens &#x3D; parser.getTokenStream();</span><br><span class="line">        String type &#x3D; &quot;void&quot;;&#x2F;&#x2F;type为方法的返回类型</span><br><span class="line">        if ( ctx.type()!&#x3D;null ) &#123;</span><br><span class="line">            type &#x3D; tokens.getText(ctx.type());</span><br><span class="line">        &#125;</span><br><span class="line">        String args &#x3D; tokens.getText(ctx.formalParameters());&#x2F;&#x2F;args是入参</span><br><span class="line">        System.out.println(&quot;\t&quot;+type+&quot; &quot;+ctx.Identifier()+args+&quot;;&quot;);&#x2F;&#x2F;ctx.Identifier()是方法名</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ExtractInterfaceTool.java<br>将自定义的监听器集成到程序里，并遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ExtractInterfaceTool &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">String inputFile &#x3D; null;</span><br><span class="line">if ( args.length&gt;0 ) inputFile &#x3D; args[0];</span><br><span class="line">InputStream is &#x3D; System.in;</span><br><span class="line">if ( inputFile!&#x3D;null ) &#123;</span><br><span class="line">is &#x3D; new FileInputStream(inputFile);</span><br><span class="line">&#125;</span><br><span class="line">ANTLRInputStream input &#x3D; new ANTLRInputStream(is);</span><br><span class="line"></span><br><span class="line">        JavaLexer lexer &#x3D; new JavaLexer(input);</span><br><span class="line">        CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">        JavaParser parser &#x3D; new JavaParser(tokens);</span><br><span class="line">        ParseTree tree &#x3D; parser.compilationUnit(); &#x2F;&#x2F; parse。开始语法分析的过程</span><br><span class="line"></span><br><span class="line">        ParseTreeWalker walker &#x3D; new ParseTreeWalker(); &#x2F;&#x2F; create standard walker，新建一个标准的遍历器</span><br><span class="line">        ExtractInterfaceListener extractor &#x3D; new ExtractInterfaceListener(parser);</span><br><span class="line">        walker.walk(extractor, tree); &#x2F;&#x2F; initiate walk of tree with listener，使用监听器初始化对语法分析树的遍历</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="错误报告与恢复"><a href="#错误报告与恢复" class="headerlink" title="错误报告与恢复"></a>错误报告与恢复</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>ANTLR 在解析语法的时候，可以发现语法和词法的错误并给予提醒，尽管语法有错误，语法分析过程还是照常进行。除了产生良好的错误消息和利用剩余的输入进行重新同步之外，语法分析器还必须能够移动到何时的位置继续语法分析过程。</p>
<h3 id="修改和转发-ANTLR-的错误消息"><a href="#修改和转发-ANTLR-的错误消息" class="headerlink" title="修改和转发 ANTLR 的错误消息"></a>修改和转发 ANTLR 的错误消息</h3><h4 id="处理语法错误信息"><a href="#处理语法错误信息" class="headerlink" title="处理语法错误信息"></a>处理语法错误信息</h4><p>默认情况下，ANTLR 将所有的错误消息送至标准错误(standard error)，不过我们可以通过实现接口 ANTLRErrorListener 来改变这些消息的目标输出和内容。该接口有一个同时应用于词法分析器和语法分析器的 syntaxError()方法。syntaxError()方法接收各式各样的信息无论是错误的位置还是错误的内容。它还接收指向语法分析器的引用，因此我们能够通过引用来查询识别过程的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static class VerboseListener extends BaseErrorListener &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void syntaxError(Recognizer&lt;?,?&gt; recognizer,</span><br><span class="line">                            Object offendingSymbol,</span><br><span class="line">                            int line, int charPositionInLine,</span><br><span class="line">                            String msg,</span><br><span class="line">                            RecognitionException e) &#123;</span><br><span class="line">        List&lt;String&gt; stack &#x3D; ((Parser)recognizer).getRuleInvocationStack();</span><br><span class="line">        Collections.reverse(stack);</span><br><span class="line">        System.err.println(&quot;rule stack:&quot;+stack);</span><br><span class="line">        System.err.println(&quot;line&quot;+line+&quot;;&quot;+charPositionInLine+&quot;at&quot;+offendingSymbol+&quot;;&quot;+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这种方法，我们的程序就能在语法分析器调用其实规则之前，轻易地为其增加一个错误监听器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SimpleParser parser &#x3D; new SimpleParser(tokens);</span><br><span class="line">parser.removeErrorListeners();</span><br><span class="line">parser.addErrorListener(new VerboseListener());</span><br><span class="line">parser.prog;</span><br></pre></td></tr></table></figure>

<p>在我们增加自定义的错误监听器之前，我们需要移除输出目标是控制台的内置错误监听器，以防出现重复的错误消息。</p>
<h4 id="处理有歧义的语法信息"><a href="#处理有歧义的语法信息" class="headerlink" title="处理有歧义的语法信息"></a>处理有歧义的语法信息</h4><p>有时候用户输入的语法可以匹配到我们定义的多个语法分支，这是就存在歧义，默认情况下语法分析器不会通知用户，因为这不是用户的错。而是，我们定义的语法规则的问题。如果希望通知用于，则请使用 addErrorListener()方法添加一个 DiagnosticErrorListener 的实例来告知语法分析器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parser.removeErrorListeners();&#x2F;&#x2F;移除ConsoleErrorListener</span><br><span class="line">parser.addErrorListener(new DiagnosticErrorListener());</span><br></pre></td></tr></table></figure>

<p>此外，你还应当告诉语法分析器，你对所有的歧义告警都感兴趣，而不仅仅是哪些可以快速检测到的。出于效率方面的原因，ANTLR 的决策机制并不是总能发现所有的歧义信息。下面是令语法分析器报告所有歧义的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.getInterpreter().setPredictionMode(PredictionMode.LL_EXACT_AMBIG_DETECTION);</span><br></pre></td></tr></table></figure>

<p>在开发过程中使用上面提到的诊断错误监听器是个好主意，因为 ANTLR 工具不会对歧义性语法结构提出静态告警。在 ANTLR4 中，只有运行状态的语法分析器才能检测到歧义。这就像是 Java 中静态类型机制和 Python 中动态类型机制的差别。</p>
<h3 id="自动错误恢复机制"><a href="#自动错误恢复机制" class="headerlink" title="自动错误恢复机制"></a>自动错误恢复机制</h3><p>错误恢复指的是允许语法分析器在发现语法错误后还能继续的机制。语法分析器在遇到无法匹配词法符号的错误时，执行单词法符号补全和单词法符号移除。如果这些方案不奏效，语法分析器将向后查找词法符号，直到它遇到一个符合当前规则的后续部分的合理词法符号为止，接着，语法分析器将会继续语法分析过程，仿佛什么事情都没有发生过一样。<code>也就是，发生语法错误后从错误中恢复，然后继续语法解析。</code></p>
<ul>
<li>通过扫描后续词法符号来恢复。<br>当面对真正的非法输入时，当前的规则无法继续下去，此时语法分析器将会向后查找词法符号，知道它认为自己已经完成重新同步时，它就返回原先被调用的规则。我们可以成为‘同步-返回’策略。有人称为“应急模式”，不过它的表现相当好。语法分析器知道自己无法使用当前规则匹配当前输入。它会持续丢弃后续词法符号，知道发现一个可以匹配本规则中断位置之后的某条自规则的词法符号。例如，如果在赋值语句中存在一个语法错误，那么语法分析器的做法就非常合理：丢弃后续的词法符号，直到发现一个分好或者其他的语句终结符为止。这种策略较为激进，但是十分有效。我们下面将要看到，这种基本策略作为后备方案，在启用之前，ANTLR 会试图在规则内部进行恢复。<br>重新同步集合是调用栈中所有规则的后续符号集合的并集。<br>例如，如果语法分析其分析到 atom 时报错，比如输入的是“[]”，就会在 atom 的时候报错。调用栈为[group,expr,atom]那么此时的后续符号集合则是{‘^’,’]’}。然后语法分析其就从 atom 的错误中恢复了，然后继续分析，分析 expr 发现缺少^从而产生错误，然后继续从符号集合中恢复。然后匹配 group 最后匹配成功。<br>恢复过程中，ANTLR 语法分析器会避免输出层叠的错误消息，对于每个语法错误，直到成功从错误中恢复，语法分析器才输出一条错误消息。所以本次语法解析过程，实际上是产生了两处解析错误:atom 和 expr<br>注意后续符号集合的生成是动态计算的。是调用栈中所有规则的后续符号的并集。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">group : &#39;[&#39; expr &#39;]&#39; | &#39;(&#39; expr &#39;)&#39;;</span><br><span class="line">expr: atom &#39;^&#39; INT;</span><br><span class="line">atom: ID | INT;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>从不匹配的词法符号中恢复<br>在语法分析的过程中，最常见的操作之一就是“匹配词法符号”。对于语法中的每个词法符号 T，语法分析器都会调用 match(T)。如果当前的词法符号不是 T，match()方法就会通知错误监听器，并试图重新同步。为完成同步，它有三种选择：</p>
<ul>
<li>移除一个词法符号；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classDef: &#39;class&#39; ID &#39;&#123;&#39; member+ &#39;&#125;&#39; &#x2F;&#x2F;a class has one or more members</span><br><span class="line">&#123;System.out.println(&quot;class&quot;+$ID.text);&#125;</span><br></pre></td></tr></table></figure>

<p>考虑输入文本 class 9 T{int i;}，语法分析器会删除 9，然后继续进行同一条规则的语法分析过程–匹配类的定义体。</p>
<ul>
<li>补全一个词法符号；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classDef: &#39;class&#39; ID &#39;&#123;&#39; member+ &#39;&#125;&#39; &#x2F;&#x2F;a class has one or more members</span><br><span class="line">&#123;System.out.println(&quot;class&quot;+$ID.text);&#125;</span><br></pre></td></tr></table></figure>

<p>考虑输入文本 class {int i;}，语法分析器调用 match(ID),期望发现一个标识符，但实际上发现的却是{。这种情况下，语法分析器知道{是自己所期望的那个词法符号的下一个，因为在 classDef 规则中它位于 ID 之后。此时 match()方法可以假定标识符已经被发现并返回，这样，下一个 match(‘{‘)的调用就会成功。在忽略内嵌动作的前提下，这种方案表现得相当出色。但是，如果词法符号是 null，通过$ID.text 引用了缺失词法符号的打印语句就会引起一个异常。因此，错误处理器会创建一个词法符号，而非简单的假定该词法符号存在，详情参见 DefaultErrorStrategy 中的 getMissingSymbol()方法。新创建的词法符号具有语法分析器所期望的类型，以及和当前词法符号 LA（1）相同的行列位置信息。这个新创建的词法符号阻止了监听器和访问其中引用缺失词法符号时引发的异常。<br><img src="/images/antlr/9-6.png"></p>
<ul>
<li><p>从子规则的错误中恢复<br>在语法中手工插入一条空规则的引用，该规则包含特定的、能够在必要时触发错误恢复的动作。现在，ANTLR4 会在开始处和循环条件判定处自动插入同步检查，以避免集锦的恢复机制。</p>
<ul>
<li>子规则起始位置。在任意子规则的起始位置，语法分析器会尝试进行单词法符号移除。不过，和词法符号匹配不同的是，语法分析器不会尝试进行单词法符号补全。创建一个词法符号对 ANTLR 来说是很困难的，因为它必须猜测多个备选分支中的哪个会最终胜出。</li>
<li>子规则的循环条件判定位置。如果子规则是一个循环结构，即(…)*或(…)+，在遇到错误时，语法分析器会尝试进行积极的回复，使得自己留在循环内部。在成功地匹配到循环的某个备选分支之后，语法分析器会持续消费词法符号，直到发现满足下列条件之一的词法符号为止：</li>
<li>循环的另一次迭代</li>
<li>紧跟在循环之后的内容</li>
<li>当前规则的重新同步集合中的元素<br>例子：<br>考虑 Simple 语法的 classDef 规则中的 member+循环结构。如果我们手误多输入了’{‘，member+子规则会在进入 member 之前移除掉多余的那个词法符号。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; class T &#123;&#123;int i;&#125;</span><br><span class="line">&gt; EOF</span><br><span class="line">&gt; line 1:9 extraneous input &#39;&#123;&#39; expecting &#39;int&#39;</span><br><span class="line">var i</span><br><span class="line">class T</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>捕获失败的语义判定<br>语义判定指定了一些必须在运行时为真的条件，以使得语法分析器能够通过这些条件的验证。如果一个判定结果为假，语法分析器会抛出一个 FailedPredicateException 异常，该异常会被当前规则的 catch 语句捕获。语法分析器随机报告一个错误，并运行通用的同步-返回恢复机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vec4: &#39;[&#39; ints[4] &#39;]&#39;;</span><br><span class="line">ints[int max]</span><br><span class="line">locals [int i&#x3D;1]</span><br><span class="line">    : INT(&#39;,&#39; &#123;$i++;&#125; &#123;$i&lt;&#x3D;max&#125;? INT)*</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<p>下列测试给出的整数过多，于是我们看到了一个错误消息，以及错误恢复的过程，在这个过程中，多余的逗号和整数被丢弃了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; [1,2,3,4,5,6]</span><br><span class="line">&gt; EOF</span><br><span class="line">&gt; line 1:9 rule ints failed predicate: &#123;$i&lt;&#x3D;max&#125;?</span><br></pre></td></tr></table></figure>
<p>有时候我们输入的结构语法上是有效的，但是在语义上是无效的，这是，语义判定就不适用了。例如有种语言，要求变量不能被赋值 0.这意味“assignment x =0;”在语法上有效，在语义上无效。<br>较好的解决办法是手工输出一个错误，然后令语法分析器按照正确的语法继续继续进行匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assign</span><br><span class="line">    : ID &#39;&#x3D;&#39; v&#x3D;INT &#123;$v.int&gt;0&#125;? &#39;;&#39;</span><br><span class="line">    &#123;if ($v.int&#x3D;&#x3D;0) notifyListeners(&quot;values must be &gt; 0&quot;);&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>错误恢复机制的防护措施<br>ANTLR 的语法分析器具有内置的防护措施，以保证错误回复过程正常结束。如果我们在相同的语法分析位置，遇到了相同的输入情况，语法分析器会在尝试进行恢复之前强制消费一个词法符号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; class T &#123;</span><br><span class="line">&gt;    int int x;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; EOF</span><br><span class="line">&gt; line 2:6 no viable alternative at input &#39;intint&#39;</span><br><span class="line">&gt; var x</span><br><span class="line">&gt; class T</span><br></pre></td></tr></table></figure>

<p>classDef 规则调用了三次 member。其中，第一个 member 没有匹配到任何内容，第二个 member 匹配到了多余的 int。第三次匹配 member 的尝试正确地匹配到了“int x;”序列。<br><img src="/images/antlr/9-11.png"></p>
</li>
</ul>
</li>
<li><p>简单地抛出一个异常以启用基本的同步-返回机制<br>当面对真正的非法输入时，当前的规则无法继续下去，此时语法分析器将会向后查找词法符号，知道它认为自己已经完成重新同步时，它就返回原先被调用的规则。我们可以成为‘同步-返回’策略。有人称为“应急模式”，不过它的表现相当好。语法分析器知道自己无法使用当前规则匹配当前输入。它会持续丢弃后续词法符号，知道发现一个可以匹配本规则中断位置之后的某条自规则的词法符号。例如，如果在赋值语句中存在一个语法错误，那么语法分析器的做法就非常合适。</p>
</li>
</ul>
<h3 id="勘误备选分支"><a href="#勘误备选分支" class="headerlink" title="勘误备选分支"></a>勘误备选分支</h3><p>一些语法错误十分常见，以至于对它们进行特殊处理是值得的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stat: fcall &#39;;&#39;;</span><br><span class="line">fcall</span><br><span class="line">    : ID &#39;(&#39; expr &#39;)&#39;</span><br><span class="line">    | ID &#39;(&#39; expr &#39;)&#39; &#39;)&#39; &#123;notifyErrorListeners(&quot;Too many parentheses&quot;);&#125;</span><br><span class="line">    | ID &#39;(&#39; expr &#123;notifyErrorListeners(&quot;Missing closing&quot;);&#125;</span><br><span class="line">    ;</span><br><span class="line">expr: &#39;(&#39; expr &#39;)&#39;</span><br><span class="line">    | INT</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<h3 id="修改-ANTLR-的错误处理策略"><a href="#修改-ANTLR-的错误处理策略" class="headerlink" title="修改 ANTLR 的错误处理策略"></a>修改 ANTLR 的错误处理策略</h3><p>默认的错误处理机制表现出色，不过我们还是会遇到一些非典型的，需要修改默认机制的场景。首先，我们希望关闭某些默认的错误处理功能，他们会带来额外的运行负担。其次，我们可能希望语法分析器在遇到第一个语法错误时就退出。这种情况是，当处理类似 bash 的命令行输入时，从错误中回复是毫无意义的。我们不能一意孤星地执行有风险的命令，因此语法分析器可以一遇到问题就退出。探究错误处理策略，不妨看一下 ANTLRErrorStratege 接口及实现类 DefaultError-Strategy，该类完成了全部的默认错误处理工作。利用 ANTLRErrorListener 和 ANTLRErrorStrategy 接口，我们能够非常灵活地指定错误消息的输出位置、错误消息的内容以及语法分析器从错误中恢复的方法。</p>
<h2 id="在语法分析过程中执行自身的逻辑代码"><a href="#在语法分析过程中执行自身的逻辑代码" class="headerlink" title="在语法分析过程中执行自身的逻辑代码"></a>在语法分析过程中执行自身的逻辑代码</h2><p>在之前的学习中，我们的程序逻辑代码都是与语法分析树遍历器分离的，这意味着我们的代码总是在语法分析完成之后执行。在接下来的几节（属性和动作、使用语义判定修改语法分析过程、掌握词法分析的“黑魔法”）中我们可以看到，一些语言类应用程序需要在语法分析的过程中执行自身的逻辑代码。</p>
<h2 id="属性和动作"><a href="#属性和动作" class="headerlink" title="属性和动作"></a>属性和动作</h2><p>通常我们应当避免将语法和应用程序的逻辑代码纠缠在一起。不包含动作的语法更容易阅读，不会绑定到特定的目标语言和程序上。尽管如此，内嵌的动作仍然是有用的，原因有如下三个：</p>
<ul>
<li>简便: 有时，使用少量的动作，避免创建一个监听器或者访问器会使事情变得更加简单。</li>
<li>效率：在资源紧张的程序中，我们可能不想把宝贵的时间和内存浪费在简历语法分析树上。</li>
<li>待判定的语法分析过程：在某些罕见情况下，我们必须依赖从之前的输入流中获取的数据才能正常第进行语法分析过程。一些语法需要建立一个符号表，以便在未来根据情况差异化地识别输入的文本。</li>
</ul>
<p>动作就是使用目标语言编写的、放置在{}中的任意代码块。我们可以在动作中编写任意代码，只要它们是合法的目标语言语句。动作的典型用法是操纵词法符号和规则引用的属性。例如，我们可以读取一个词法符号对应的文本或者整个规则匹配的文本。通过从词法符号和规则引用中获取的数据，我们就可以打印结果或者执行任意计算。规则允许参数和返回值，因此我们可以在规则之间传递数据。</p>
<h3 id="添加动作"><a href="#添加动作" class="headerlink" title="添加动作"></a>添加动作</h3><ol>
<li><p>定义 header 和 members<br>这些动作可以位于规则内，也可以位于规则外。header 用于向自动生成的语法分析器和词法分析器中注入 package 或 import 语句。members 用于向自动生成的语法分析器和词法分析器中注入字段(成员变量)和方法(成员函数)。下面显示了注入代码片段的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;</span><br><span class="line">public class &lt;grammarName&gt;Parser extends Parser &#123;</span><br><span class="line">    &lt;members&gt;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用@header{}和@members{}来注入代码。{}内的代码，将出现在语法和词法解析器中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">grammar Expr;</span><br><span class="line">&#x2F;&#x2F;定义了语法和词法解析器所属的包，并导入了java.util包</span><br><span class="line">@header &#123;</span><br><span class="line">    package tools;</span><br><span class="line">    import java.util.*;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;新增了语法和词法解析器中的字段（成员变量）memory和方法eval()。</span><br><span class="line">@members &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; memory &#x3D; new HashMap&lt;String, Integer&gt;();</span><br><span class="line">    int eval (int left, int op, int right) &#123;</span><br><span class="line">        switch (op) &#123;</span><br><span class="line">            case MUL: return left * right;</span><br><span class="line">            case DIV: return left &#x2F; right;</span><br><span class="line">            case ADD: return left + right;</span><br><span class="line">            case SUB: return left - right;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在规则中嵌入动作<br>动作执行时机是它前面的语法元素之后。本例中，动作出现在备选分支的末尾，因此它们会在语法分析器匹配到整个语句之后被执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stat: e NEWLINE          &#123;System.out.println($e.v);&#125;</span><br><span class="line">    | ID &#39;&#x3D;&#39; e NEWLINE   &#123;memory.put($ID.text, $e.v);&#125;</span><br><span class="line">    | NEWLINE</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<ul>
<li>returns 定义了返回值 v，且类型为 int。通过$e.v 可以引用 e 规则的返回值。</li>
<li>a,b,op 都是标记，它们是对=右侧的引用。使用标记可以方便在动作中操作各种值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">e returns [int v]</span><br><span class="line">    : a&#x3D;e op&#x3D;(&#39;*&#39;|&#39;&#x2F;&#39;) b&#x3D;e &#123;$v &#x3D; eval($a.v, $op.type, $b.v);&#125;</span><br><span class="line">    | a&#x3D;e op&#x3D;(&#39;+&#39;|&#39;-&#39;) b&#x3D;e &#123;$v &#x3D; eval($a.v, $op.type, $b.v);&#125;</span><br><span class="line">    | INT                  &#123;$v &#x3D; $INT.int;&#125;</span><br><span class="line">    | ID</span><br><span class="line">        &#123;</span><br><span class="line">            String id &#x3D; $ID.text;</span><br><span class="line">            $v &#x3D; memory.containsKey(id) ? memory.get(id) : 0;</span><br><span class="line">        &#125;</span><br><span class="line">    | &#39;(&#39; e &#39;)&#39; &#123;$v &#x3D; $e.v;&#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
ANTLR 通过规则上下文对象来实现语法分析树的节点，每次规则调用都会新建并返回一个规则上下文对象。自然地，规则上下文对象非常适合放置与特定规则相关的数据实体。EContext 的第一部分如下所示:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static class EContext extends ParserRuleContext&#123;</span><br><span class="line">    public int v;        &#x2F;&#x2F;规则e的返回值</span><br><span class="line">    public EContext a;   &#x2F;&#x2F;规则引用e上的标记a</span><br><span class="line">    public Token op;     &#x2F;&#x2F;类似（‘*’|‘&#x2F;’）的运算符子规则上的标记</span><br><span class="line">    public EContext b;   &#x2F;&#x2F;规则引用e上的标记b</span><br><span class="line">    public Token INT;    &#x2F;&#x2F;第三个备选分支引用的INT</span><br><span class="line">    public Token ID;     &#x2F;&#x2F;第四个备选分支引用的ID</span><br><span class="line">    public EContext e;   &#x2F;&#x2F;e的调用过程对应的上下文对象的引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="访问词法符号和规则的属性"><a href="#访问词法符号和规则的属性" class="headerlink" title="访问词法符号和规则的属性"></a>访问词法符号和规则的属性</h3><p>此节中可以看到如何定义和引用规则的参数和返回值。<br>原始规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">grammar CSV;</span><br><span class="line"></span><br><span class="line">file : hdr row+;</span><br><span class="line">hdr : row ;</span><br><span class="line">row : field (&#39;,&#39; field)* &#39;\r&#39;? &#39;\n&#39;;</span><br><span class="line">field</span><br><span class="line">    : TEXT   # text</span><br><span class="line">    | STRING # string</span><br><span class="line">    |        # empty</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">TEXT : ~[,\n\r&quot;]+ ;</span><br><span class="line">STRING: &#39;&quot;&#39; (&#39;&quot;&quot;&#39;|~&#39;&quot;&#39;)* &#39;&quot;&#39; ;</span><br></pre></td></tr></table></figure>

<p>改造后的规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 由规则&quot;file: hdr row+ ;&quot;衍生而来 *&#x2F;</span><br><span class="line">file</span><br><span class="line">locals [int i&#x3D;0]</span><br><span class="line">    : hdr ( rows+&#x3D;row[$hdr.text.split(&quot;,&quot;)] &#123;$i++&#125; )+</span><br><span class="line">      &#123;</span><br><span class="line">          System.out.println($i+&quot;rows&quot;);</span><br><span class="line">          for (RowContext r : $rows) &#123;</span><br><span class="line">              System.out.println(&quot;row token interval:&quot;+r.getSourceInterval());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">hdr: row[null] &#123;System.out.println(&quot;header: &#39;&quot;+$text.trim()+&quot;&#39;&quot;);&#125;;</span><br><span class="line">&#x2F;* 由规则&quot;row: field (&#39;,&#39; field)* &#39;\r&#39;? &#39;\n&#39; ;&quot; 衍生而来*&#x2F;</span><br><span class="line">row[String[] columns] returns [Map&lt;String,String&gt; values]</span><br><span class="line">locals [int col&#x3D;0]</span><br><span class="line">@init&#123;</span><br><span class="line">    $values &#x3D; new HashMap&lt;String,String&gt;();</span><br><span class="line">&#125;</span><br><span class="line">@after&#123;</span><br><span class="line">    if ($values!&#x3D;null &amp;&amp; $values.size()&gt;0) &#123;</span><br><span class="line">        System.out.println(&quot;values &#x3D; &quot;+ $values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    : field</span><br><span class="line">        &#123;</span><br><span class="line">            if($columns!&#x3D;null) &#123;</span><br><span class="line">                $values.put($columns[$col++].trim(), $field.text.trim());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        (</span><br><span class="line">            &#39;,&#39; field</span><br><span class="line">            &#123;</span><br><span class="line">                if ($column!&#x3D;null)&#123;</span><br><span class="line">                    $values.put($columns[$col++].trim(), $field.text.trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )* &#39;\r&#39;? &#39;\n&#39;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>输入如下数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User,  Name,   Dept</span><br><span class="line">parrt, Terence, 101</span><br><span class="line">tombu, Tom,     020</span><br><span class="line">bke,   Kevin,   008</span><br></pre></td></tr></table></figure>

<p>输出解析结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">header: &#39;User, Name, Dept&#39;</span><br><span class="line">values &#x3D; &#123;Name&#x3D;Terence, User&#x3D;parrt, Dept&#x3D;101&#125;</span><br><span class="line">values &#x3D; &#123;Name&#x3D;Tom, User&#x3D;tombu, Dept&#x3D;020&#125;</span><br><span class="line">values &#x3D; &#123;Name&#x3D;Kevin, User&#x3D;bke, Dept&#x3D;008&#125;</span><br><span class="line">3 rows</span><br><span class="line">row token interval:6..11</span><br><span class="line">row token interval:12..17</span><br><span class="line">row token interval:18..23</span><br></pre></td></tr></table></figure>

<h3 id="关键字识别"><a href="#关键字识别" class="headerlink" title="关键字识别"></a>关键字识别</h3><p>此节中我们将看到如何使用词法符号属性，text 和 type。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">grammar Keywords;</span><br><span class="line">@lexer::header&#123;</span><br><span class="line">    import java.util.*;</span><br><span class="line">&#125;</span><br><span class="line">@lexer::members&#123;</span><br><span class="line">    Map&lt;String,Integer&gt; keywords &#x3D; new HashMap&lt;String,Integer&gt;() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            put(&quot;begin&quot;, KeywordsParser.BEGIN);</span><br><span class="line">            put(&quot;end&quot;, KeywordsParser.END);</span><br><span class="line">            put(&quot;if&quot;, KeywordsParser.IF);</span><br><span class="line">            put(&quot;then&quot;, KeywordsParser.THEN);</span><br><span class="line">            put(&quot;while&quot;, KeywordsParser.WHILE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">stat: BEGIN stat* END</span><br><span class="line">    | IF expr THEN stat</span><br><span class="line">    | WHILE expr stat</span><br><span class="line">    | ID &#39;&#x3D;&#39; expr &#39;;&#39;</span><br><span class="line">        ;</span><br><span class="line">expr: INT|CHAR;</span><br><span class="line">ID: [a-zA-Z]+&#123;</span><br><span class="line">    if(keywords.containsKey(getText()))&#123;</span><br><span class="line">        setType(keywords.get(getText()));&#x2F;&#x2F;重置词法符号类型</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">CHAR: &#39;\&#39;&#39;.&#39;\&#39;&#39;&#123;setText(String.valueOf(getText().charAt(1)))&#125;;</span><br><span class="line">tokens &#123;BEGIN, END, IF , THEN, WHILE&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用语义判定修改语法分析过程"><a href="#使用语义判定修改语法分析过程" class="headerlink" title="使用语义判定修改语法分析过程"></a>使用语义判定修改语法分析过程</h2><p>在上节中，内嵌动作仅仅是计算一些值或者打印结果。但是，某些情况下使用内嵌动作类修改语法分析过程是正确识别某些编程语言语句的唯一方案。本章我们学习一种特殊的动作{…}?,成为语义判定，它允许我们在运行时选择性地关闭部分语法。判定本身就是布尔表达式，它会减少语法分析器的在语法分析过程中可选项的数量。适当地减少可选项的数量会增强语法分析器的性能。在词法规则中使用判定，一样会拖慢词法分析器。<br>语义判定可以在两种常见情况下发挥作用。<br>第一，我们可能需要语法分析器处理同一门编程语言稍有差异的多个版本。语义判定允许我们通过命令行参数或者其他动态机制，在运行时选择所使用的方言。<br>第二，应用场景包含处理语法的歧义性。在某些编程语言中，相同的语法结构具有不同的含义，此时判定机制提供了一种方法，让我们能够在对相同输入文本的不同解释中做出选择。</p>
<ul>
<li><p>在语法规则中加入判定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">grammar Enum;</span><br><span class="line">@parser::members &#123;public static boolean java5;&#125;</span><br><span class="line"></span><br><span class="line">prog: (stat</span><br><span class="line">        | enumDecl</span><br><span class="line">        )+</span><br><span class="line">        ;</span><br><span class="line">stat: id &#39;&#x3D;&#39; expr &#39;;&#39; &#123;System.out.println($id.text+&quot;&#x3D;&quot;+$expr.text);&#125;;</span><br><span class="line">expr: id | INT;</span><br><span class="line">enumDecl: &#123;java5&#125;? &#39;enum&#39; name&#x3D;id &#39;&#123;&#39; id (&#39;,&#39; id)* &#39;&#125;&#39;</span><br><span class="line">        &#123;System.out.println(&quot;enum &quot;+$name.text);&#125;</span><br><span class="line">        ;</span><br><span class="line">ENUM: &#39;enum&#39;;</span><br><span class="line">ID: [a-zA-Z]+;</span><br></pre></td></tr></table></figure>

<p>判定可以开启和关闭任何在通过判定后能被匹配的规则。<br>下面这样写，一样是正确的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog : (&#123;java5&#125;? enumDecl| stat)+;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在词法规则中加入判定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enumDecl: &#39;enum&#39; name&#x3D;id &#39;&#123;&#39; id (&#39;,&#39; id)* &#39;&#125;&#39;</span><br><span class="line">          &#123;System.out.println(&quot;enum &quot;+$name.text);&#125;</span><br><span class="line">          ;</span><br><span class="line">ENUM: &#39;enum&#39; &#123;java5&#125;? ;&#x2F;&#x2F;必须放置在ID规则之前</span><br><span class="line">ID: [a-zA-Z]+;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，判定出现在词法规则的右侧，而非像文法规则一样的左侧。这是由于在语法分析中，语法分析器会对之后的内容进行预测，因此需要在匹配备选分支之前进行判定。而词法分析器不进行备选分支的预测。它们仅仅寻找最长的匹配文本，然后在发现整个词法符号后做出决策。当 java5 为假时，该判定关闭了 ENUM 规则。当它为真时，ENUM 和 ID 同时匹配了字符序列 e-n-u-m，此时该输入存在歧义。ANTLR 总是通过选择位置靠前的规则来解决词法歧义问题，也就是这里的 ENUM。</p>
</li>
<li><p>识别歧义文本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 前两个备选分支中使用了理想化的判定作为区分这两种情况的Demo **&#x2F;</span><br><span class="line">expr: &#123;&lt;&lt;isfunc(ID)&gt;&gt;&#125;? ID &#39;(&#39; expr &#39;)&#39; &#x2F;&#x2F;一个参数的函数调用</span><br><span class="line">    | &#123;&lt;&lt;istype(ID)&gt;&gt;&#125;? ID &#39;(&#39; expr &#39;)&#39; &#x2F;&#x2F;构造器风格的对expr的转换</span><br><span class="line">    | INT           &#x2F;&#x2F;整数常量</span><br><span class="line">    | ID            &#x2F;&#x2F;标识符</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>当我们使用这份带判定的语法再次进行测试时，输入”f(i);”被正确地解释成了函数调用表达式，而非声明。输入”T(i);”也被正确解释成了声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">decl: ID ID</span><br><span class="line">    | &#123;istype()&#125;? ID &#39;(&#39; ID &#39;)&#39;</span><br><span class="line">    ;</span><br><span class="line">expr: INT</span><br><span class="line">    | ID</span><br><span class="line">    | &#123;!istype()&#125;? ID &#39;(&#39; expr &#39;)&#39;</span><br><span class="line">    ;</span><br><span class="line">@parser::members &#123;</span><br><span class="line">    Set&lt;String&gt; types &#x3D; new HashSet&lt;String&gt;() &#123;&#123;add(&quot;T&quot;);&#125;&#125;;</span><br><span class="line">    boolean istype() &#123;return types.contains(getCurrentToken().getText());&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="掌握词法分析的“黑魔法”"><a href="#掌握词法分析的“黑魔法”" class="headerlink" title="掌握词法分析的“黑魔法”"></a>掌握词法分析的“黑魔法”</h2><h3 id="将词法符号送入不同通道"><a href="#将词法符号送入不同通道" class="headerlink" title="将词法符号送入不同通道"></a>将词法符号送入不同通道</h3><ul>
<li><p>将空格和回车送入不同通道，而正常的词法符号仍然位于默认的 0 通道。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WS ： [\t\n\r]+ -&gt; channel(1);</span><br><span class="line">SL_COMMENT : &#39;&#x2F;&#x2F;&#39; .*? &#39;\n&#39; -&gt; channel(2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问隐藏通道<br>通过继承监听器，在方法中可以调用 BufferedTokenStream.getHiddenTokensToRight()得到隐藏 channel，进而可以访问 channel 中的 Token 的 text 进行改造。</p>
</li>
</ul>
<h3 id="上下文相关的词法问题"><a href="#上下文相关的词法问题" class="headerlink" title="上下文相关的词法问题"></a>上下文相关的词法问题</h3><h3 id="字符流中的孤岛"><a href="#字符流中的孤岛" class="headerlink" title="字符流中的孤岛"></a>字符流中的孤岛</h3><h3 id="对-XML-进行语法分析和词法分析"><a href="#对-XML-进行语法分析和词法分析" class="headerlink" title="对 XML 进行语法分析和词法分析"></a>对 XML 进行语法分析和词法分析</h3><h2 id="语法参考"><a href="#语法参考" class="headerlink" title="语法参考"></a>语法参考</h2><h3 id="语法词汇表"><a href="#语法词汇表" class="headerlink" title="语法词汇表"></a>语法词汇表</h3><ol>
<li>注释<br>ANTLR 支持单行、多行注释。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grammar T;</span><br><span class="line">&#x2F;*多行</span><br><span class="line">  注释</span><br><span class="line"> *&#x2F;</span><br><span class="line">decl: ID; &#x2F;&#x2F;单行注释</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>标识符<br>词法符号名和词法规则名总是以大写字母开头。文法规则总是以小写字母开头。首字母之后的字符可以是大小写字符、数字和下划线。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ID,LPAREN,RIGHT_CURLY &#x2F;&#x2F;词法符号和词法规则名</span><br><span class="line">expr,d2,header_file &#x2F;&#x2F;文法规则名</span><br></pre></td></tr></table></figure>

<pre><code>ANTLR是支持中文等unicode的。同时也支持非unicode，需要在使用ANTLR工具中使用-encoding选项，以便正确读字符。</code></pre>
<ol start="3">
<li><p>文本常量</p>
</li>
<li><p>动作</p>
</li>
<li><p>关键字</p>
</li>
</ol>
<h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><h3 id="文法规则"><a href="#文法规则" class="headerlink" title="文法规则"></a>文法规则</h3><h3 id="动作和属性"><a href="#动作和属性" class="headerlink" title="动作和属性"></a>动作和属性</h3><h3 id="词法规则-1"><a href="#词法规则-1" class="headerlink" title="词法规则"></a>词法规则</h3><h3 id="通配符和非贪婪子规则"><a href="#通配符和非贪婪子规则" class="headerlink" title="通配符和非贪婪子规则"></a>通配符和非贪婪子规则</h3><h3 id="语义判定"><a href="#语义判定" class="headerlink" title="语义判定"></a>语义判定</h3>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ss/" rel="tag"># ss</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/01/29/JMX/" rel="prev" title="JMX">
                  <i class="fa fa-chevron-left"></i> JMX
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
