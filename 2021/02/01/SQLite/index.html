<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta name="description" content="后端OS 层sqlite3.h定义了主要的数据结构sqlite3_vfs: 定义了 vps 的名字，核心方法：比如创建文件，删除文件等。sqlite3_io_methods: 定义了操作文件的方法，比如读文件，写文件等。sqlite3_file：代表一个打开了的文件，由 sqlite3_vfs 中的 XOpen 方法返回。sqlite3_file 内部存储一个指向 sqlite3_io_metho">
<meta property="og:type" content="article">
<meta property="og:title" content="SQLite相关">
<meta property="og:url" content="http://yoursite.com/2021/02/01/SQLite/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="后端OS 层sqlite3.h定义了主要的数据结构sqlite3_vfs: 定义了 vps 的名字，核心方法：比如创建文件，删除文件等。sqlite3_io_methods: 定义了操作文件的方法，比如读文件，写文件等。sqlite3_file：代表一个打开了的文件，由 sqlite3_vfs 中的 XOpen 方法返回。sqlite3_file 内部存储一个指向 sqlite3_io_metho">
<meta property="og:locale">
<meta property="og:image" content="http://yoursite.com/images/sqlite/sqlite-3.2.png">
<meta property="og:image" content="http://yoursite.com/images/sqlite/sqlite-3.3.png">
<meta property="og:image" content="http://yoursite.com/images/sqlite/sqlite-3.4.png">
<meta property="og:image" content="http://yoursite.com/images/sqlite/sqlite-3.5.png">
<meta property="og:image" content="http://yoursite.com/images/sqlite/sqlite-3.6.png">
<meta property="og:image" content="http://yoursite.com/images/sqlite/sqlite-3.7.png">
<meta property="og:image" content="http://yoursite.com/images/sqlite/sqlite-3.8.png">
<meta property="og:image" content="http://yoursite.com/images/sqlite/sqlite-3.9.png">
<meta property="og:image" content="http://yoursite.com/images/sqlite/sqlite-4.1.png">
<meta property="og:image" content="http://yoursite.com/images/sqlite/sqlite-4.2.png">
<meta property="og:image" content="http://yoursite.com/images/sqlite/sqlite-4.3.png">
<meta property="og:image" content="http://yoursite.com/images/sqlite/sqlite-4.4.png">
<meta property="og:image" content="http://yoursite.com/images/sqlite/sqlite-4.5.png">
<meta property="og:image" content="http://yoursite.com/images/sqlite/sqlite-4.6.png">
<meta property="article:published_time" content="2021-02-01T13:00:00.000Z">
<meta property="article:modified_time" content="2021-05-04T02:34:17.247Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/sqlite/sqlite-3.2.png">


<link rel="canonical" href="http://yoursite.com/2021/02/01/SQLite/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>
<title>SQLite相关 | Hexo</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8E%E7%AB%AF"><span class="nav-number">1.</span> <span class="nav-text">后端</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#OS-%E5%B1%82"><span class="nav-number">1.1.</span> <span class="nav-text">OS 层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pager-%E5%B1%82"><span class="nav-number">1.2.</span> <span class="nav-text">Pager 层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Storage"><span class="nav-number">1.2.1.</span> <span class="nav-text">Storage</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Database-File-Structure"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">Database File Structure</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Journal-File-Structure"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">Journal File Structure</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.2.</span> <span class="nav-text">日志管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.3.</span> <span class="nav-text">事务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">事务类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lock"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">Lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E5%92%8C%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">锁的兼容性和转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">锁的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unixLock-%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.3.5.</span> <span class="nav-text">unixLock 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E5%AF%B9%E9%94%81%E6%97%B6%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%BA%8B%E5%8A%A1%EF%BC%8CunixFile%EF%BC%8CunixInodInfo-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.2.3.6.</span> <span class="nav-text">面对锁时进程，线程，事务，unixFile，unixInodInfo 之间的关系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tree-%E5%B1%82"><span class="nav-number">1.3.</span> <span class="nav-text">Tree 层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Virtual-Machine-%E5%B1%82"><span class="nav-number">1.4.</span> <span class="nav-text">Virtual-Machine 层</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF"><span class="nav-number">2.</span> <span class="nav-text">前端</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Virtual-Machine-%E5%B1%82-1"><span class="nav-number">2.1.</span> <span class="nav-text">Virtual-Machine 层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Parser-%E5%B1%82"><span class="nav-number">2.2.</span> <span class="nav-text">Parser 层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tokenizer-%E5%B1%82"><span class="nav-number">2.3.</span> <span class="nav-text">Tokenizer 层</span></a></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/01/SQLite/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SQLite相关
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-01 21:00:00" itemprop="dateCreated datePublished" datetime="2021-02-01T21:00:00+08:00">2021-02-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-04 10:34:17" itemprop="dateModified" datetime="2021-05-04T10:34:17+08:00">2021-05-04</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><h2 id="OS-层"><a href="#OS-层" class="headerlink" title="OS 层"></a>OS 层</h2><p><code>sqlite3.h</code>定义了主要的数据结构<br>sqlite3_vfs: 定义了 vps 的名字，核心方法：比如创建文件，删除文件等。<br>sqlite3_io_methods: 定义了操作文件的方法，比如读文件，写文件等。<br>sqlite3_file：代表一个打开了的文件，由 sqlite3_vfs 中的 XOpen 方法返回。sqlite3_file 内部存储一个指向 sqlite3_io_methods 的指针。<br><code>test_demovfs.c</code>是一个 sqlite3_vfs 实现类的样例。C 语言中通过给结构体的函数指针赋值，来完成接口和实现类的连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static int demoDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync)&#123;</span><br><span class="line">    &#x2F;&#x2F;这方法在删除的时候，使用unlink删除文件后。还从zPath中提取目录，然后将删除的工作同步更改到目录中。也就是需要在文件系统中删除对应文件的元数据。这里值得研究！！！linux如何彻底删除一个文件。参考unix高级环境编程。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Pager-层"><a href="#Pager-层" class="headerlink" title="Pager 层"></a>Pager 层</h2><h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><h4 id="Database-File-Structure"><a href="#Database-File-Structure" class="headerlink" title="Database File Structure"></a>Database File Structure</h4><ol>
<li>SQLite 将每个 database file 分成了若干个固定大小的区域叫 page。这样 database file 就变成了数组，如下：<br><img src="/images/sqlite/sqlite-3.2.png"></li>
<li>page size 默认为 1024 bytes。这个值可以在编译时指定或者在创建第一个 table 之前使用命令<code>page_size pragma</code></li>
<li>page type.包含四中类型：free,tree,pointer-map,lock-byte.</li>
<li>数据库的元数据存储在第一个 page，其他 page 可以存储任意 page type 的数据。第一个 page 的结构如下<br><img src="/images/sqlite/sqlite-3.3.png"><br>file header 中 1 前 100 字节存储 database file 结构信息，中间部分存储(master catalog table) B+树用于跟踪文件中的其他 page。header 部分的内容如下：<br><img src="/images/sqlite/sqlite-3.4.png"></li>
<li>freelist 数据结构。它按照如下结构组织数据。trunk pointer 用于指向下一个节点，number of leaves 用于存储叶子指针的数量，leaf page numbers 用于存储 leaf pages 的数量。当 page 不被使用时，SQLite 将它存储进 Freelist 并不换给文件系统。后面有信息 page 需求时，先从 freelist 中找到可用 page。如果想把 page 归还，可以使用 vacuum 命令(手动或自动)清空 page。<br><img src="/images/sqlite/sqlite-3.5.png"></li>
</ol>
<h4 id="Journal-File-Structure"><a href="#Journal-File-Structure" class="headerlink" title="Journal File Structure"></a>Journal File Structure</h4><p>SQLite 使用三种日志文件：rollback journal, statement journal, master journal.</p>
<ul>
<li>Rollback journal.这个文件是临时文件，与 database file 位于同目录下。每次写事务时创建日志，每次结束时删除日志。<br><img src="/images/sqlite/sqlite-3.6.png"><ul>
<li>segment header structure.<ul>
<li>存储记录数，数据库初始 page 数量，sector size， page size，魔数(确认文件类型)等<br><img src="/images/sqlite/sqlite-3.7.png"></li>
<li>日志文件可以被保留，日志文件需要包含有效的 segment header。</li>
<li>SQLite 支持异步事务，也就是不强制刷新日志和 database file。这样性能好，但是不具备失败恢复性。</li>
</ul>
</li>
<li>log record structure<ul>
<li>数据结构如下：checksum 十分重要，因为在新建的文件中，log record 中的数据有可能是早先被删除的文件的内容，如果没有 checksum 做检查，那么脏数据就会被读取。这种将 page number 放在头部，checksum 放在尾部的方式，可以很好地在宕机后发现有问题的数据区域。因为一个区域的写往往是顺序的，如果头部和尾部是正确的，那么中间应该也是正确的。<br><img src="/images/sqlite/sqlite-3.8.png"></li>
</ul>
</li>
</ul>
</li>
<li>Statement journal<br>这个 Statement journal 被用来从 statement 失败中恢复数据库。当 Statement 执行成功后，这个文件被删除。<br>通过设置项，可以保留 Statement Journal。</li>
<li>多数据库事务日志和主日志<br>通常一个数据库只有一个 database file，一个 database file 对应一个事务。但是通过 attach 命令，可以将多个 database file 绑定在一个 sqlite 中。这样在一次事务执行过程中，可以操作多个 database file，每个 database file 都有自己单独的 rollback journal file。如果让多个子 journal file 保持全局原子性，需要使用 master journal。它位于 database file 同级目录，以-mj 结尾。<br>每个子 journal file，拥有 master journal 的名字。如下是子 journal file 的结构<br><img src="/images/sqlite/sqlite-3.9.png"></li>
</ul>
<h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><p>Journal 用于恢复，当事务失败或系统宕机时。每个数据库一个 Journal 文件，与数据库文件位于同目录，‘-journal’结尾命名。每当写事务开启时创建 journal，完成后关闭 journal。<br>SQLite 的使用的日志方式是最简单的且不是很高效。它在 page 级别粒度上记录旧值，使用 undo 方式恢复。SQLite 把将要被改变的数据所在的页的完整内容 copy 进 journal 中。journal 记录 database file 的尺寸在 journal segment header 中，当 journal 文件被创建是。如果 database file 被事务扩大了，那么 journal file 可以让 database file 回滚到原来大小。</p>
<ul>
<li>Journaled Page 跟踪：SQLite 使用内存 bit map 数据结构来跟踪哪个 page 被当前事务记录了日志。</li>
<li>不要给 database file 和 journal file 命名别名。</li>
<li>WAL。在修改 database file 在 disk 生效之前，一定保证先把日志刷盘，以保证可以在宕机后修复。</li>
<li>异步事务模式。也就是在提交时不将 journal 文件刷盘，这样速度很快，但是没有恢复能力。临时数据库默认是异步事务，因为宕机时我们不需要恢复临时数据库。</li>
<li>子事务管理。每个 Statement 子事务通过用户事务获取锁，它并不 刷盘，因为它不承担恢复的责任。一个 log record 写入 Statement journal 仅当在 Statement 执行前相应 page 已经写在了用户事务中。</li>
</ul>
<h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><h4 id="事务类型"><a href="#事务类型" class="headerlink" title="事务类型"></a>事务类型</h4><p>几乎所有数据库系统都是用锁来控制并发，使用日志来恢复。一开始 DBMS 首先将修改写入日志的磁盘中，然后再修改数据。当宕机发生时，撤销未完成的事务，重做已完成的事务。</p>
<ul>
<li>系统事务<br>SQLite 中读写数据都必须在事务中进行，但是不需要显示指明事务类型，SQLite 根据操作自行分辨。对于 SELECT 语句 SQLite 开始读事务，对于非 SELECT 语句 SQLite 开始读事务，再将读事务升级为写事务。一个 connection 可以同时执行多个 SELECT 语句，但是非 SELECT 在 connection 只能单个执行。也就是多个读事务+单个写事务可以并发执行在一个 connection 上，但多个写事务不行。<br>非 SELECT 语句被原子地执行，执行前 SQLite 获取锁，执行完成释放锁。</li>
<li>用户事务<br>默认的系统事务，在执行多个写操作时效率很低，因为每执行一个写操作都要操作日志和锁。这时可以使用用户事务<code>BEGIN TRANSACTION</code>和<code>COMMIT</code>来包含多个写操作，减少日志和锁操作。用户定义的事务只包含写操作，读操作仍然是独立的原来的自动提交。如果事务 abort，那么读到那些被事务更改的数据的读操作也将 abort。<br>SQLite 不支持嵌套事务。</li>
<li>Savepoint<br>在用户事务中可以设置 savepoint，savepoint 是数据库那个时刻的所有数据，可用于回滚当事务失败时。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t1(a PRIMARY KEY, b);</span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO t1 VALUES(1, &#39;one&#39;);</span><br><span class="line">INSERT INTO t1 VALUES(2, &#39;two&#39;);</span><br><span class="line">UPDATE t1 SET a &#x3D; a + 10 &#x2F;&#x2F;UPDATE操作违反了主键唯一性的约束，那么将产生一个冲突，UPDATE前默认创建了一个savepoint，可以用于回滚。当然也可以显示指定。使用&#96;SAVEPOINT&#96;</span><br><span class="line">INSERT INTO t1 VALUES(3,null);</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>数据库的锁是为了保证事务执行的隔离性，通过锁来实现事务访问的顺序性，进而实现了事务的隔离性。<br>SQLite 的锁是数据库级别的锁，将整个数据库锁住(也就是锁住那个数据库文件，SQLite 将一个库的所有内容存储在一个文件中)。SQLite 为了简化锁的复杂度，采取了严格要求并发程度的方式。它允许同一时间任意数量的读事务。但是同一时间只有一个写事务，没有其他读写事务。<br>为了实现事务访问的顺序性，需要使用两阶段锁。<br>Statement 子事务通过所在的父事务获取锁，所有锁持续被事务持有直到事务执行成功或者失败。<br>SQLite 在 unix 平台上的使用来自于 <code>os_unix.c</code> 文件的实现，但要实现对数据库的操作，其核心在于 SQLite 的锁机制。SQLite 采用粗放型的锁。当一个连接要写数据库时，所有其他的连接被锁住，直到写连接结束了它的事务。SQLite 有一个加锁表，来帮助不同的写数据库者能够在最后一刻再加锁，以保证最大的并发性。SQLite 使用锁逐步上升机制，为了写数据库，连接需要逐步地获得排它锁。对于 5 个不同的锁状态：未加锁(UNLOCKED)、共享(SHARED)、保留(RESERVED)、未决(PENDING)和排它(EXCLUSIVE)。每个数据库连接在同一时刻只能处于其中一个状态。每种状态(未加锁状态除外)都有一种锁与之对应。</p>
<ul>
<li><p>锁类型：在 SQLite 中为了写数据库，连接需要逐步地获得排它锁。SQLite 有 5 个不同的锁：未加锁(NO_LOCK)、共享锁(SHARED_LOCK)、保留锁(RESERVED_LOCK)、未决锁(PENDING_LOCK)和排它锁(EXCLUSIVE_LOCK)。</p>
</li>
<li><p>NO_LOCK：最初的状态是未加锁状态，在此状态下，连接还没有存取数据库。当连接到了一个数据库，甚至已经用 BEGIN 开始了一个事务时，连接都还处于未加锁状态。</p>
</li>
<li><p>SHARED 锁：SHARED 锁意味着进程要读（不写）数据库。一个数据库上可以同时有多个进程获得 SHARED 锁，哪个进程能够在 SHARED_FIRST 区域加共享锁(使用 LockFileEx()LockFileEx()函数)，即获得了 SHARED 锁。</p>
</li>
<li><p>RESERVED 锁： RESERVED 锁意味着进程将要对数据库进行写操作。一个数据库上同时只能有一个进程拥有 RESERVED 锁。RESERVED 锁可以与 SHARED 锁共存，并可以继续对数据库加新的 SHARED 锁。</p>
</li>
<li><p>PENDING 锁：PENDING LOCK 意味着进程已经完成缓存中的数据修改，并想立即将更新写入磁盘。它将等待此时已经存在的读锁事务完成，但是不允许对数据库加新的 SHARED LOCK(这与 RESERVED LOCK 相区别)。</p>
</li>
<li><p>EXCLUSIVE 锁：在此锁状态下，进程此时就可以自由地对数据库进行修改了，所有以前对缓冲区所做的修改都会被写到数据库文件。</p>
</li>
</ul>
<h4 id="锁的兼容性和转换"><a href="#锁的兼容性和转换" class="headerlink" title="锁的兼容性和转换"></a>锁的兼容性和转换</h4><p>下表中，每一行行首是指当前锁的类型，每一个列首是指申请的锁类型。Y 代表可以，N 代表不行。</p>
<p><img src="/images/sqlite/sqlite-4.1.png"></p>
<p>每一个事务都需要在执行读写操作前获取合适的锁。这是 Pager 的责任从文件上获取锁。<br>5 种锁中，pending 是一种内部类型锁。pager 不能直接跟 lock management 申请 pending。pager 只能申请 exclusive，然后 lock management 根据情况，可能返回拒绝或 pending lock 或 exclusive lock。<br><img src="/images/sqlite/sqlite-4.2.png"><br>一次读事务，nolock-shared lock-no lock.<br>一次写事务，nolock-shared lock-reserved lock- pending lock - Exclusive lock<br>一次事务回滚，nolock-shared lock-pending lock-exclusive lock</p>
<h4 id="锁的实现"><a href="#锁的实现" class="headerlink" title="锁的实现"></a>锁的实现</h4><p>SQLite 依赖 Linux 的的锁原语，fcnt()它可以提供读锁和写锁，并且指定锁定的文件中范围。<br>文件中的 512 字节用于锁。其中 510 字节用于 shared 锁和 exclusive 锁。fcntl 的读锁这 510 字节，则获取 shared 锁。写锁锁住 510，则获取 exclusive 锁。<br>reserved 锁，是第 511 字节。使用 fcntl()添加写锁。peding 锁在 512 字节，使用 fcntl()添加写锁。<br>这里的读锁为什么范围是 510 的原因是，windows 不支持读锁。那么使用一个大的范围，每个 bytes 单独设置一个写锁，可以支持 510 的写锁。那么这些写锁可以作为 sqlite 并发的读锁。<br><img src="/images/sqlite/sqlite-4.3.png"><br><img src="/images/sqlite/sqlite-4.4.png"></p>
<h4 id="unixLock-方法"><a href="#unixLock-方法" class="headerlink" title="unixLock 方法"></a>unixLock 方法</h4><p><code>os_unix.c</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static int unixLock(sqlite3_file *id, int eFileLock) &#x2F;&#x2F;加锁逻辑</span><br></pre></td></tr></table></figure>

<h4 id="面对锁时进程，线程，事务，unixFile，unixInodInfo-之间的关系"><a href="#面对锁时进程，线程，事务，unixFile，unixInodInfo-之间的关系" class="headerlink" title="面对锁时进程，线程，事务，unixFile，unixInodInfo 之间的关系"></a>面对锁时进程，线程，事务，unixFile，unixInodInfo 之间的关系</h4><p>Linux 操作系统中。 1.将锁与文件的 inode 联系在一起，而不是使用文件名，因为通过文件可以指向同一个 inode(因为符号链接，硬链接)。 2.锁的获取是通过文件描述符得到的，但是如果文件描述符指向相同的 inode，那么实际的效果还是在操作同一个锁。<br>因此，Linux 的这种机制，使得在同一个 process 下多个线程或 connection(transction)打开相同的文件时会出现问题，比因为对于系统来说它只按照 process+文件来区分锁的粒度。此时多个线程或 transaction 都在操作同一个锁.<br>所以，我们需要 unixInodeInfo 结构体在 process 存储文件锁的整体情况。一个 unixInodeInfo 对象代表一个位于 database file 的 SQLite 锁。一个 process 不能拥有多个指向相同文件的 unixInodeInfo 对象。因为一个 process 可以打开多个文件，所以使用 inodeList 来存储所有 unixInodeInfo 对象。<br><img src="/images/sqlite/sqlite-4.5.png"><br><img src="/images/sqlite/sqlite-4.6.png"></p>
<ul>
<li>unixInodeInfo</li>
</ul>
<p><code>os_unix.c</code> 文件<br><code>unixInodeInfo</code>结构体，存储了一个进程打开某个文件 iNode 的对应的锁的信息。当进程持有一个文件的 RESERVED 锁，线程如果申请 SHARED 锁，则该进程在 unixInodeInfo 中的 nShared 加 1。如果一个线程申请排它锁，进程则调用 fcntl 获取文件中的排它锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct unixInodeInfo &#123;</span><br><span class="line">  struct unixFileId fileId;       &#x2F;* unixInodeInfo 存储在list中，fileId作为key *&#x2F;</span><br><span class="line">  int nShared;                    &#x2F;* 持有SHARED锁的数量 *&#x2F;</span><br><span class="line">  unsigned char eFileLock;        &#x2F;* 进程持有的最高级的锁：SHARED_LOCK, RESERVED_LOCK, NOLOCK, PEDING, EXCLUSIVE. *&#x2F;</span><br><span class="line">  unsigned char bProcessLock;     &#x2F;* An exclusive process lock is held *&#x2F;</span><br><span class="line">  int nRef;                       &#x2F;* 打开的文件数量，因为多个文件可以指向同一个iNode *&#x2F;</span><br><span class="line">  unixShmNode *pShmNode;          &#x2F;* Shared memory associated with this inode *&#x2F;</span><br><span class="line">  int nLock;                      &#x2F;* Number of outstanding file locks *&#x2F;</span><br><span class="line">  UnixUnusedFd *pUnused;          &#x2F;* Unused file descriptors to close *&#x2F;</span><br><span class="line">  unixInodeInfo *pNext;           &#x2F;* List of all unixInodeInfo objects *&#x2F;</span><br><span class="line">  unixInodeInfo *pPrev;           &#x2F;*    .... doubly linked *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>unixFile</li>
</ul>
<p>位于<code>os_unix.c</code> 文件，SQLite 使用 unixFile 来跟踪一个文件的打开实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct unixFile &#123;</span><br><span class="line">  sqlite3_io_methods const *pMethod;  &#x2F;* Always the first entry *&#x2F;</span><br><span class="line">  sqlite3_vfs *pVfs;                  &#x2F;* The VFS that created this unixFile *&#x2F;</span><br><span class="line">  unixInodeInfo *pInode;              &#x2F;* Info about locks on this inode *&#x2F;</span><br><span class="line">  int h;                              &#x2F;* The file descriptor *&#x2F;</span><br><span class="line">  unsigned char eFileLock;            &#x2F;* The type of lock held on this fd *&#x2F;</span><br><span class="line">  unsigned short int ctrlFlags;       &#x2F;* Behavioral bits.  UNIXFILE_* flags *&#x2F;</span><br><span class="line">  int lastErrno;                      &#x2F;* The unix errno from last I&#x2F;O error *&#x2F;</span><br><span class="line">  void *lockingContext;               &#x2F;* Locking style specific state *&#x2F;</span><br><span class="line">  UnixUnusedFd *pUnused;              &#x2F;* Pre-allocated UnixUnusedFd *&#x2F;</span><br><span class="line">  const char *zPath;                  &#x2F;* Name of the file *&#x2F;</span><br><span class="line">  unixShm *pShm;                      &#x2F;* Shared memory segment information *&#x2F;</span><br><span class="line">  int szChunk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>多线程问题</p>
<ol>
<li>LinuxThreads 是按照线程区分 lock，不同线程之间不能覆盖 lock。NPTL(Native Posix Thread Library)从 3.7.0 开始支持的，同 Process 的线程之间可以相互覆盖 lock。</li>
<li>当一个线程关闭文件时，Linux 将删除 inode 上所有的锁，而不管具体是哪个线程的锁。SQLite 对此进行了优化，单个线程关闭文件时不会立刻删除所有的 lock，而是跟踪，等到 inode 上最后一个文件描述符被关闭时，才将所有文件描述符关闭并将 lock 释放掉。</li>
</ol>
</li>
<li><p>API</p>
</li>
</ul>
<p><code>unixLock</code>包含了完整的锁状态转换和加锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static int unixLock(sqlite3_file *id, int eFileLock) &#x2F;&#x2F;加锁逻辑</span><br></pre></td></tr></table></figure>

<p><code>unixFileLock</code>是对 fcntl 和 sqlilte 区域锁实现的封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static int unixFileLock(unixFile *pFile, struct flock *pLock)</span><br></pre></td></tr></table></figure>

<p><code>unixUnlock</code>是解锁</p>
<p>解开低等级锁，eFileLock 只能是 SHARED_LOCK 或 NO_LOCK。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static int unixUnlock(sqlite3_file *id, int eFileLock)&#123;</span><br><span class="line">  return posixUnlock(id, eFileLock, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Tree-层"><a href="#Tree-层" class="headerlink" title="Tree 层"></a>Tree 层</h2><h2 id="Virtual-Machine-层"><a href="#Virtual-Machine-层" class="headerlink" title="Virtual-Machine 层"></a>Virtual-Machine 层</h2><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="Virtual-Machine-层-1"><a href="#Virtual-Machine-层-1" class="headerlink" title="Virtual-Machine 层"></a>Virtual-Machine 层</h2><h2 id="Parser-层"><a href="#Parser-层" class="headerlink" title="Parser 层"></a>Parser 层</h2><h2 id="Tokenizer-层"><a href="#Tokenizer-层" class="headerlink" title="Tokenizer 层"></a>Tokenizer 层</h2>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/01/29/JMX/" rel="prev" title="JMX">
                  <i class="fa fa-chevron-left"></i> JMX
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/02/01/ANTLR/" rel="next" title="Antlr相关">
                  Antlr相关 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
