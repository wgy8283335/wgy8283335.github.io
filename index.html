<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'default'
  };
</script>
<title>Hexo</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/31/wrk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/31/wrk/" class="post-title-link" itemprop="url">wrk</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-31 21:00:00" itemprop="dateCreated datePublished" datetime="2021-03-31T21:00:00+08:00">2021-03-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-01 14:38:32" itemprop="dateModified" datetime="2021-04-01T14:38:32+08:00">2021-04-01</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>WRK 的结果怎么看？</p>
<p>Latency：表示的是响应时间（需要在命令中添加 –latency），顺序分别是： 平均值，标准偏差，最大值，正负标准差；<br>其中，平均值，最大值，有一定参考意义，如果标准偏差越小，一定层面能反应待测的接口是比较稳定的</p>
<p>Req/Sec：表示的是每个线程每秒的完成的请求数，顺序分别是： 平均值，标准差，最大值，正负标准差；<br>参考价值与响应时间类似</p>
<p>链接数和线程数应该设多少？<br>先上结论：<br>-t（线程数）：<br>一般是 CPU 核数，最大不要超过 CPUx2 核数，否则会带来额外的上下文切换，将线程数设置为 CPU 核数主要是为了 WRK 能最大化利用 CPU，使结果更准确<br>-c（连接数）：<br>连接数（connection）可以理解为并发数，一般在测试过程中，这个值需要使用者不断向上调试，直至 QPS 达到一个临界点，便可认为此时的并发数为系统所能承受的最大并发量。<br>实际上，wrk 会为每个线程分配（c/t）个 socket 连接，每个连接会先执行请求动作，然后等待直到收到响应后才会再发送请求，这个日后会有关于 wrk 的源码解析方便理解，所以每个时间点的并发数大致等于连接数（connection）</p>
<p>连接数（c）与 QPS（q），请求响应时间毫秒（t）的关系大概可理解为：q = 1000/t * c<br>RTT 为 1ms，如果 c（连接数）为 1，则理论上 QPS 接近 1000，如果 c（连接数）为 100，则 QPS 接近 10w<br>RTT 为 10ms，如果 c（连接数）为 1，则理论上 QPS 接近 100，如果 c（连接数）为 100，则 QPS 接近 1w</p>
<p>但是服务有自己的负载极限，并发数不能无限放大，这就能解释有的时候连接数越大，反而 QPS 越低，是因为并发数已经设的过高，导致待测系统已经超出自身能承受的负载<br><a target="_blank" rel="noopener" href="https://testerhome.com/topics/22610">https://testerhome.com/topics/22610</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/shardingsphere-sql-parser%E6%96%B0%E5%A2%9E%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/26/shardingsphere-sql-parser%E6%96%B0%E5%A2%9E%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">shardingsphere-sql-parser新增语法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-26 21:00:00" itemprop="dateCreated datePublished" datetime="2021-03-26T21:00:00+08:00">2021-03-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-14 09:18:00" itemprop="dateModified" datetime="2021-04-14T09:18:00+08:00">2021-04-14</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="shardingsphere-sql-parser-新增语法"><a href="#shardingsphere-sql-parser-新增语法" class="headerlink" title="shardingsphere-sql-parser 新增语法"></a>shardingsphere-sql-parser 新增语法</h1><p>给 Oracle 添加语法时，需要注意哪些文件的改动：<br><img src="/images/ss/oracle-parser.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/26/%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">事务并发管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-03-26 21:00:00 / Modified: 13:34:07" itemprop="dateCreated datePublished" datetime="2021-03-26T21:00:00+08:00">2021-03-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="事务并发管理"><a href="#事务并发管理" class="headerlink" title="事务并发管理"></a>事务并发管理</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/01/ANTLR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/01/ANTLR/" class="post-title-link" itemprop="url">Antlr相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-01 21:00:00" itemprop="dateCreated datePublished" datetime="2021-02-01T21:00:00+08:00">2021-02-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-20 12:07:05" itemprop="dateModified" datetime="2021-03-20T12:07:05+08:00">2021-03-20</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="实例入门"><a href="#实例入门" class="headerlink" title="实例入门"></a>实例入门</h1><p>在安装完 antlr 之后，可以编写简单的 g4 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grammar Hello;</span><br><span class="line">r:&#39;hello&#39; ID ;</span><br><span class="line">ID:[a-z]+ ;</span><br><span class="line">WS:[\t\r\n]+ -&gt; skip;</span><br></pre></td></tr></table></figure>

<p>运行如下命令</p>
<ul>
<li><code>antlr4 Hello.g4</code></li>
<li><code>javac *.java</code></li>
<li><code>alias grun=‘java org.antlr.v4.runtime.misc.TestRig’</code> TestRig 是一个调试工具，使用 alias 给它起了一个别名。直接执行<code>grun</code>可以得到帮助信息。</li>
<li><code>grun Hello r -tokens</code></li>
<li><code>hello parrt</code></li>
<li><code>EOF</code></li>
</ul>
<p>得到如下结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[@0,0:4&#x3D;&#39;hello&#39;,&lt;&#39;hello&#39;&gt;,1:0]</span><br><span class="line">[@1,6:10&#x3D;&#39;parrt&#39;,&lt;ID&gt;,1:6]</span><br><span class="line">[@2,12:11&#x3D;&#39;&lt;EOF&gt;&#39;,&lt;EOF&gt;,2:0]</span><br></pre></td></tr></table></figure>

<p>解析结果：比如 parrt。@1 表明该词法符号在第 2 个位置，parrt 位于第 6 个到第 10 个位置之间，词法符号类型是 ID，位于输入文本的第 1 行，第 6 个位置处。</p>
<h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><p>TestRig 是一个调试工具。<br><code>alias grun=‘java org.antlr.v4.runtime.misc.TestRig’</code> TestRig 是一个调试工具，使用 alias 给它起了一个别名。直接执行<code>grun</code>可以得到帮助信息。</p>
<ul>
<li>对于<code>Hello</code>语法，执行<code>grun Hello r -tokens</code>可以得到解析的各个 token 的信息。</li>
<li>对于<code>Hello</code>语法，执行<code>grun Hello r -tree</code>可以得到解析的树信息。</li>
<li>对于<code>Hello</code>语法，执行<code>grun Hello r -gui</code>可以得到解析的树的图形信息。<br>通过执行 grun，可以查看可以使用的选项。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ grun</span><br><span class="line">java org.antlr.v4.gui.TestRig GrammarName startRuleName</span><br><span class="line">  [-tokens] [-tree] [-gui] [-ps file.ps] [-encoding encodingname]</span><br><span class="line">  [-trace] [-diagnostics] [-SLL]</span><br><span class="line">  [input-filename(s)]</span><br><span class="line">Use startRuleName&#x3D;&#39;tokens&#39; if GrammarName is a lexer grammar.</span><br></pre></td></tr></table></figure>

<p>-ps files.ps 以 PostScript 格式生成可视化语法分析树，然后将其存储于 file.ps。本章中的语法分析树的图片就是使用-ps 选项生成的。<br>-encoding encodingname 若当前的区域设定无法正确读取输入，使用这个选项指定测试组件输入文件的编码。例如，在 12.4 节中我们需要通过这个选项来解析日语 XML 文件。<br>-trace 打印规则的名字以及进入和离开该规则时的词法符号。</p>
<ul>
<li>diagnostics 开启解析过程中的调试信息输出。通常仅在一些罕见情况下使用它产生信息，例如输入的文本有歧义。</li>
<li>SLL 使用另外一种更快但是功能稍弱的解析策略。</li>
</ul>
<h2 id="ANTLR4-的-IntelliJ-插件"><a href="#ANTLR4-的-IntelliJ-插件" class="headerlink" title="ANTLR4 的 IntelliJ 插件"></a>ANTLR4 的 IntelliJ 插件</h2><p>打开 g4 文件，选择特定的规则名字，然后右键选择 Test Rule ****。<br>会在底部弹出框，左侧显示输入的 sql 语句，右侧显示分析的后 tree 以及 Hierarchy，Profiler。</p>
<h1 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h1><p>Antlr 依据我们定义的语法规则，产生一个递归下降的语法分析器。下降过程就是从语法分析树的根节点开始，朝着叶节点进行解析的过程。递归下降的语法分析其实际是若干方法的结合，每个方法对应一条规则。递归下降属于自上而下的语法分析器的一种实现。<br>首先调用的规则，即语义符号的起始点，就会成为语法分析树的根节点。比如：调用上面的 r()方法，作为起始点。<br>语法分析数的构造过程：识别匹配的规则，将对应规则的方法映射到语法分析树中。<br>一般规则分为：单一分支，多分支。例如：多个规则 assign，ifstat<br>单一分支，如：<code>stat: assign;</code><br>多分支，如:<code>stat: assign|ifstat;</code></p>
<h2 id="顺序解析"><a href="#顺序解析" class="headerlink" title="顺序解析"></a>顺序解析</h2><p>单一分支，只需要顺序匹配词汇符号。</p>
<h2 id="多分支解析"><a href="#多分支解析" class="headerlink" title="多分支解析"></a>多分支解析</h2><p>多分支，需要检查下一个词法符号或者多个词法符号，来决定选择哪个备选分支。这个过程成为预测或语法分析决策。<br>如果在预测过程中，发现多个分支都匹配的话，则出现了规则的定义出现了歧义，需要解决。</p>
<h2 id="歧义"><a href="#歧义" class="headerlink" title="歧义"></a>歧义</h2><p>例如下面这个语法就存在歧义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stat: expr &#39;;&#39;</span><br><span class="line">    | ID &#39;(&#39; &#39;)&#39; &#39;;&#39;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expr: ID &#39;(&#39; &#39;)&#39;</span><br><span class="line">    | INT</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>一般情况下要确保语法分析器能够选择唯一匹配的备选分支。不过当存在多个备选分支时，ANTLR 会选取备选分支中的第一条。比如本例中就会选择<code>expr &#39;;&#39;</code><br>如下存在词法歧义,begin 是一个关键字，同时也是一个标识符。<br>词法分析器会匹配最长字符串，如果输入文本 beginner 只会匹配上例中的 ID 这条词法规则。ANTLR 词法分析器不会把它匹配为关键字 BEGIN 后跟着标识符 ner</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BEGIN : &#39;begin&#39; ;</span><br><span class="line">ID    : [a-z]+ ;</span><br></pre></td></tr></table></figure>

<h2 id="语法分析树"><a href="#语法分析树" class="headerlink" title="语法分析树"></a>语法分析树</h2><p>构建应用逻辑和语法松耦合的语言类应用程序的关键在于，令语法分析器建立一颗语法分析树，然后在遍历该树的过程中触发应用逻辑代码。<br>语法分析树的建造过程：词法分析器处理字符序列并将生成的词法符号提供给语法分析器，语法分析器随即根据这些细信息来检查语法的正确性并建造出一颗语法分析树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharStream-&gt;(Lexer)-&gt;TokenStream-&gt;(Parser)-&gt;ParseTree(RuleNode子类+TerminalNode)</span><br></pre></td></tr></table></figure>

<p><img src="/images/antlr/2-2.png"><br><img src="/images/antlr/2-3.png"></p>
<p>ANTLR 使用共享数据结构节约内存，具体办法是：语法分析树中的叶子节点仅仅是盛放词法符号流中的词法符号的容器。每个词法符号都记录了自己在字符序列中的开始位置和结束位置，而非保存子字符串的拷贝。<br>ParseTree 有两个子类：RuleNode 的子类（非叶子） 和 TerminalNode（叶子）。 RuleNode 的子类包括：StatContext 和 ExprContext.Context 对象知道自己识别的词组中，开始和结束位置处的词法符号，同时提供访问该词组全部元素的方法比如 statContext 类有 ID（）和 expr()方法。有了这些方法，我们就可以遍历并操作树中节点。实际上遍历树的机制都是由 ANTLR 生成的代码</p>
<h2 id="语法分析树的访问-监听器、访问器"><a href="#语法分析树的访问-监听器、访问器" class="headerlink" title="语法分析树的访问-监听器、访问器"></a>语法分析树的访问-监听器、访问器</h2><p>为了构建一个语言类应用程序，语法分析器需要在遇到特定的输入语句、词组或者词法符号时触发特定的行为。这样的词组-&gt;行为的集合构成了我们的语言类应用程序，或者，至少担任了语法和外围程序间接口的角色。<br>监听器和访问器的区别在于，监听器方法不负责显示调用子节点的访问方法(visit())。访问器必须显式触发对子节点的访问，树的遍历过程才能正常进行，所以访问器可以控制访问的顺序以及节点被访问的次数。</p>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>ANTLR 提供了 ParseTree-Walker 类，自动遍历树然后生成事件并调用监听器。<br>每个语法文件都会生成一个 ParseTreeLisener 的子类，里面每个规则都有对应的 enter 方法和 exit 方法()，这些方法也称为”事件方法”。这些方法的入参是 ×××Context，提供该方法所需要的所有信息。监听器的操作逻辑在这些 enter 和 exit 方法内添加。下图显示了 ParseTreeWalker 对监听器方法的完整的调用顺序。<br><img src="/images/antlr/2-5.png"></p>
<h3 id="访问器"><a href="#访问器" class="headerlink" title="访问器"></a>访问器</h3><p>有时候我们希望手动控制遍历数的过程，通过显示的方法调用来访问子节点。在命令行中加入-visitor 选项可以指示 ANTLR 为一个语法生成访问器接口，语法中的每条规则对应接口中的一个 visit 方法。ANTRL 提供了访问器接口和一个默认实现类，这样我们自己只需要覆盖接口中我们感兴趣的方法。<br><img src="/images/antlr/2-6.png"></p>
<p>调用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ParseTree tree &#x3D; ...;&#x2F;&#x2F;语法分析数</span><br><span class="line">MyVisitor v &#x3D; new MyVisitor();&#x2F;&#x2F;访问器接口的实现类</span><br><span class="line">v.visit(tree);&#x2F;&#x2F;visitor访问tree</span><br></pre></td></tr></table></figure>

<h3 id="在事件方法中共享信息"><a href="#在事件方法中共享信息" class="headerlink" title="在事件方法中共享信息"></a>在事件方法中共享信息</h3><ol>
<li><p>使用访问器遍历语法分析树,使用访问器方法来返回值。优缺点：无法传递参数，访问器方法只能返回值。</p>
</li>
<li><p>使用类成员在事件方法之间共享数据，使用栈来模拟返回值。在上下文类中维护一个栈字段，以与 java 调用栈相同的方式，模拟参数和返回值的入和出栈。优缺点：手工操作栈存在失误的可能性，不过栈比较节省空间，所有局部结果的存储在树遍历完成后都会被释放。</p>
</li>
<li><p>通过对语法分析树的节点进行标注来存储相关数据，通过规则参数和返回值为节点添加字段。在上下文中维护一个 Map 字段，用对应的值来标注节点。优缺点：树标注是我个人的首选解决方案，因为它允许我向事件方法提供任意信息来操纵语法分析树中的各个节点。通过该方案，我可以传递多个任意类型的参数值。在很多情况下，标注比存储转瞬即逝的值的栈更好。使用它，在众多方法中来回传递数据也更不容易事务。这种方案的唯一缺点是，在整个遍历过程中，局部结果都会被保留，因此具有更大的内存消耗。另一方面，某些程序恰好需要标注语法分析树的方案，例如 8.4 节。该程序需要对语法分析树进行多次遍历，将第一趟遍历得到的数据完整地存储在树中是合理的，这样，第二趟遍历就能非常容易地获取这些数据。总之，对数进行标注的方案异常灵活，同时内存占用也处于可接受的范围。</p>
<ul>
<li><strong>为规则添加返回值</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e returns [int value]</span><br><span class="line">    : e &#39;*&#39; e  # Mult</span><br><span class="line">    | e &#39;+&#39; e  # Add</span><br><span class="line">    | INT      # Int</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>ANTLR 会将所有的参数和返回值放入相关的上下文对象中，这样，value 就成为 EContext 的一个字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static class AddContext extends ParserRuleContext &#123;</span><br><span class="line">    public int value;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在对监听器方法进行实现的时候，就可以按照如下方式存储值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void exitAdd(LExprParser.AddContext ctx) &#123;</span><br><span class="line">    &#x2F;&#x2F; e(0).value 是备选分支中的第一个e子表达式的值</span><br><span class="line">    ctx.value &#x3D; ctx.e(0).value + ctx.e(1).value; &#x2F;&#x2F; e &#39;+&#39; e #Add</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 ParseTreeProperty 类来存储各个节点及对应的值</strong><br>定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static class EvaluatorWithProps extends LExprBaseListener &#123;</span><br><span class="line">    &#x2F;** 使用Map&lt;ParseTree,Inteer&gt;将节点映射到对应的整数值 **&#x2F;</span><br><span class="line">    ParseTreeProperty&lt;Integer&gt; values &#x3D; new ParseTreeProperty&lt;Integer&gt;();</span><br><span class="line">    public void setValue(ParseTree node, int value) &#123; values.put(node,value);&#125;</span><br><span class="line">    public int getValue(ParseTree node) &#123;return values.get(node);&#125;</span><br><span class="line">    public void exitAdd(LExprParser.AddContext ctx) &#123;</span><br><span class="line">        int left &#x3D; getValue(ctx.e(0));</span><br><span class="line">        int right &#x3D; getValue(ctx.e(1));</span><br><span class="line">        setValue(ctx, left+right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ParseTreeWalker walker &#x3D; new ParseTreeWalker();</span><br><span class="line">EvaluatorWithProps evalProp &#x3D; new EvaluatorWithProps();</span><br><span class="line">walker.walk(evalProp, tree);</span><br><span class="line">System.out.println(&quot;properties result &#x3D; &quot;+ evalProp.getValue(tree));</span><br></pre></td></tr></table></figure>
</li>
<li><p>总结。为获取可复用的语法，我们需要使其与用户自定义的动作分离。这意味着将所有程序自身的逻辑代码放到语法之外的某种监听器或者访问器中。监听器和访问器通过操纵语法分析树来完成工作，ANTLR 会自动生成合适的接口和默认实现类，以便对语法分析树进行遍历。但是，由于事件方法的签名是固定的，无法由程序自行决定，我们找到了三种在事件方法中共享数据的方案。</p>
</li>
</ol>
<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h3><p>文件 ArrayInit.g4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 语法文件通常以grammar关键字开头</span><br><span class="line"> *  这是一个名为ArrayInit的语法，它必须和文件名ArrayInit.g4相匹配</span><br><span class="line"> *&#x2F;</span><br><span class="line">grammar ArrayInit;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;一条名为init的规则，它匹配一对花括号中的、逗号分隔的value</span><br><span class="line">init: &#39;&#123;&#39; value (&#39;,&#39; value)* &#39;)&#39;; &#x2F;&#x2F;必须匹配至少一个value。其中*号用来修饰小括号里的内容，表示任意个。</span><br><span class="line">&#x2F;&#x2F; 一个value可以是嵌套的花括号结构，也可以是一个简单的整数，即INT词法符号</span><br><span class="line">value: init</span><br><span class="line">     | INIT</span><br><span class="line">     ;</span><br><span class="line">&#x2F;&#x2F;语法分析器的规则必须以小写字母开头，词法分析器的规则必须用大写字母开头</span><br><span class="line">INT： [0-9]+;  &#x2F;&#x2F;定义词法符号INT, 它由一个或多个数字组成</span><br><span class="line">WS: [\t\r\n]+ -&gt; skip;     &#x2F;&#x2F;定义词法规则“空白符号”，丢弃之。-&gt; skip表示跳过丢弃的意思。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ANTLR 对 g4 文件解析后，会生成如下文件:ArrayInitParser.java, ArrayInitLexer.java,ArrayInit.tokens,ArrayInitLexer.tokens,ArrayInitListener.java:ArrayBaseListener.java.<br>1 ArrayInitParser.java:对应语法 ArrayInit，每条规则对应里面一个方法。<br>2 ArrayInitLexer.java:用于识别词法规则和文法规则。它是通过 ANTLR 分析词法规则 INT 和 WS，以及语法中的字面值‘{’ ‘}‘ ‘,’生成的。<br>3 ArrrayInit.tokens: ANTLR 会给每个我们定义的词法符号指定一个数字形式的类型，然后将他们的对应关系存储于该文件中。<br>4 ArrayInitListener.java 和 ArrayBaseListener.java: 在遍历 AST 时,遍历器能够触发一系列事件，并通知我们提供的监听器对象。ArrayInitListener 接口给出了这些回调方法的定义，ArrayBaseListener 是该接口的默认实现类，为其中的每个方法提供了一个空实现。</p>
<h3 id="ANTLR-语法基本标记"><a href="#ANTLR-语法基本标记" class="headerlink" title="ANTLR 语法基本标记"></a>ANTLR 语法基本标记</h3><ul>
<li>语法包含一系列描述语言结构的规则。这些规则既包括类似 stat 和 expr 的描述语法结构的规则，也包括描述标识符和整数之类的词汇符号的规则</li>
<li>语法分析器的规则以小写字母开头</li>
<li>词法分析器的规则以大写字母开头</li>
</ul>
<h3 id="语法规则-1"><a href="#语法规则-1" class="headerlink" title="语法规则"></a>语法规则</h3><ul>
<li>我们使用|来分隔同一个语言规则的若干备选分支，使用圆括号把一些符号组合成自规则。例如，子规则(‘*‘|’/‘)匹配一个乘法符号或者触发符号。</li>
<li>使用?表达一个或 0 个，使用*表达多个或 0 个，使用+表达至少 1 个。</li>
<li>词法符号依赖，比如(),[],{}等。成对出现的符号。符号使用’’包裹起来。</li>
<li>处理嵌套模式可以使用递归规则处理，规则的定义中包含对自身的调用。有规则直接引用自身称为直接递归，规则间接引用自身称为间接递归。</li>
<li>处理优先级，左结合。ANTLR 在解析输入的语句的时候采用左结合的特性，当处理“1+2*3”的时候，就会先处理加法。这样是有问题的，解决这个问题的办法是在定义语法的时候，乘法的语法写在加法前面，这样，ANTLR 会优先匹配乘法，然后再匹配除法。</li>
<li>#标签可以标注备选分支，为每个备选分支单独生成一个监听器方法。如果没有#进行标注，则之后语法规则名对应的一个监听器方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expr: &lt;assign&#x3D;right&gt; expr &#39;^&#39; expr #Index</span><br><span class="line">      | expr &#39;*&#39; expr #Mult</span><br><span class="line">      | expr &#39;+&#39; expr #Add</span><br><span class="line">      | INT</span><br><span class="line">      ;</span><br></pre></td></tr></table></figure>

<p>但是，向指数运算这种右结合的情况，就需要使用<code>&lt;assign=right&gt;</code>单独指定。</p>
<h4 id="左递归"><a href="#左递归" class="headerlink" title="左递归"></a>左递归</h4><ul>
<li>左递归规则含义：在某个备选分支的最左侧位置，直接或间接调用了自身。例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr: INT|ID|&#39;(&#39;expr&#39;)&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>带有优先级的左递归。在面对 1+2<em>3 这样的输入是，根据优先级原则，会按照 1+(2</em>3)来处理。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expr: expr &#39;*&#39; expr</span><br><span class="line">    | expr &#39;+&#39; expr</span><br><span class="line">    | INT</span><br><span class="line">    | ID</span><br><span class="line">    ；</span><br></pre></td></tr></table></figure>

<ul>
<li>ANTLR 通过下列四种子表达式运算模式来认定一条规则为左递归规则。<ul>
<li>二元。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr: ...</span><br><span class="line">    | expr (&#39;&lt;&#39; | &#39;&gt;&#39; | &#39;&#x3D; &#39;) expr</span><br><span class="line">    ...</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure></li>
<li>三元<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr: ...</span><br><span class="line">    | expr &#39;?&#39; expr &#39;:&#39; expr</span><br><span class="line">    ...</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure></li>
<li>一元前缀<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expr:...</span><br><span class="line">    |&#39;(&#39; type &#39;)&#39; expr</span><br><span class="line">    ...</span><br><span class="line">    |(&#39;+&#39;|&#39;-&#39;|&#39;++&#39;|&#39;--&#39;) expr</span><br><span class="line">    ...</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure></li>
<li>一元后缀<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expr:...</span><br><span class="line">    |expr ‘.’ Identifier</span><br><span class="line">    ...</span><br><span class="line">    |expr &#39;.&#39; &#39;super&#39; &#39;(&#39; exprList? &#39;)&#39;</span><br><span class="line">    ...</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="词法规则"><a href="#词法规则" class="headerlink" title="词法规则"></a>词法规则</h3><ul>
<li><p>匹配标识符<code>ID: [a-zA-Z]+;</code></p>
</li>
<li><p>匹配数字<code>ID: [0-9]+;</code></p>
</li>
<li><p>匹配字符串常量。<code>STINRG: &#39;&quot;&#39; .*? &#39;&quot;&#39;</code>。点通配符匹配任意的单个字符。因此，*.就是一个循环，它匹配零个或多个字符组成的任意字符序列。显然，它可以一直匹配到文件结束，但这没有任何意义。为解决这个问题，ANTLR 通过标准正则表达式的标记‘？’，提供了对非贪婪匹配子规则的支持。非贪婪匹配的基本含义是：“获取一些字符，直到发现匹配后续子规则的字符为止”。更准确的描述是，在保证整个父规则完成匹配的前提下，非贪婪子规则匹配数量最少的字符。不过目前这个字符串不支持字符串内包含双引号。</p>
</li>
<li><p>匹配注释并丢弃。<code>COMMENT:&#39;/*&#39; ,*? &#39;*/&#39; -&gt; skip;</code>. skip 是丢弃的含义。</p>
</li>
<li><p>匹配空白字符并丢弃。 <code>WS:[\t\n\r]+ -&gt; skip</code></p>
</li>
</ul>
<h2 id="ANTLR-解析过程的异常处理"><a href="#ANTLR-解析过程的异常处理" class="headerlink" title="ANTLR 解析过程的异常处理"></a>ANTLR 解析过程的异常处理</h2><p>ANTLR 语法分析器能够自动报告语法错误并从错误中恢复继续工作。比如前一个错误的表达式，则输出错误信息。然后继续正确地解析第二个表达式。<br>ANTLR 的错误处理机制有很高的灵活性。我们可以修改输出的错误信息，捕获识别过程中的异常，甚至改变基本的异常处理策略。</p>
<h2 id="在语法和词法文件中添加动作"><a href="#在语法和词法文件中添加动作" class="headerlink" title="在语法和词法文件中添加动作"></a>在语法和词法文件中添加动作</h2><h3 id="定制语法分析"><a href="#定制语法分析" class="headerlink" title="定制语法分析"></a>定制语法分析</h3><ul>
<li>在语法中嵌入任意动作<br>我们创建一个构造器，这样我们就能传入希望提取的列号；另外，我们需要在 row 规则的”(…)+”循环中放置一些动作。<br>下面的例子，是将输入文本中的指定列显示出来。<br>详细的内容，会在第 10 章。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">grammar Rows;</span><br><span class="line"></span><br><span class="line">@parser::members &#123; &#x2F;&#x2F; add members to generated RowsParser</span><br><span class="line">int col;</span><br><span class="line">public RowsParser(TokenStream input, int col) &#123; &#x2F;&#x2F; custom constructor</span><br><span class="line">this(input);</span><br><span class="line">this.col &#x3D; col;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file: (row NL)+ ;</span><br><span class="line"></span><br><span class="line">row</span><br><span class="line">locals [int i&#x3D;0]</span><br><span class="line">: ( STUFF</span><br><span class="line">&#123;</span><br><span class="line">$i++;</span><br><span class="line">          if ( $i &#x3D;&#x3D; col ) System.out.println(\$STUFF.text);</span><br><span class="line">&#125;</span><br><span class="line">)+</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">TAB : &#39;\t&#39; -&gt; skip ; &#x2F;&#x2F; match but don&#39;t pass to the parser</span><br><span class="line">NL : &#39;\r&#39;? &#39;\n&#39; ; &#x2F;&#x2F; match and pass to the parser</span><br><span class="line">STUFF: ~[\t\r\n]+ ; &#x2F;&#x2F; match any chars except tab, newline</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用语义判定改变语法分析过程(第 11 章)<br>下面的语法用来处理一组整数”2 9 10 3 1 2 3”。第一个数字 2 代表接下来匹配两个数组 9 和 10。紧接着数字 3 告诉我们匹配接下来的三个数字。<br>我们的目标是创建一份名为 Data 的语法，将 9 和 10 分为一组，然后 1,2,3 分为一组。<br>Data 语法的关键在于一段动作，它的值是布尔类型的，称为一个语义判定:{$i&lt;=$n&gt;}?。它的值在匹配到 n 个输入整数之前保持为 true,其中 n 是 sequence<br>语法中的参数。当语义判定的值为 false 时，对应的备选分支就从语法中“消失”了，因此，它也就从生成的语法分析器中“消失”了。在本例中，语义判定的值为 false 使得”(…)*“循环终止，从 sequence 规则返回。<br><img src="/images/antlr/4-4.png"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">grammar Data;</span><br><span class="line"></span><br><span class="line">file : group+ ;</span><br><span class="line"></span><br><span class="line">group: INT sequence[$INT.int] ;</span><br><span class="line"></span><br><span class="line">sequence[int n]</span><br><span class="line">locals [int i &#x3D; 1;]</span><br><span class="line">: ( &#123;$i&lt;&#x3D;$n&#125;? INT &#123;\$i++;&#125; )\* &#x2F;&#x2F; match n integers</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">INT : [0-9]+ ; &#x2F;&#x2F; match integers</span><br><span class="line">WS : [ \t\n\r]+ -&gt; skip ; &#x2F;&#x2F; toss out all whitespace</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="定制词法分析"><a href="#定制词法分析" class="headerlink" title="定制词法分析"></a>定制词法分析</h3><ul>
<li>孤岛语法:处理相同文件中的不同格式<br>mode INSIDE 定义模式，INSIDE 模式用于识别 XML 标签，默认模式用于识别标签之外的文本。<br>-&gt;定义了动作进入到 INSIDE 模式下<br>-&gt;定义了动作 popMode，从 INSIDE 模式下退出。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">lexer grammar XMLLexer;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Default &quot;mode&quot;: Everything OUTSIDE of a tag</span><br><span class="line">OPEN : &#39;&lt;&#39; -&gt; pushMode(INSIDE) ;</span><br><span class="line">COMMENT : &#39;&lt;!--&#39; .*? &#39;--&gt;&#39; -&gt; skip ;</span><br><span class="line">EntityRef : &#39;&amp;&#39; [a-z]+ &#39;;&#39; ;</span><br><span class="line">TEXT : ~(&#39;&lt;&#39;|&#39;&amp;&#39;)+ ; &#x2F;&#x2F; match any 16 bit char minus &lt; and &amp;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------------- Everything INSIDE of a tag ---------------------</span><br><span class="line">mode INSIDE;</span><br><span class="line"></span><br><span class="line">CLOSE : &#39;&gt;&#39; -&gt; popMode ; &#x2F;&#x2F; back to default mode</span><br><span class="line">SLASH_CLOSE : &#39;&#x2F;&gt;&#39; -&gt; popMode ;</span><br><span class="line">EQUALS : &#39;&#x3D;&#39; ;</span><br><span class="line">STRING : &#39;&quot;&#39; ._? &#39;&quot;&#39; ;</span><br><span class="line">SlashName : &#39;&#x2F;&#39; Name ;</span><br><span class="line">Name : ALPHA (ALPHA|DIGIT)_ ;</span><br><span class="line">S : [ \t\r\n] -&gt; skip ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">ALPHA : [a-zA-Z] ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">DIGIT : [0-9] ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>重写输入流<br>TokenStreamRewriter 对象可以改写输入的 TokenStream。关键之处，TokenStreamRewriter 对象实际上修改的是词法符号流的“视图”而非词法符号流本身。它认为所有对修改方法的调用都只是一个“指令”，然后将这些修改放入一个队列；在未来词法符号流被重新渲染为文本时，这些修改才会被执行。在每次我们调用 getText()的时候，rewriter 对象都会执行上述队列中的指令。</p>
<p>这样的方法在源代码插桩或者重构等场合下非常有效。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class InsertSerialIDListener extends JavaBaseListener &#123;</span><br><span class="line">TokenStreamRewriter rewriter;</span><br><span class="line">public InsertSerialIDListener(TokenStream tokens) &#123;</span><br><span class="line">rewriter &#x3D; new TokenStreamRewriter(tokens);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void enterClassBody(JavaParser.ClassBodyContext ctx) &#123;</span><br><span class="line">        String field &#x3D; &quot;\n\tpublic static final long serialVersionUID &#x3D; 1L;&quot;;</span><br><span class="line">        rewriter.insertAfter(ctx.start, field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>将词法符号送入不同通道<br>忽略却保留注释和空白字符的秘诀是将这些词法符号送入一个“隐藏通道”。语法分析器只处理一个通道，因此我们可以将希望保留的词法符号送入其他通道内。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">COMMENT</span><br><span class="line">: &#39;&#x2F;_&#39; ._? &#39;_&#x2F;&#39; -&gt; channel(HIDDEN) &#x2F;&#x2F; match anything between &#x2F;_ and \*&#x2F;</span><br><span class="line">;</span><br><span class="line">WS : [ \r\t\u000C\n]+ -&gt; channel(HIDDEN)</span><br><span class="line">;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="将生成的语法分析器与-Java-程序集成，并使用监听器遍历处理"><a href="#将生成的语法分析器与-Java-程序集成，并使用监听器遍历处理" class="headerlink" title="将生成的语法分析器与 Java 程序集成，并使用监听器遍历处理"></a>将生成的语法分析器与 Java 程序集成，并使用监听器遍历处理</h2><h3 id="例子-1-1"><a href="#例子-1-1" class="headerlink" title="例子 1"></a>例子 1</h3><p>Test.java<br>此例子的目标是将 Java 中，类似{99, 3, 451}的 short 数组翻译成”\u0063\u0003\u01c3”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.antlr.v4.runtime._;</span><br><span class="line">import org.antlr.v4.runtime.tree._;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void amin(String[] args) throws Exception&#123;</span><br><span class="line">&#x2F;&#x2F;新建一个 CharStream，从标准输入读取数据</span><br><span class="line">ANTLRInputStream input &#x3D; new ANTLRInputStream(System.in);</span><br><span class="line">&#x2F;&#x2F;新建一个词法分析器，处理输入的 CharStream</span><br><span class="line">ArrayInitLexer lexer &#x3D; new ArrayInitLexer(input);</span><br><span class="line">&#x2F;&#x2F;新建一个词法符号的缓冲区，用于存储词法分析器将生成的词法符号</span><br><span class="line">CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">&#x2F;&#x2F;新建一个语法分析器，处理词法符号缓冲区中的内容</span><br><span class="line">ArrayInitParser parser &#x3D; new ArrayInitParser(tokens);</span><br><span class="line">ParseTree tree &#x3D; parser.init(); &#x2F;&#x2F;针对 init 规则，开始语法分析。因为 init 规则是这些规则中根规则，所以适合从 init 开始分析</span><br><span class="line">&#x2F;_System.out.println(tree.toStringTree(parser));&#x2F;&#x2F;用 LISP 风格打印生成的树_&#x2F;</span><br><span class="line">&#x2F;&#x2F;新建一个通用的、能够触发回调函数的语法分析树遍历器</span><br><span class="line">ParseTreeWalker walker &#x3D; new ParseTreeWalker();</span><br><span class="line">&#x2F;&#x2F;遍历语法分析过程中生成的语法分析树，触发回调</span><br><span class="line">walker.walk(new ShortToUnicodeString(), tree);</span><br><span class="line">System.out.println();&#x2F;&#x2F;翻译完成后，打印一个\n</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ShortToUnicodeString.java<br>当遍历 AST 的时候，会对监听器里的方法进行回调。ArrayInitBaseListener 实现了 ArrayInitListener 接口的每个方法，我们只需要继承 ArrayInitBaseListener 并重写自己感兴趣的方法，就可以达到目的。ShortToUnicodeString 中的方法将翻译输入数据的一部分并将结果打印出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;将类似&#123;1,2,3&#125;的 short 数组初始化语句翻译为&quot;\u0001\u0002\u0003&quot;</span><br><span class="line">public class ShortToUnicodeString extends ArrayInitBaseListener &#123;</span><br><span class="line">&#x2F;&#x2F;将&#123;翻译为&quot;</span><br><span class="line">@Override</span><br><span class="line">public void enterInit(ArrayInitParser.InitContext ctx)&#123;</span><br><span class="line">System.out.print(&#39;&quot;&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将&#125;翻译为&quot;</span><br><span class="line">@Override</span><br><span class="line">public void exitInit(ArrayInitParser.InitContext ctx)&#123;</span><br><span class="line">System.out.print(&#39;&quot;&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将每个整数翻译为四位的十六进制形式，然后加前缀\u</span><br><span class="line">@Override</span><br><span class="line">public void enterValue(ArrrayInitParser.ValueContext ctx) &#123;</span><br><span class="line">&#x2F;&#x2F;假定不存在嵌套结构</span><br><span class="line">int value &#x3D; Integer.valueOf(ctx.INT().getText());&#x2F;&#x2F;ctx 是 value 的上下文对象，它获取 INT 词法符号对应的整数值。</span><br><span class="line">System.out.printf(&quot;\\u%04x&quot;, value);&#x2F;&#x2F;输出 16 进制数，总共占 4 为，前面的空位补 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h3><p>LibExpr.g4<br>此例子用来展示，将语法词法规则分布到多个不同文件中。<br>使用 import 功能，可以将一个大的语法文件分隔成小的，然后 import 导入连到一起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">grammar LibExpr; &#x2F;&#x2F; Rename to distinguish from original</span><br><span class="line">import CommonLexerRules; &#x2F;&#x2F; includes all rules from CommonLexerRules.g4</span><br><span class="line">&#x2F;\*_ The start rule; begin parsing here. _&#x2F;</span><br><span class="line">prog: stat+ ;</span><br><span class="line"></span><br><span class="line">stat: expr NEWLINE</span><br><span class="line">| ID &#39;&#x3D;&#39; expr NEWLINE</span><br><span class="line">| NEWLINE</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr: expr (&#39;\*&#39;|&#39;&#x2F;&#39;) expr &#x2F;&#x2F;左递归</span><br><span class="line">| expr (&#39;+&#39;|&#39;-&#39;) expr</span><br><span class="line">| INT</span><br><span class="line">| ID</span><br><span class="line">| &#39;(&#39; expr &#39;)&#39;</span><br><span class="line">;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>CommonLexerRules.g4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">lexer grammar CommonLexerRules; &#x2F;&#x2F; note &quot;lexer grammar&quot;</span><br><span class="line"></span><br><span class="line">ID : [a-zA-Z]+ ; &#x2F;&#x2F; match identifiers</span><br><span class="line">INT : [0-9]+ ; &#x2F;&#x2F; match integers</span><br><span class="line">NEWLINE:&#39;\r&#39;? &#39;\n&#39; ; &#x2F;&#x2F; return newlines to parser (end-statement signal)</span><br><span class="line">WS : [ \t]+ -&gt; skip ; &#x2F;&#x2F; toss out whitespace. &#39;-&gt; skip&#39;是丢弃操作。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ExprJoyRide.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.antlr.v4.runtime._;</span><br><span class="line">import org.antlr.v4.runtime.tree._;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">public class ExprJoyRide &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F;新建输入流</span><br><span class="line">String inputFile &#x3D; null;</span><br><span class="line">if ( args.length&gt;0 ) inputFile &#x3D; args[0];</span><br><span class="line">InputStream is &#x3D; System.in;</span><br><span class="line">if ( inputFile!&#x3D;null ) is &#x3D; new FileInputStream(inputFile);</span><br><span class="line">ANTLRInputStream input &#x3D; new ANTLRInputStream(is);</span><br><span class="line">&#x2F;&#x2F;新建词法分析器和语法分析器</span><br><span class="line">ExprLexer lexer &#x3D; new ExprLexer(input);</span><br><span class="line">CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">ExprParser parser &#x3D; new ExprParser(tokens);</span><br><span class="line">&#x2F;&#x2F;启动语法分析器开始解析</span><br><span class="line">ParseTree tree &#x3D; parser.prog();</span><br><span class="line">&#x2F;&#x2F;用文本形式将该规则方法 prog()返回的语法分析树打印出来</span><br><span class="line">System.out.println(tree.toStringTree(parser));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="例子-3-访问器"><a href="#例子-3-访问器" class="headerlink" title="例子 3 访问器"></a>例子 3 访问器</h3><p>LabeledExpr.g4<br>为每个备选分支定义一个标签，标签以#开头。这样 ANTLR 会为每个备选分支生成不同的访问器方法。这样我们就可以对每种输入都获得一个不同的事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">grammar LabeledExpr; &#x2F;&#x2F; rename to distinguish from Expr.g4</span><br><span class="line"></span><br><span class="line">prog: stat+ ;</span><br><span class="line"></span><br><span class="line">stat: expr NEWLINE # printExpr</span><br><span class="line">| ID &#39;&#x3D;&#39; expr NEWLINE # assign</span><br><span class="line">| NEWLINE # blank</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr: expr op&#x3D;(&#39;_&#39;|&#39;&#x2F;&#39;) expr # MulDiv</span><br><span class="line">| expr op&#x3D;(&#39;+&#39;|&#39;-&#39;) expr # AddSub</span><br><span class="line">| INT # int</span><br><span class="line">| ID # id</span><br><span class="line">| &#39;(&#39; expr &#39;)&#39; # parens</span><br><span class="line">;</span><br><span class="line">&#x2F;&#x2F;接下来我们为运算符词法符号定义一些名字，这样在随后的访问器中，我们就可以将这些词法符号的名字当做 JAVA 常量来引用。</span><br><span class="line">MUL : &#39;_&#39; ; &#x2F;&#x2F; assigns token name to &#39;\*&#39; used above in grammar</span><br><span class="line">DIV : &#39;&#x2F;&#39; ;</span><br><span class="line">ADD : &#39;+&#39; ;</span><br><span class="line">SUB : &#39;-&#39; ;</span><br><span class="line">ID : [a-zA-Z]+ ; &#x2F;&#x2F; match identifiers</span><br><span class="line">INT : [0-9]+ ; &#x2F;&#x2F; match integers</span><br><span class="line">NEWLINE:&#39;\r&#39;? &#39;\n&#39; ; &#x2F;&#x2F; return newlines to parser (is end-statement signal)</span><br><span class="line">WS : [ \t]+ -&gt; skip ; &#x2F;&#x2F; toss out whitespace</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Calc &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">String inputFile &#x3D; null;</span><br><span class="line">if ( args.length&gt;0 ) inputFile &#x3D; args[0];</span><br><span class="line">InputStream is &#x3D; System.in;</span><br><span class="line">if ( inputFile!&#x3D;null ) is &#x3D; new FileInputStream(inputFile);</span><br><span class="line">ANTLRInputStream input &#x3D; new ANTLRInputStream(is);</span><br><span class="line">LabeledExprLexer lexer &#x3D; new LabeledExprLexer(input);</span><br><span class="line">CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">LabeledExprParser parser &#x3D; new LabeledExprParser(tokens);</span><br><span class="line">ParseTree tree &#x3D; parser.prog(); &#x2F;&#x2F; parse</span><br><span class="line">&#x2F;&#x2F;实例化一个自定义的访问器，然后访问 tree</span><br><span class="line">EvalVisitor eval &#x3D; new EvalVisitor();</span><br><span class="line">eval.visit(tree);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用如下命令可以生成 visitor<br><code>antlr4 -no-listener -visitor LabeledExpr.g4</code><br>可以生成，LabeledExprBaseVisitor.java,LabeledExprParse.java,LabeledExprLexer.java,LabeledExprVisitor.java。<br>LabeledExprVisitor 是接口，LabeledExprBaseVisitor 是默认实现类。我们可以继承 LabeledExprBaseVisitor 然后重写里面的函数来实现自定义的逻辑。<br>EvalVisitor 内重写的方法对应备选分支的标签。里面引用的 JAVA 常量如：MUL，DIV 等。也是在语法文件中定义的词法符号名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class EvalVisitor extends LabeledExprBaseVisitor&lt;Integer&gt; &#123;</span><br><span class="line">&#x2F;\*_ &quot;memory&quot; for our calculator; variable&#x2F;value pairs go here _&#x2F;</span><br><span class="line">Map&lt;String, Integer&gt; memory &#x3D; new HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;** ID &#39;&#x3D;&#39; expr NEWLINE *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitAssign(LabeledExprParser.AssignContext ctx) &#123;</span><br><span class="line">        String id &#x3D; ctx.ID().getText();  &#x2F;&#x2F; id is left-hand side of &#39;&#x3D;&#39;</span><br><span class="line">        int value &#x3D; visit(ctx.expr());   &#x2F;&#x2F; compute value of expression on right</span><br><span class="line">        memory.put(id, value);           &#x2F;&#x2F; store it in our memory</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** expr NEWLINE *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitPrintExpr(LabeledExprParser.PrintExprContext ctx) &#123;</span><br><span class="line">        Integer value &#x3D; visit(ctx.expr()); &#x2F;&#x2F; evaluate the expr child</span><br><span class="line">        System.out.println(value);         &#x2F;&#x2F; print the result</span><br><span class="line">        return 0;                          &#x2F;&#x2F; return dummy value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** INT *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitInt(LabeledExprParser.IntContext ctx) &#123;</span><br><span class="line">        return Integer.valueOf(ctx.INT().getText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** ID *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitId(LabeledExprParser.IdContext ctx) &#123;</span><br><span class="line">        String id &#x3D; ctx.ID().getText();</span><br><span class="line">        if ( memory.containsKey(id) ) return memory.get(id);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** expr op&#x3D;(&#39;*&#39;|&#39;&#x2F;&#39;) expr *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitMulDiv(LabeledExprParser.MulDivContext ctx) &#123;</span><br><span class="line">        int left &#x3D; visit(ctx.expr(0));  &#x2F;&#x2F; get value of left subexpression</span><br><span class="line">        int right &#x3D; visit(ctx.expr(1)); &#x2F;&#x2F; get value of right subexpression</span><br><span class="line">        if ( ctx.op.getType() &#x3D;&#x3D; LabeledExprParser.MUL ) return left * right;</span><br><span class="line">        return left &#x2F; right; &#x2F;&#x2F; must be DIV</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** expr op&#x3D;(&#39;+&#39;|&#39;-&#39;) expr *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitAddSub(LabeledExprParser.AddSubContext ctx) &#123;</span><br><span class="line">        int left &#x3D; visit(ctx.expr(0));  &#x2F;&#x2F; get value of left subexpression</span><br><span class="line">        int right &#x3D; visit(ctx.expr(1)); &#x2F;&#x2F; get value of right subexpression</span><br><span class="line">        if ( ctx.op.getType() &#x3D;&#x3D; LabeledExprParser.ADD ) return left + right;</span><br><span class="line">        return left - right; &#x2F;&#x2F; must be SUB</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** &#39;(&#39; expr &#39;)&#39; *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitParens(LabeledExprParser.ParensContext ctx) &#123;</span><br><span class="line">        return visit(ctx.expr()); &#x2F;&#x2F; return child expr&#39;s value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子 4"></a>例子 4</h3><p>使用监听器来对 java 语法进行分析，根据实现类可以生成对应的接口定义，并保留注释<br>Java.g4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">classDeclaration</span><br><span class="line">: &#39;class&#39; Identifier typeParameters? (&#39;extends&#39; type)?</span><br><span class="line">(&#39;implements&#39; typeList)?</span><br><span class="line">classBody</span><br><span class="line">;</span><br><span class="line">methodDeclaration</span><br><span class="line">: type Identifier formalParameters (&#39;[&#39; &#39;]&#39;)\* methodDeclarationRest</span><br><span class="line">| &#39;void&#39; Identifier formalParameters methodDeclarationRest</span><br><span class="line">;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ExtractInterfaceListener.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ExtractInterfaceListener extends JavaBaseListener &#123;</span><br><span class="line">JavaParser parser;</span><br><span class="line">public ExtractInterfaceListener(JavaParser parser) &#123;this.parser &#x3D; parser;&#125;</span><br><span class="line">&#x2F;\*_ Listen to matches of classDeclaration _&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public void enterClassDeclaration(JavaParser.ClassDeclarationContext ctx)&#123;</span><br><span class="line">System.out.println(&quot;interface I&quot;+ctx.Identifier()+&quot; &#123;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void exitClassDeclaration(JavaParser.ClassDeclarationContext ctx) &#123;</span><br><span class="line">System.out.println(&quot;&#125;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Listen to matches of methodDeclaration *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void enterMethodDeclaration(</span><br><span class="line">        JavaParser.MethodDeclarationContext ctx</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; need parser to get tokens</span><br><span class="line">        TokenStream tokens &#x3D; parser.getTokenStream();</span><br><span class="line">        String type &#x3D; &quot;void&quot;;&#x2F;&#x2F;type为方法的返回类型</span><br><span class="line">        if ( ctx.type()!&#x3D;null ) &#123;</span><br><span class="line">            type &#x3D; tokens.getText(ctx.type());</span><br><span class="line">        &#125;</span><br><span class="line">        String args &#x3D; tokens.getText(ctx.formalParameters());&#x2F;&#x2F;args是入参</span><br><span class="line">        System.out.println(&quot;\t&quot;+type+&quot; &quot;+ctx.Identifier()+args+&quot;;&quot;);&#x2F;&#x2F;ctx.Identifier()是方法名</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ExtractInterfaceTool.java<br>将自定义的监听器集成到程序里，并遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ExtractInterfaceTool &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">String inputFile &#x3D; null;</span><br><span class="line">if ( args.length&gt;0 ) inputFile &#x3D; args[0];</span><br><span class="line">InputStream is &#x3D; System.in;</span><br><span class="line">if ( inputFile!&#x3D;null ) &#123;</span><br><span class="line">is &#x3D; new FileInputStream(inputFile);</span><br><span class="line">&#125;</span><br><span class="line">ANTLRInputStream input &#x3D; new ANTLRInputStream(is);</span><br><span class="line"></span><br><span class="line">        JavaLexer lexer &#x3D; new JavaLexer(input);</span><br><span class="line">        CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">        JavaParser parser &#x3D; new JavaParser(tokens);</span><br><span class="line">        ParseTree tree &#x3D; parser.compilationUnit(); &#x2F;&#x2F; parse。开始语法分析的过程</span><br><span class="line"></span><br><span class="line">        ParseTreeWalker walker &#x3D; new ParseTreeWalker(); &#x2F;&#x2F; create standard walker，新建一个标准的遍历器</span><br><span class="line">        ExtractInterfaceListener extractor &#x3D; new ExtractInterfaceListener(parser);</span><br><span class="line">        walker.walk(extractor, tree); &#x2F;&#x2F; initiate walk of tree with listener，使用监听器初始化对语法分析树的遍历</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="错误报告与恢复"><a href="#错误报告与恢复" class="headerlink" title="错误报告与恢复"></a>错误报告与恢复</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>ANTLR 在解析语法的时候，可以发现语法和词法的错误并给予提醒，尽管语法有错误，语法分析过程还是照常进行。除了产生良好的错误消息和利用剩余的输入进行重新同步之外，语法分析器还必须能够移动到何时的位置继续语法分析过程。</p>
<h3 id="修改和转发-ANTLR-的错误消息"><a href="#修改和转发-ANTLR-的错误消息" class="headerlink" title="修改和转发 ANTLR 的错误消息"></a>修改和转发 ANTLR 的错误消息</h3><h4 id="处理语法错误信息"><a href="#处理语法错误信息" class="headerlink" title="处理语法错误信息"></a>处理语法错误信息</h4><p>默认情况下，ANTLR 将所有的错误消息送至标准错误(standard error)，不过我们可以通过实现接口 ANTLRErrorListener 来改变这些消息的目标输出和内容。该接口有一个同时应用于词法分析器和语法分析器的 syntaxError()方法。syntaxError()方法接收各式各样的信息无论是错误的位置还是错误的内容。它还接收指向语法分析器的引用，因此我们能够通过引用来查询识别过程的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static class VerboseListener extends BaseErrorListener &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void syntaxError(Recognizer&lt;?,?&gt; recognizer,</span><br><span class="line">                            Object offendingSymbol,</span><br><span class="line">                            int line, int charPositionInLine,</span><br><span class="line">                            String msg,</span><br><span class="line">                            RecognitionException e) &#123;</span><br><span class="line">        List&lt;String&gt; stack &#x3D; ((Parser)recognizer).getRuleInvocationStack();</span><br><span class="line">        Collections.reverse(stack);</span><br><span class="line">        System.err.println(&quot;rule stack:&quot;+stack);</span><br><span class="line">        System.err.println(&quot;line&quot;+line+&quot;;&quot;+charPositionInLine+&quot;at&quot;+offendingSymbol+&quot;;&quot;+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这种方法，我们的程序就能在语法分析器调用其实规则之前，轻易地为其增加一个错误监听器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SimpleParser parser &#x3D; new SimpleParser(tokens);</span><br><span class="line">parser.removeErrorListeners();</span><br><span class="line">parser.addErrorListener(new VerboseListener());</span><br><span class="line">parser.prog;</span><br></pre></td></tr></table></figure>

<p>在我们增加自定义的错误监听器之前，我们需要移除输出目标是控制台的内置错误监听器，以防出现重复的错误消息。</p>
<h4 id="处理有歧义的语法信息"><a href="#处理有歧义的语法信息" class="headerlink" title="处理有歧义的语法信息"></a>处理有歧义的语法信息</h4><p>有时候用户输入的语法可以匹配到我们定义的多个语法分支，这是就存在歧义，默认情况下语法分析器不会通知用户，因为这不是用户的错。而是，我们定义的语法规则的问题。如果希望通知用于，则请使用 addErrorListener()方法添加一个 DiagnosticErrorListener 的实例来告知语法分析器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parser.removeErrorListeners();&#x2F;&#x2F;移除ConsoleErrorListener</span><br><span class="line">parser.addErrorListener(new DiagnosticErrorListener());</span><br></pre></td></tr></table></figure>

<p>此外，你还应当告诉语法分析器，你对所有的歧义告警都感兴趣，而不仅仅是哪些可以快速检测到的。出于效率方面的原因，ANTLR 的决策机制并不是总能发现所有的歧义信息。下面是令语法分析器报告所有歧义的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.getInterpreter().setPredictionMode(PredictionMode.LL_EXACT_AMBIG_DETECTION);</span><br></pre></td></tr></table></figure>

<p>在开发过程中使用上面提到的诊断错误监听器是个好主意，因为 ANTLR 工具不会对歧义性语法结构提出静态告警。在 ANTLR4 中，只有运行状态的语法分析器才能检测到歧义。这就像是 Java 中静态类型机制和 Python 中动态类型机制的差别。</p>
<h3 id="自动错误恢复机制"><a href="#自动错误恢复机制" class="headerlink" title="自动错误恢复机制"></a>自动错误恢复机制</h3><p>错误恢复指的是允许语法分析器在发现语法错误后还能继续的机制。语法分析器在遇到无法匹配词法符号的错误时，执行单词法符号补全和单词法符号移除。如果这些方案不奏效，语法分析器将向后查找词法符号，直到它遇到一个符合当前规则的后续部分的合理词法符号为止，接着，语法分析器将会继续语法分析过程，仿佛什么事情都没有发生过一样。<code>也就是，发生语法错误后从错误中恢复，然后继续语法解析。</code></p>
<ul>
<li>通过扫描后续词法符号来恢复。<br>当面对真正的非法输入时，当前的规则无法继续下去，此时语法分析器将会向后查找词法符号，知道它认为自己已经完成重新同步时，它就返回原先被调用的规则。我们可以成为‘同步-返回’策略。有人称为“应急模式”，不过它的表现相当好。语法分析器知道自己无法使用当前规则匹配当前输入。它会持续丢弃后续词法符号，知道发现一个可以匹配本规则中断位置之后的某条自规则的词法符号。例如，如果在赋值语句中存在一个语法错误，那么语法分析器的做法就非常合理：丢弃后续的词法符号，直到发现一个分好或者其他的语句终结符为止。这种策略较为激进，但是十分有效。我们下面将要看到，这种基本策略作为后备方案，在启用之前，ANTLR 会试图在规则内部进行恢复。<br>重新同步集合是调用栈中所有规则的后续符号集合的并集。<br>例如，如果语法分析其分析到 atom 时报错，比如输入的是“[]”，就会在 atom 的时候报错。调用栈为[group,expr,atom]那么此时的后续符号集合则是{‘^’,’]’}。然后语法分析其就从 atom 的错误中恢复了，然后继续分析，分析 expr 发现缺少^从而产生错误，然后继续从符号集合中恢复。然后匹配 group 最后匹配成功。<br>恢复过程中，ANTLR 语法分析器会避免输出层叠的错误消息，对于每个语法错误，直到成功从错误中恢复，语法分析器才输出一条错误消息。所以本次语法解析过程，实际上是产生了两处解析错误:atom 和 expr<br>注意后续符号集合的生成是动态计算的。是调用栈中所有规则的后续符号的并集。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">group : &#39;[&#39; expr &#39;]&#39; | &#39;(&#39; expr &#39;)&#39;;</span><br><span class="line">expr: atom &#39;^&#39; INT;</span><br><span class="line">atom: ID | INT;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>从不匹配的词法符号中恢复<br>在语法分析的过程中，最常见的操作之一就是“匹配词法符号”。对于语法中的每个词法符号 T，语法分析器都会调用 match(T)。如果当前的词法符号不是 T，match()方法就会通知错误监听器，并试图重新同步。为完成同步，它有三种选择：</p>
<ul>
<li>移除一个词法符号；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classDef: &#39;class&#39; ID &#39;&#123;&#39; member+ &#39;&#125;&#39; &#x2F;&#x2F;a class has one or more members</span><br><span class="line">&#123;System.out.println(&quot;class&quot;+$ID.text);&#125;</span><br></pre></td></tr></table></figure>

<p>考虑输入文本 class 9 T{int i;}，语法分析器会删除 9，然后继续进行同一条规则的语法分析过程–匹配类的定义体。</p>
<ul>
<li>补全一个词法符号；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classDef: &#39;class&#39; ID &#39;&#123;&#39; member+ &#39;&#125;&#39; &#x2F;&#x2F;a class has one or more members</span><br><span class="line">&#123;System.out.println(&quot;class&quot;+$ID.text);&#125;</span><br></pre></td></tr></table></figure>

<p>考虑输入文本 class {int i;}，语法分析器调用 match(ID),期望发现一个标识符，但实际上发现的却是{。这种情况下，语法分析器知道{是自己所期望的那个词法符号的下一个，因为在 classDef 规则中它位于 ID 之后。此时 match()方法可以假定标识符已经被发现并返回，这样，下一个 match(‘{‘)的调用就会成功。在忽略内嵌动作的前提下，这种方案表现得相当出色。但是，如果词法符号是 null，通过$ID.text 引用了缺失词法符号的打印语句就会引起一个异常。因此，错误处理器会创建一个词法符号，而非简单的假定该词法符号存在，详情参见 DefaultErrorStrategy 中的 getMissingSymbol()方法。新创建的词法符号具有语法分析器所期望的类型，以及和当前词法符号 LA（1）相同的行列位置信息。这个新创建的词法符号阻止了监听器和访问其中引用缺失词法符号时引发的异常。<br><img src="/images/antlr/9-6.png"></p>
<ul>
<li><p>从子规则的错误中恢复<br>在语法中手工插入一条空规则的引用，该规则包含特定的、能够在必要时触发错误恢复的动作。现在，ANTLR4 会在开始处和循环条件判定处自动插入同步检查，以避免集锦的恢复机制。</p>
<ul>
<li>子规则起始位置。在任意子规则的起始位置，语法分析器会尝试进行单词法符号移除。不过，和词法符号匹配不同的是，语法分析器不会尝试进行单词法符号补全。创建一个词法符号对 ANTLR 来说是很困难的，因为它必须猜测多个备选分支中的哪个会最终胜出。</li>
<li>子规则的循环条件判定位置。如果子规则是一个循环结构，即(…)*或(…)+，在遇到错误时，语法分析器会尝试进行积极的回复，使得自己留在循环内部。在成功地匹配到循环的某个备选分支之后，语法分析器会持续消费词法符号，直到发现满足下列条件之一的词法符号为止：</li>
<li>循环的另一次迭代</li>
<li>紧跟在循环之后的内容</li>
<li>当前规则的重新同步集合中的元素<br>例子：<br>考虑 Simple 语法的 classDef 规则中的 member+循环结构。如果我们手误多输入了’{‘，member+子规则会在进入 member 之前移除掉多余的那个词法符号。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; class T &#123;&#123;int i;&#125;</span><br><span class="line">&gt; EOF</span><br><span class="line">&gt; line 1:9 extraneous input &#39;&#123;&#39; expecting &#39;int&#39;</span><br><span class="line">var i</span><br><span class="line">class T</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>捕获失败的语义判定<br>语义判定指定了一些必须在运行时为真的条件，以使得语法分析器能够通过这些条件的验证。如果一个判定结果为假，语法分析器会抛出一个 FailedPredicateException 异常，该异常会被当前规则的 catch 语句捕获。语法分析器随机报告一个错误，并运行通用的同步-返回恢复机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vec4: &#39;[&#39; ints[4] &#39;]&#39;;</span><br><span class="line">ints[int max]</span><br><span class="line">locals [int i&#x3D;1]</span><br><span class="line">    : INT(&#39;,&#39; &#123;$i++;&#125; &#123;$i&lt;&#x3D;max&#125;? INT)*</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<p>下列测试给出的整数过多，于是我们看到了一个错误消息，以及错误恢复的过程，在这个过程中，多余的逗号和整数被丢弃了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; [1,2,3,4,5,6]</span><br><span class="line">&gt; EOF</span><br><span class="line">&gt; line 1:9 rule ints failed predicate: &#123;$i&lt;&#x3D;max&#125;?</span><br></pre></td></tr></table></figure>
<p>有时候我们输入的结构语法上是有效的，但是在语义上是无效的，这是，语义判定就不适用了。例如有种语言，要求变量不能被赋值 0.这意味“assignment x =0;”在语法上有效，在语义上无效。<br>较好的解决办法是手工输出一个错误，然后令语法分析器按照正确的语法继续继续进行匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assign</span><br><span class="line">    : ID &#39;&#x3D;&#39; v&#x3D;INT &#123;$v.int&gt;0&#125;? &#39;;&#39;</span><br><span class="line">    &#123;if ($v.int&#x3D;&#x3D;0) notifyListeners(&quot;values must be &gt; 0&quot;);&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>错误恢复机制的防护措施<br>ANTLR 的语法分析器具有内置的防护措施，以保证错误回复过程正常结束。如果我们在相同的语法分析位置，遇到了相同的输入情况，语法分析器会在尝试进行恢复之前强制消费一个词法符号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; class T &#123;</span><br><span class="line">&gt;    int int x;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; EOF</span><br><span class="line">&gt; line 2:6 no viable alternative at input &#39;intint&#39;</span><br><span class="line">&gt; var x</span><br><span class="line">&gt; class T</span><br></pre></td></tr></table></figure>

<p>classDef 规则调用了三次 member。其中，第一个 member 没有匹配到任何内容，第二个 member 匹配到了多余的 int。第三次匹配 member 的尝试正确地匹配到了“int x;”序列。<br><img src="/images/antlr/9-11.png"></p>
</li>
</ul>
</li>
<li><p>简单地抛出一个异常以启用基本的同步-返回机制<br>当面对真正的非法输入时，当前的规则无法继续下去，此时语法分析器将会向后查找词法符号，知道它认为自己已经完成重新同步时，它就返回原先被调用的规则。我们可以成为‘同步-返回’策略。有人称为“应急模式”，不过它的表现相当好。语法分析器知道自己无法使用当前规则匹配当前输入。它会持续丢弃后续词法符号，知道发现一个可以匹配本规则中断位置之后的某条自规则的词法符号。例如，如果在赋值语句中存在一个语法错误，那么语法分析器的做法就非常合适。</p>
</li>
</ul>
<h3 id="勘误备选分支"><a href="#勘误备选分支" class="headerlink" title="勘误备选分支"></a>勘误备选分支</h3><p>一些语法错误十分常见，以至于对它们进行特殊处理是值得的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stat: fcall &#39;;&#39;;</span><br><span class="line">fcall</span><br><span class="line">    : ID &#39;(&#39; expr &#39;)&#39;</span><br><span class="line">    | ID &#39;(&#39; expr &#39;)&#39; &#39;)&#39; &#123;notifyErrorListeners(&quot;Too many parentheses&quot;);&#125;</span><br><span class="line">    | ID &#39;(&#39; expr &#123;notifyErrorListeners(&quot;Missing closing&quot;);&#125;</span><br><span class="line">    ;</span><br><span class="line">expr: &#39;(&#39; expr &#39;)&#39;</span><br><span class="line">    | INT</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<h3 id="修改-ANTLR-的错误处理策略"><a href="#修改-ANTLR-的错误处理策略" class="headerlink" title="修改 ANTLR 的错误处理策略"></a>修改 ANTLR 的错误处理策略</h3><p>默认的错误处理机制表现出色，不过我们还是会遇到一些非典型的，需要修改默认机制的场景。首先，我们希望关闭某些默认的错误处理功能，他们会带来额外的运行负担。其次，我们可能希望语法分析器在遇到第一个语法错误时就退出。这种情况是，当处理类似 bash 的命令行输入时，从错误中回复是毫无意义的。我们不能一意孤星地执行有风险的命令，因此语法分析器可以一遇到问题就退出。探究错误处理策略，不妨看一下 ANTLRErrorStratege 接口及实现类 DefaultError-Strategy，该类完成了全部的默认错误处理工作。利用 ANTLRErrorListener 和 ANTLRErrorStrategy 接口，我们能够非常灵活地指定错误消息的输出位置、错误消息的内容以及语法分析器从错误中恢复的方法。</p>
<h2 id="在语法分析过程中执行自身的逻辑代码"><a href="#在语法分析过程中执行自身的逻辑代码" class="headerlink" title="在语法分析过程中执行自身的逻辑代码"></a>在语法分析过程中执行自身的逻辑代码</h2><p>在之前的学习中，我们的程序逻辑代码都是与语法分析树遍历器分离的，这意味着我们的代码总是在语法分析完成之后执行。在接下来的几节（属性和动作、使用语义判定修改语法分析过程、掌握词法分析的“黑魔法”）中我们可以看到，一些语言类应用程序需要在语法分析的过程中执行自身的逻辑代码。</p>
<h2 id="属性和动作"><a href="#属性和动作" class="headerlink" title="属性和动作"></a>属性和动作</h2><p>通常我们应当避免将语法和应用程序的逻辑代码纠缠在一起。不包含动作的语法更容易阅读，不会绑定到特定的目标语言和程序上。尽管如此，内嵌的动作仍然是有用的，原因有如下三个：</p>
<ul>
<li>简便: 有时，使用少量的动作，避免创建一个监听器或者访问器会使事情变得更加简单。</li>
<li>效率：在资源紧张的程序中，我们可能不想把宝贵的时间和内存浪费在简历语法分析树上。</li>
<li>待判定的语法分析过程：在某些罕见情况下，我们必须依赖从之前的输入流中获取的数据才能正常第进行语法分析过程。一些语法需要建立一个符号表，以便在未来根据情况差异化地识别输入的文本。</li>
</ul>
<p>动作就是使用目标语言编写的、放置在{}中的任意代码块。我们可以在动作中编写任意代码，只要它们是合法的目标语言语句。动作的典型用法是操纵词法符号和规则引用的属性。例如，我们可以读取一个词法符号对应的文本或者整个规则匹配的文本。通过从词法符号和规则引用中获取的数据，我们就可以打印结果或者执行任意计算。规则允许参数和返回值，因此我们可以在规则之间传递数据。</p>
<h3 id="添加动作"><a href="#添加动作" class="headerlink" title="添加动作"></a>添加动作</h3><ol>
<li><p>定义 header 和 members<br>这些动作可以位于规则内，也可以位于规则外。header 用于向自动生成的语法分析器和词法分析器中注入 package 或 import 语句。members 用于向自动生成的语法分析器和词法分析器中注入字段(成员变量)和方法(成员函数)。下面显示了注入代码片段的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;</span><br><span class="line">public class &lt;grammarName&gt;Parser extends Parser &#123;</span><br><span class="line">    &lt;members&gt;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用@header{}和@members{}来注入代码。{}内的代码，将出现在语法和词法解析器中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">grammar Expr;</span><br><span class="line">&#x2F;&#x2F;定义了语法和词法解析器所属的包，并导入了java.util包</span><br><span class="line">@header &#123;</span><br><span class="line">    package tools;</span><br><span class="line">    import java.util.*;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;新增了语法和词法解析器中的字段（成员变量）memory和方法eval()。</span><br><span class="line">@members &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; memory &#x3D; new HashMap&lt;String, Integer&gt;();</span><br><span class="line">    int eval (int left, int op, int right) &#123;</span><br><span class="line">        switch (op) &#123;</span><br><span class="line">            case MUL: return left * right;</span><br><span class="line">            case DIV: return left &#x2F; right;</span><br><span class="line">            case ADD: return left + right;</span><br><span class="line">            case SUB: return left - right;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在规则中嵌入动作<br>动作执行时机是它前面的语法元素之后。本例中，动作出现在备选分支的末尾，因此它们会在语法分析器匹配到整个语句之后被执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stat: e NEWLINE          &#123;System.out.println($e.v);&#125;</span><br><span class="line">    | ID &#39;&#x3D;&#39; e NEWLINE   &#123;memory.put($ID.text, $e.v);&#125;</span><br><span class="line">    | NEWLINE</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<ul>
<li>returns 定义了返回值 v，且类型为 int。通过$e.v 可以引用 e 规则的返回值。</li>
<li>a,b,op 都是标记，它们是对=右侧的引用。使用标记可以方便在动作中操作各种值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">e returns [int v]</span><br><span class="line">    : a&#x3D;e op&#x3D;(&#39;*&#39;|&#39;&#x2F;&#39;) b&#x3D;e &#123;$v &#x3D; eval($a.v, $op.type, $b.v);&#125;</span><br><span class="line">    | a&#x3D;e op&#x3D;(&#39;+&#39;|&#39;-&#39;) b&#x3D;e &#123;$v &#x3D; eval($a.v, $op.type, $b.v);&#125;</span><br><span class="line">    | INT                  &#123;$v &#x3D; $INT.int;&#125;</span><br><span class="line">    | ID</span><br><span class="line">        &#123;</span><br><span class="line">            String id &#x3D; $ID.text;</span><br><span class="line">            $v &#x3D; memory.containsKey(id) ? memory.get(id) : 0;</span><br><span class="line">        &#125;</span><br><span class="line">    | &#39;(&#39; e &#39;)&#39; &#123;$v &#x3D; $e.v;&#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
ANTLR 通过规则上下文对象来实现语法分析树的节点，每次规则调用都会新建并返回一个规则上下文对象。自然地，规则上下文对象非常适合放置与特定规则相关的数据实体。EContext 的第一部分如下所示:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static class EContext extends ParserRuleContext&#123;</span><br><span class="line">    public int v;        &#x2F;&#x2F;规则e的返回值</span><br><span class="line">    public EContext a;   &#x2F;&#x2F;规则引用e上的标记a</span><br><span class="line">    public Token op;     &#x2F;&#x2F;类似（‘*’|‘&#x2F;’）的运算符子规则上的标记</span><br><span class="line">    public EContext b;   &#x2F;&#x2F;规则引用e上的标记b</span><br><span class="line">    public Token INT;    &#x2F;&#x2F;第三个备选分支引用的INT</span><br><span class="line">    public Token ID;     &#x2F;&#x2F;第四个备选分支引用的ID</span><br><span class="line">    public EContext e;   &#x2F;&#x2F;e的调用过程对应的上下文对象的引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="访问词法符号和规则的属性"><a href="#访问词法符号和规则的属性" class="headerlink" title="访问词法符号和规则的属性"></a>访问词法符号和规则的属性</h3><p>此节中可以看到如何定义和引用规则的参数和返回值。<br>原始规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">grammar CSV;</span><br><span class="line"></span><br><span class="line">file : hdr row+;</span><br><span class="line">hdr : row ;</span><br><span class="line">row : field (&#39;,&#39; field)* &#39;\r&#39;? &#39;\n&#39;;</span><br><span class="line">field</span><br><span class="line">    : TEXT   # text</span><br><span class="line">    | STRING # string</span><br><span class="line">    |        # empty</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">TEXT : ~[,\n\r&quot;]+ ;</span><br><span class="line">STRING: &#39;&quot;&#39; (&#39;&quot;&quot;&#39;|~&#39;&quot;&#39;)* &#39;&quot;&#39; ;</span><br></pre></td></tr></table></figure>

<p>改造后的规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 由规则&quot;file: hdr row+ ;&quot;衍生而来 *&#x2F;</span><br><span class="line">file</span><br><span class="line">locals [int i&#x3D;0]</span><br><span class="line">    : hdr ( rows+&#x3D;row[$hdr.text.split(&quot;,&quot;)] &#123;$i++&#125; )+</span><br><span class="line">      &#123;</span><br><span class="line">          System.out.println($i+&quot;rows&quot;);</span><br><span class="line">          for (RowContext r : $rows) &#123;</span><br><span class="line">              System.out.println(&quot;row token interval:&quot;+r.getSourceInterval());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">hdr: row[null] &#123;System.out.println(&quot;header: &#39;&quot;+$text.trim()+&quot;&#39;&quot;);&#125;;</span><br><span class="line">&#x2F;* 由规则&quot;row: field (&#39;,&#39; field)* &#39;\r&#39;? &#39;\n&#39; ;&quot; 衍生而来*&#x2F;</span><br><span class="line">row[String[] columns] returns [Map&lt;String,String&gt; values]</span><br><span class="line">locals [int col&#x3D;0]</span><br><span class="line">@init&#123;</span><br><span class="line">    $values &#x3D; new HashMap&lt;String,String&gt;();</span><br><span class="line">&#125;</span><br><span class="line">@after&#123;</span><br><span class="line">    if ($values!&#x3D;null &amp;&amp; $values.size()&gt;0) &#123;</span><br><span class="line">        System.out.println(&quot;values &#x3D; &quot;+ $values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    : field</span><br><span class="line">        &#123;</span><br><span class="line">            if($columns!&#x3D;null) &#123;</span><br><span class="line">                $values.put($columns[$col++].trim(), $field.text.trim());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        (</span><br><span class="line">            &#39;,&#39; field</span><br><span class="line">            &#123;</span><br><span class="line">                if ($column!&#x3D;null)&#123;</span><br><span class="line">                    $values.put($columns[$col++].trim(), $field.text.trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )* &#39;\r&#39;? &#39;\n&#39;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>输入如下数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User,  Name,   Dept</span><br><span class="line">parrt, Terence, 101</span><br><span class="line">tombu, Tom,     020</span><br><span class="line">bke,   Kevin,   008</span><br></pre></td></tr></table></figure>

<p>输出解析结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">header: &#39;User, Name, Dept&#39;</span><br><span class="line">values &#x3D; &#123;Name&#x3D;Terence, User&#x3D;parrt, Dept&#x3D;101&#125;</span><br><span class="line">values &#x3D; &#123;Name&#x3D;Tom, User&#x3D;tombu, Dept&#x3D;020&#125;</span><br><span class="line">values &#x3D; &#123;Name&#x3D;Kevin, User&#x3D;bke, Dept&#x3D;008&#125;</span><br><span class="line">3 rows</span><br><span class="line">row token interval:6..11</span><br><span class="line">row token interval:12..17</span><br><span class="line">row token interval:18..23</span><br></pre></td></tr></table></figure>

<h3 id="关键字识别"><a href="#关键字识别" class="headerlink" title="关键字识别"></a>关键字识别</h3><p>此节中我们将看到如何使用词法符号属性，text 和 type。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">grammar Keywords;</span><br><span class="line">@lexer::header&#123;</span><br><span class="line">    import java.util.*;</span><br><span class="line">&#125;</span><br><span class="line">@lexer::members&#123;</span><br><span class="line">    Map&lt;String,Integer&gt; keywords &#x3D; new HashMap&lt;String,Integer&gt;() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            put(&quot;begin&quot;, KeywordsParser.BEGIN);</span><br><span class="line">            put(&quot;end&quot;, KeywordsParser.END);</span><br><span class="line">            put(&quot;if&quot;, KeywordsParser.IF);</span><br><span class="line">            put(&quot;then&quot;, KeywordsParser.THEN);</span><br><span class="line">            put(&quot;while&quot;, KeywordsParser.WHILE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">stat: BEGIN stat* END</span><br><span class="line">    | IF expr THEN stat</span><br><span class="line">    | WHILE expr stat</span><br><span class="line">    | ID &#39;&#x3D;&#39; expr &#39;;&#39;</span><br><span class="line">        ;</span><br><span class="line">expr: INT|CHAR;</span><br><span class="line">ID: [a-zA-Z]+&#123;</span><br><span class="line">    if(keywords.containsKey(getText()))&#123;</span><br><span class="line">        setType(keywords.get(getText()));&#x2F;&#x2F;重置词法符号类型</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">CHAR: &#39;\&#39;&#39;.&#39;\&#39;&#39;&#123;setText(String.valueOf(getText().charAt(1)))&#125;;</span><br><span class="line">tokens &#123;BEGIN, END, IF , THEN, WHILE&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用语义判定修改语法分析过程"><a href="#使用语义判定修改语法分析过程" class="headerlink" title="使用语义判定修改语法分析过程"></a>使用语义判定修改语法分析过程</h2><p>在上节中，内嵌动作仅仅是计算一些值或者打印结果。但是，某些情况下使用内嵌动作类修改语法分析过程是正确识别某些编程语言语句的唯一方案。本章我们学习一种特殊的动作{…}?,成为语义判定，它允许我们在运行时选择性地关闭部分语法。判定本身就是布尔表达式，它会减少语法分析器的在语法分析过程中可选项的数量。适当地减少可选项的数量会增强语法分析器的性能。在词法规则中使用判定，一样会拖慢词法分析器。<br>语义判定可以在两种常见情况下发挥作用。<br>第一，我们可能需要语法分析器处理同一门编程语言稍有差异的多个版本。语义判定允许我们通过命令行参数或者其他动态机制，在运行时选择所使用的方言。<br>第二，应用场景包含处理语法的歧义性。在某些编程语言中，相同的语法结构具有不同的含义，此时判定机制提供了一种方法，让我们能够在对相同输入文本的不同解释中做出选择。</p>
<ul>
<li><p>在语法规则中加入判定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">grammar Enum;</span><br><span class="line">@parser::members &#123;public static boolean java5;&#125;</span><br><span class="line"></span><br><span class="line">prog: (stat</span><br><span class="line">        | enumDecl</span><br><span class="line">        )+</span><br><span class="line">        ;</span><br><span class="line">stat: id &#39;&#x3D;&#39; expr &#39;;&#39; &#123;System.out.println($id.text+&quot;&#x3D;&quot;+$expr.text);&#125;;</span><br><span class="line">expr: id | INT;</span><br><span class="line">enumDecl: &#123;java5&#125;? &#39;enum&#39; name&#x3D;id &#39;&#123;&#39; id (&#39;,&#39; id)* &#39;&#125;&#39;</span><br><span class="line">        &#123;System.out.println(&quot;enum &quot;+$name.text);&#125;</span><br><span class="line">        ;</span><br><span class="line">ENUM: &#39;enum&#39;;</span><br><span class="line">ID: [a-zA-Z]+;</span><br></pre></td></tr></table></figure>

<p>判定可以开启和关闭任何在通过判定后能被匹配的规则。<br>下面这样写，一样是正确的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog : (&#123;java5&#125;? enumDecl| stat)+;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在词法规则中加入判定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enumDecl: &#39;enum&#39; name&#x3D;id &#39;&#123;&#39; id (&#39;,&#39; id)* &#39;&#125;&#39;</span><br><span class="line">          &#123;System.out.println(&quot;enum &quot;+$name.text);&#125;</span><br><span class="line">          ;</span><br><span class="line">ENUM: &#39;enum&#39; &#123;java5&#125;? ;&#x2F;&#x2F;必须放置在ID规则之前</span><br><span class="line">ID: [a-zA-Z]+;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，判定出现在词法规则的右侧，而非像文法规则一样的左侧。这是由于在语法分析中，语法分析器会对之后的内容进行预测，因此需要在匹配备选分支之前进行判定。而词法分析器不进行备选分支的预测。它们仅仅寻找最长的匹配文本，然后在发现整个词法符号后做出决策。当 java5 为假时，该判定关闭了 ENUM 规则。当它为真时，ENUM 和 ID 同时匹配了字符序列 e-n-u-m，此时该输入存在歧义。ANTLR 总是通过选择位置靠前的规则来解决词法歧义问题，也就是这里的 ENUM。</p>
</li>
<li><p>识别歧义文本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 前两个备选分支中使用了理想化的判定作为区分这两种情况的Demo **&#x2F;</span><br><span class="line">expr: &#123;&lt;&lt;isfunc(ID)&gt;&gt;&#125;? ID &#39;(&#39; expr &#39;)&#39; &#x2F;&#x2F;一个参数的函数调用</span><br><span class="line">    | &#123;&lt;&lt;istype(ID)&gt;&gt;&#125;? ID &#39;(&#39; expr &#39;)&#39; &#x2F;&#x2F;构造器风格的对expr的转换</span><br><span class="line">    | INT           &#x2F;&#x2F;整数常量</span><br><span class="line">    | ID            &#x2F;&#x2F;标识符</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>当我们使用这份带判定的语法再次进行测试时，输入”f(i);”被正确地解释成了函数调用表达式，而非声明。输入”T(i);”也被正确解释成了声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">decl: ID ID</span><br><span class="line">    | &#123;istype()&#125;? ID &#39;(&#39; ID &#39;)&#39;</span><br><span class="line">    ;</span><br><span class="line">expr: INT</span><br><span class="line">    | ID</span><br><span class="line">    | &#123;!istype()&#125;? ID &#39;(&#39; expr &#39;)&#39;</span><br><span class="line">    ;</span><br><span class="line">@parser::members &#123;</span><br><span class="line">    Set&lt;String&gt; types &#x3D; new HashSet&lt;String&gt;() &#123;&#123;add(&quot;T&quot;);&#125;&#125;;</span><br><span class="line">    boolean istype() &#123;return types.contains(getCurrentToken().getText());&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="掌握词法分析的“黑魔法”"><a href="#掌握词法分析的“黑魔法”" class="headerlink" title="掌握词法分析的“黑魔法”"></a>掌握词法分析的“黑魔法”</h2><h3 id="将词法符号送入不同通道"><a href="#将词法符号送入不同通道" class="headerlink" title="将词法符号送入不同通道"></a>将词法符号送入不同通道</h3><ul>
<li><p>将空格和回车送入不同通道，而正常的词法符号仍然位于默认的 0 通道。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WS ： [\t\n\r]+ -&gt; channel(1);</span><br><span class="line">SL_COMMENT : &#39;&#x2F;&#x2F;&#39; .*? &#39;\n&#39; -&gt; channel(2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问隐藏通道<br>通过继承监听器，在方法中可以调用 BufferedTokenStream.getHiddenTokensToRight()得到隐藏 channel，进而可以访问 channel 中的 Token 的 text 进行改造。</p>
</li>
</ul>
<h3 id="上下文相关的词法问题"><a href="#上下文相关的词法问题" class="headerlink" title="上下文相关的词法问题"></a>上下文相关的词法问题</h3><h3 id="字符流中的孤岛"><a href="#字符流中的孤岛" class="headerlink" title="字符流中的孤岛"></a>字符流中的孤岛</h3><h3 id="对-XML-进行语法分析和词法分析"><a href="#对-XML-进行语法分析和词法分析" class="headerlink" title="对 XML 进行语法分析和词法分析"></a>对 XML 进行语法分析和词法分析</h3><h2 id="语法参考"><a href="#语法参考" class="headerlink" title="语法参考"></a>语法参考</h2><h3 id="语法词汇表"><a href="#语法词汇表" class="headerlink" title="语法词汇表"></a>语法词汇表</h3><ol>
<li>注释<br>ANTLR 支持单行、多行注释。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grammar T;</span><br><span class="line">&#x2F;*多行</span><br><span class="line">  注释</span><br><span class="line"> *&#x2F;</span><br><span class="line">decl: ID; &#x2F;&#x2F;单行注释</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>标识符<br>词法符号名和词法规则名总是以大写字母开头。文法规则总是以小写字母开头。首字母之后的字符可以是大小写字符、数字和下划线。<br>tokens{LEXSYMBOL,ASYMBOL,BSYMBOL} //词法符号名<br>LEXSYMBOL: [0-9a-z]* //词法规则</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ID,LPAREN,RIGHT_CURLY &#x2F;&#x2F;词法符号和词法规则名</span><br><span class="line">expr,d2,header_file &#x2F;&#x2F;文法规则名</span><br></pre></td></tr></table></figure>

<pre><code>ANTLR是支持中文等unicode的。同时也支持非unicode，需要在使用ANTLR工具中使用-encoding选项，以便正确读字符。</code></pre>
<ol start="3">
<li><p>文本常量<br>ANTLR 不区分字符常量和字符串常量，所有的文本常量都是由单引号括起来的字符串，如’;’、’if’、‘&lt;’。文本常量不支持正则表达式。文本常量也可以是 Unicode 转义序列’\u00E8’，或者常见转义序列’\n’、’\r’等。<br>ANTLR 生成的识别器假定语法中的字符都是 Unicode 字符，ANTLR 运行库根据目标语言对输入文件的编码做出假设，例如对于 Java 运行库假定输入文件为 UTF-8 编码。（Unicode 是字符集每个字符一个码，UTF-8 定义了如何使用二进制存储这个码，比如变长或定长，使用 1 个字节还是多个字节）</p>
</li>
<li><p>动作<br>动作是使用目标语言编写代码块，由花括号包围的任意文本。内嵌代码可以出现在以@header 和@members 命名的动作、词法和文法规则、指定异常捕获区、文法规则的属性区域，以及一些规则元素的选项。</p>
</li>
<li><p>关键字</p>
<ul>
<li>不要使用 ANTLR 保留字，ANTLR 语法中的保留字列表:import、tokens、options 等。</li>
<li>不要使用 rule 这个关键字。rule 虽然不是关键字也要避免将它作为规则或者备选分支，因为这样会使得自动生成的 RuleContext 上下文对象与内之类冲突。</li>
<li>不要使用目标语言中的关键字作为词法符号、标签或者规则名。例如，if 规则会生成 if()函数。</li>
</ul>
</li>
</ol>
<h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grammar Name</span><br><span class="line">options&#123;&#125;    &#x2F;&#x2F;可选，options</span><br><span class="line">import...;   &#x2F;&#x2F;可选，import，用来导入词法规则或语法规则</span><br><span class="line">tokens &#123;...&#125; &#x2F;&#x2F;可选，词法符号名，用于定义未在本语法中定义词法规则的词法符号</span><br><span class="line">@actionName&#123;...&#125; &#x2F;&#x2F;可选,动作名。 @actionName可以是@header:在生成的代码头部插入&#123;&#125;中的内容; @member在生成的代码中插入变量，变量内容在&#123;&#125;中定义; @after在进行词法或语法分析后，执行&#123;&#125;中定义的动作。</span><br><span class="line"></span><br><span class="line">&lt;&lt;rule 1&gt;&gt; &#x2F;&#x2F;可能混杂一些词法和文法规则</span><br><span class="line">...</span><br><span class="line">&lt;&lt;rule N&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="文法规则"><a href="#文法规则" class="headerlink" title="文法规则"></a>文法规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">grammar Name</span><br><span class="line">e : e &#39;*&#39; e # Mult</span><br><span class="line">  | e &#39;+&#39; e # Add</span><br><span class="line">  | INT # Int</span><br><span class="line">  | &#39;return&#39; value &#x3D; a &#39;;&#39; #Return &#x2F;&#x2F;为规则a增加标签value</span><br><span class="line">  | &#39;&#123;&#39; el+&#x3D;INT (, el+&#x3D;INT)* &#39;&#125;&#39; &#x2F;&#x2F;通过+&#x3D;来实现列表标签，就是使用el可以访问一组INT数据</span><br><span class="line">  ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1.#标签的作用是为每个备选分支都生成一个监听器。不然的话，就只为规则生成监听器。所以标签的名要求不能与已有标签名或者规则名冲突。<br>2.ANTLR 为每个规则生成规则上下文对象，并附带访问方法。NameContext 对象里面包含访问 Econtext 的方法。<br>3.为规则 a 增加标签 value<br> 4.规则元素</p>
<h3 id="动作和属性"><a href="#动作和属性" class="headerlink" title="动作和属性"></a>动作和属性</h3><h3 id="词法规则-1"><a href="#词法规则-1" class="headerlink" title="词法规则"></a>词法规则</h3><h3 id="通配符和非贪婪子规则"><a href="#通配符和非贪婪子规则" class="headerlink" title="通配符和非贪婪子规则"></a>通配符和非贪婪子规则</h3><h3 id="语义判定"><a href="#语义判定" class="headerlink" title="语义判定"></a>语义判定</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/01/SQLite/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/01/SQLite/" class="post-title-link" itemprop="url">SQLite相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-01 21:00:00" itemprop="dateCreated datePublished" datetime="2021-02-01T21:00:00+08:00">2021-02-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-05 10:32:07" itemprop="dateModified" datetime="2021-05-05T10:32:07+08:00">2021-05-05</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><h2 id="OS-层"><a href="#OS-层" class="headerlink" title="OS 层"></a>OS 层</h2><p><code>sqlite3.h</code>定义了主要的数据结构<br>sqlite3_vfs: 定义了 vps 的名字，核心方法：比如创建文件，删除文件等。<br>sqlite3_io_methods: 定义了操作文件的方法，比如读文件，写文件等。<br>sqlite3_file：代表一个打开了的文件，由 sqlite3_vfs 中的 XOpen 方法返回。sqlite3_file 内部存储一个指向 sqlite3_io_methods 的指针。<br><code>test_demovfs.c</code>是一个 sqlite3_vfs 实现类的样例。C 语言中通过给结构体的函数指针赋值，来完成接口和实现类的连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static int demoDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync)&#123;</span><br><span class="line">    &#x2F;&#x2F;这方法在删除的时候，使用unlink删除文件后。还从zPath中提取目录，然后将删除的工作同步更改到目录中。也就是需要在文件系统中删除对应文件的元数据。这里值得研究！！！linux如何彻底删除一个文件。参考unix高级环境编程。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Pager-层"><a href="#Pager-层" class="headerlink" title="Pager 层"></a>Pager 层</h2><h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><h4 id="Database-File-Structure"><a href="#Database-File-Structure" class="headerlink" title="Database File Structure"></a>Database File Structure</h4><ol>
<li>SQLite 将每个 database file 分成了若干个固定大小的区域叫 page。这样 database file 就变成了数组，如下：<br><img src="/images/sqlite/sqlite-3.2.png"></li>
<li>page size 默认为 1024 bytes。这个值可以在编译时指定或者在创建第一个 table 之前使用命令<code>page_size pragma</code></li>
<li>page type.包含四中类型：free,tree,pointer-map,lock-byte.</li>
<li>数据库的元数据存储在第一个 page，其他 page 可以存储任意 page type 的数据。第一个 page 的结构如下<br><img src="/images/sqlite/sqlite-3.3.png"><br>file header 中 1 前 100 字节存储 database file 结构信息，中间部分存储(master catalog table) B+树用于跟踪文件中的其他 page。header 部分的内容如下：<br><img src="/images/sqlite/sqlite-3.4.png"></li>
<li>freelist 数据结构。它按照如下结构组织数据。trunk pointer 用于指向下一个节点，number of leaves 用于存储叶子指针的数量，leaf page numbers 用于存储 leaf pages 的数量。当 page 不被使用时，SQLite 将它存储进 Freelist 并不换给文件系统。后面有信息 page 需求时，先从 freelist 中找到可用 page。如果想把 page 归还，可以使用 vacuum 命令(手动或自动)清空 page。<br><img src="/images/sqlite/sqlite-3.5.png"></li>
</ol>
<h4 id="Journal-File-Structure"><a href="#Journal-File-Structure" class="headerlink" title="Journal File Structure"></a>Journal File Structure</h4><p>SQLite 使用三种日志文件：rollback journal, statement journal, master journal.</p>
<ul>
<li>Rollback journal.这个文件是临时文件，与 database file 位于同目录下。每次写事务时创建日志，每次结束时删除日志。<br><img src="/images/sqlite/sqlite-3.6.png"><ul>
<li>segment header structure.<ul>
<li>存储记录数，数据库初始 page 数量，sector size， page size，魔数(确认文件类型)等<br><img src="/images/sqlite/sqlite-3.7.png"></li>
<li>日志文件可以被保留，日志文件需要包含有效的 segment header。</li>
<li>SQLite 支持异步事务，也就是不强制刷新日志和 database file。这样性能好，但是不具备失败恢复性。</li>
</ul>
</li>
<li>log record structure<ul>
<li>数据结构如下：checksum 十分重要，因为在新建的文件中，log record 中的数据有可能是早先被删除的文件的内容，如果没有 checksum 做检查，那么脏数据就会被读取。这种将 page number 放在头部，checksum 放在尾部的方式，可以很好地在宕机后发现有问题的数据区域。因为一个区域的写往往是顺序的，如果头部和尾部是正确的，那么中间应该也是正确的。<br><img src="/images/sqlite/sqlite-3.8.png"></li>
</ul>
</li>
</ul>
</li>
<li>Statement journal<br>这个 Statement journal 被用来从 statement 失败中恢复数据库。当 Statement 执行成功后，这个文件被删除。<br>通过设置项，可以保留 Statement Journal。</li>
<li>多数据库事务日志和主日志<br>通常一个数据库只有一个 database file，一个 database file 对应一个事务。但是通过 attach 命令，可以将多个 database file 绑定在一个 sqlite 中。这样在一次事务执行过程中，可以操作多个 database file，每个 database file 都有自己单独的 rollback journal file。如果让多个子 journal file 保持全局原子性，需要使用 master journal。它位于 database file 同级目录，以-mj 结尾。<br>每个子 journal file，拥有 master journal 的名字。如下是子 journal file 的结构<br><img src="/images/sqlite/sqlite-3.9.png"></li>
</ul>
<h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><p>Journal 用于恢复，当事务失败或系统宕机时。每个数据库一个 Journal 文件，与数据库文件位于同目录，‘-journal’结尾命名。每当写事务开启时创建 journal，完成后关闭 journal。<br>SQLite 的使用的日志方式是最简单的且不是很高效。它在 page 级别粒度上记录旧值，使用 undo 方式恢复。SQLite 把将要被改变的数据所在的页的完整内容 copy 进 journal 中。journal 记录 database file 的尺寸在 journal segment header 中，当 journal 文件被创建是。如果 database file 被事务扩大了，那么 journal file 可以让 database file 回滚到原来大小。</p>
<ul>
<li>Journaled Page 跟踪：SQLite 使用内存 bit map 数据结构来跟踪哪个 page 被当前事务记录了日志。</li>
<li>不要给 database file 和 journal file 命名别名。</li>
<li>WAL。在修改 database file 在 disk 生效之前，一定保证先把日志刷盘，以保证可以在宕机后修复。</li>
<li>异步事务模式。也就是在提交时不将 journal 文件刷盘，这样速度很快，但是没有恢复能力。临时数据库默认是异步事务，因为宕机时我们不需要恢复临时数据库。</li>
<li>子事务管理。每个 Statement 子事务通过用户事务获取锁，它并不 刷盘，因为它不承担恢复的责任。一个 log record 写入 Statement journal 仅当在 Statement 执行前相应 page 已经写在了用户事务中。</li>
</ul>
<h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><h4 id="事务类型"><a href="#事务类型" class="headerlink" title="事务类型"></a>事务类型</h4><p>几乎所有数据库系统都是用锁来控制并发，使用日志来恢复。一开始 DBMS 首先将修改写入日志的磁盘中，然后再修改数据。当宕机发生时，撤销未完成的事务，重做已完成的事务。</p>
<ul>
<li>系统事务<br>SQLite 中读写数据都必须在事务中进行，但是不需要显示指明事务类型，SQLite 根据操作自行分辨。对于 SELECT 语句 SQLite 开始读事务，对于非 SELECT 语句 SQLite 开始读事务，再将读事务升级为写事务。一个 connection 可以同时执行多个 SELECT 语句，但是非 SELECT 在 connection 只能单个执行。也就是多个读事务+单个写事务可以并发执行在一个 connection 上，但多个写事务不行。<br>非 SELECT 语句被原子地执行，执行前 SQLite 获取锁，执行完成释放锁。</li>
<li>用户事务<br>默认的系统事务，在执行多个写操作时效率很低，因为每执行一个写操作都要操作日志和锁。这时可以使用用户事务<code>BEGIN TRANSACTION</code>和<code>COMMIT</code>来包含多个写操作，减少日志和锁操作。用户定义的事务只包含写操作，读操作仍然是独立的原来的自动提交。如果事务 abort，那么读到那些被事务更改的数据的读操作也将 abort。<br>SQLite 不支持嵌套事务。</li>
<li>Savepoint<br>在用户事务中可以设置 savepoint，savepoint 是数据库那个时刻的所有数据，可用于回滚当事务失败时。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t1(a PRIMARY KEY, b);</span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO t1 VALUES(1, &#39;one&#39;);</span><br><span class="line">INSERT INTO t1 VALUES(2, &#39;two&#39;);</span><br><span class="line">UPDATE t1 SET a &#x3D; a + 10 &#x2F;&#x2F;UPDATE操作违反了主键唯一性的约束，那么将产生一个冲突，UPDATE前默认创建了一个savepoint，可以用于回滚。当然也可以显示指定。使用&#96;SAVEPOINT&#96;</span><br><span class="line">INSERT INTO t1 VALUES(3,null);</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>数据库的锁是为了保证事务执行的隔离性，通过锁来实现事务访问的顺序性，进而实现了事务的隔离性。<br>SQLite 的锁是数据库级别的锁，将整个数据库锁住(也就是锁住那个数据库文件，SQLite 将一个库的所有内容存储在一个文件中)。SQLite 为了简化锁的复杂度，采取了严格要求并发程度的方式。它允许同一时间任意数量的读事务。但是同一时间只有一个写事务，没有其他读写事务。<br>为了实现事务访问的顺序性，需要使用两阶段锁。<br>Statement 子事务通过所在的父事务获取锁，所有锁持续被事务持有直到事务执行成功或者失败。<br>SQLite 在 unix 平台上的使用来自于 <code>os_unix.c</code> 文件的实现，但要实现对数据库的操作，其核心在于 SQLite 的锁机制。SQLite 采用粗放型的锁。当一个连接要写数据库时，所有其他的连接被锁住，直到写连接结束了它的事务。SQLite 有一个加锁表，来帮助不同的写数据库者能够在最后一刻再加锁，以保证最大的并发性。SQLite 使用锁逐步上升机制，为了写数据库，连接需要逐步地获得排它锁。对于 5 个不同的锁状态：未加锁(UNLOCKED)、共享(SHARED)、保留(RESERVED)、未决(PENDING)和排它(EXCLUSIVE)。每个数据库连接在同一时刻只能处于其中一个状态。每种状态(未加锁状态除外)都有一种锁与之对应。</p>
<ul>
<li><p>锁类型：在 SQLite 中为了写数据库，连接需要逐步地获得排它锁。SQLite 有 5 个不同的锁：未加锁(NO_LOCK)、共享锁(SHARED_LOCK)、保留锁(RESERVED_LOCK)、未决锁(PENDING_LOCK)和排它锁(EXCLUSIVE_LOCK)。</p>
</li>
<li><p>NO_LOCK：最初的状态是未加锁状态，在此状态下，连接还没有存取数据库。当连接到了一个数据库，甚至已经用 BEGIN 开始了一个事务时，连接都还处于未加锁状态。</p>
</li>
<li><p>SHARED 锁：SHARED 锁意味着进程要读（不写）数据库。一个数据库上可以同时有多个进程获得 SHARED 锁，哪个进程能够在 SHARED_FIRST 区域加共享锁(使用 LockFileEx()LockFileEx()函数)，即获得了 SHARED 锁。</p>
</li>
<li><p>RESERVED 锁： RESERVED 锁意味着进程将要对数据库进行写操作。一个数据库上同时只能有一个进程拥有 RESERVED 锁。RESERVED 锁可以与 SHARED 锁共存，并可以继续对数据库加新的 SHARED 锁。</p>
</li>
<li><p>PENDING 锁：PENDING LOCK 意味着进程已经完成缓存中的数据修改，并想立即将更新写入磁盘。它将等待此时已经存在的读锁事务完成，但是不允许对数据库加新的 SHARED LOCK(这与 RESERVED LOCK 相区别)。</p>
</li>
<li><p>EXCLUSIVE 锁：在此锁状态下，进程此时就可以自由地对数据库进行修改了，所有以前对缓冲区所做的修改都会被写到数据库文件。</p>
</li>
</ul>
<h4 id="锁的兼容性和转换"><a href="#锁的兼容性和转换" class="headerlink" title="锁的兼容性和转换"></a>锁的兼容性和转换</h4><p>下表中，每一行行首是指当前锁的类型，每一个列首是指申请的锁类型。Y 代表可以，N 代表不行。</p>
<p><img src="/images/sqlite/sqlite-4.1.png"></p>
<p>每一个事务都需要在执行读写操作前获取合适的锁。这是 Pager 的责任从文件上获取锁。<br>5 种锁中，pending 是一种内部类型锁。pager 不能直接跟 lock management 申请 pending。pager 只能申请 exclusive，然后 lock management 根据情况，可能返回拒绝或 pending lock 或 exclusive lock。<br><img src="/images/sqlite/sqlite-4.2.png"><br>一次读事务，nolock-shared lock-no lock.<br>一次写事务，nolock-shared lock-reserved lock- pending lock - Exclusive lock<br>一次事务回滚，nolock-shared lock-pending lock-exclusive lock</p>
<h4 id="锁的实现"><a href="#锁的实现" class="headerlink" title="锁的实现"></a>锁的实现</h4><p>SQLite 依赖 Linux 的的锁原语，fcnt()它可以提供读锁和写锁，并且指定锁定的文件中范围。<br>文件中的 512 字节用于锁。其中 510 字节用于 shared 锁和 exclusive 锁。fcntl 的读锁这 510 字节，则获取 shared 锁。写锁锁住 510，则获取 exclusive 锁。<br>reserved 锁，是第 511 字节。使用 fcntl()添加写锁。peding 锁在 512 字节，使用 fcntl()添加写锁。<br>这里的读锁为什么范围是 510 的原因是，windows 不支持读锁。那么使用一个大的范围，每个 bytes 单独设置一个写锁，可以支持 510 的写锁。那么这些写锁可以作为 sqlite 并发的读锁。<br><img src="/images/sqlite/sqlite-4.3.png"><br><img src="/images/sqlite/sqlite-4.4.png"></p>
<h4 id="unixLock-方法"><a href="#unixLock-方法" class="headerlink" title="unixLock 方法"></a>unixLock 方法</h4><p><code>os_unix.c</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static int unixLock(sqlite3_file *id, int eFileLock) &#x2F;&#x2F;加锁逻辑</span><br></pre></td></tr></table></figure>

<h4 id="面对锁时进程，线程，事务，unixFile，unixInodInfo-之间的关系"><a href="#面对锁时进程，线程，事务，unixFile，unixInodInfo-之间的关系" class="headerlink" title="面对锁时进程，线程，事务，unixFile，unixInodInfo 之间的关系"></a>面对锁时进程，线程，事务，unixFile，unixInodInfo 之间的关系</h4><p>Linux 操作系统中。 1.将锁与文件的 inode 联系在一起，而不是使用文件名，因为通过文件可以指向同一个 inode(因为符号链接，硬链接)。 2.锁的获取是通过文件描述符得到的，但是如果文件描述符指向相同的 inode，那么实际的效果还是在操作同一个锁。<br>因此，Linux 的这种机制，使得在同一个 process 下多个线程或 connection(transction)打开相同的文件时会出现问题，比因为对于系统来说它只按照 process+文件来区分锁的粒度。此时多个线程或 transaction 都在操作同一个锁.<br>所以，我们需要 unixInodeInfo 结构体在 process 存储文件锁的整体情况。一个 unixInodeInfo 对象代表一个位于 database file 的 SQLite 锁。一个 process 不能拥有多个指向相同文件的 unixInodeInfo 对象。因为一个 process 可以打开多个文件，所以使用 inodeList 来存储所有 unixInodeInfo 对象。<br><img src="/images/sqlite/sqlite-4.5.png"><br><img src="/images/sqlite/sqlite-4.6.png"></p>
<ul>
<li>unixInodeInfo</li>
</ul>
<p><code>os_unix.c</code> 文件<br><code>unixInodeInfo</code>结构体，存储了一个进程打开某个文件 iNode 的对应的锁的信息。当进程持有一个文件的 RESERVED 锁，线程如果申请 SHARED 锁，则该进程在 unixInodeInfo 中的 nShared 加 1。如果一个线程申请排它锁，进程则调用 fcntl 获取文件中的排它锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct unixInodeInfo &#123;</span><br><span class="line">  struct unixFileId fileId;       &#x2F;* unixInodeInfo 存储在list中，fileId作为key *&#x2F;</span><br><span class="line">  int nShared;                    &#x2F;* 持有SHARED锁的数量 *&#x2F;</span><br><span class="line">  unsigned char eFileLock;        &#x2F;* 进程持有的最高级的锁：SHARED_LOCK, RESERVED_LOCK, NOLOCK, PEDING, EXCLUSIVE. *&#x2F;</span><br><span class="line">  unsigned char bProcessLock;     &#x2F;* An exclusive process lock is held *&#x2F;</span><br><span class="line">  int nRef;                       &#x2F;* 打开的文件数量，因为多个文件可以指向同一个iNode *&#x2F;</span><br><span class="line">  unixShmNode *pShmNode;          &#x2F;* Shared memory associated with this inode *&#x2F;</span><br><span class="line">  int nLock;                      &#x2F;* Number of outstanding file locks *&#x2F;</span><br><span class="line">  UnixUnusedFd *pUnused;          &#x2F;* Unused file descriptors to close *&#x2F;</span><br><span class="line">  unixInodeInfo *pNext;           &#x2F;* List of all unixInodeInfo objects *&#x2F;</span><br><span class="line">  unixInodeInfo *pPrev;           &#x2F;*    .... doubly linked *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>unixFile</li>
</ul>
<p>位于<code>os_unix.c</code> 文件，SQLite 使用 unixFile 来跟踪一个文件的打开实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct unixFile &#123;</span><br><span class="line">  sqlite3_io_methods const *pMethod;  &#x2F;* Always the first entry *&#x2F;</span><br><span class="line">  sqlite3_vfs *pVfs;                  &#x2F;* The VFS that created this unixFile *&#x2F;</span><br><span class="line">  unixInodeInfo *pInode;              &#x2F;* Info about locks on this inode *&#x2F;</span><br><span class="line">  int h;                              &#x2F;* The file descriptor *&#x2F;</span><br><span class="line">  unsigned char eFileLock;            &#x2F;* The type of lock held on this fd *&#x2F;</span><br><span class="line">  unsigned short int ctrlFlags;       &#x2F;* Behavioral bits.  UNIXFILE_* flags *&#x2F;</span><br><span class="line">  int lastErrno;                      &#x2F;* The unix errno from last I&#x2F;O error *&#x2F;</span><br><span class="line">  void *lockingContext;               &#x2F;* Locking style specific state *&#x2F;</span><br><span class="line">  UnixUnusedFd *pUnused;              &#x2F;* Pre-allocated UnixUnusedFd *&#x2F;</span><br><span class="line">  const char *zPath;                  &#x2F;* Name of the file *&#x2F;</span><br><span class="line">  unixShm *pShm;                      &#x2F;* Shared memory segment information *&#x2F;</span><br><span class="line">  int szChunk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>多线程问题</p>
<ol>
<li>LinuxThreads 是按照线程区分 lock，不同线程之间不能覆盖 lock。NPTL(Native Posix Thread Library)从 3.7.0 开始支持的，同 Process 的线程之间可以相互覆盖 lock。</li>
<li>当一个线程关闭文件时，Linux 将删除 inode 上所有的锁，而不管具体是哪个线程的锁。SQLite 对此进行了优化，单个线程关闭文件时不会立刻删除所有的 lock，而是跟踪，等到 inode 上最后一个文件描述符被关闭时，才将所有文件描述符关闭并将 lock 释放掉。</li>
</ol>
</li>
<li><p>API</p>
</li>
</ul>
<p><code>unixLock</code>包含了完整的锁状态转换和加锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static int unixLock(sqlite3_file *id, int eFileLock) &#x2F;&#x2F;加锁逻辑</span><br></pre></td></tr></table></figure>

<p><code>unixFileLock</code>是对 fcntl 和 sqlilte 区域锁实现的封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static int unixFileLock(unixFile *pFile, struct flock *pLock)</span><br></pre></td></tr></table></figure>

<p><code>unixUnlock</code>是解锁</p>
<p>解开低等级锁，eFileLock 只能是 SHARED_LOCK 或 NO_LOCK。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static int unixUnlock(sqlite3_file *id, int eFileLock)&#123;</span><br><span class="line">  return posixUnlock(id, eFileLock, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Page-模块"><a href="#Page-模块" class="headerlink" title="Page 模块"></a>Page 模块</h3><h4 id="Page-模块简介"><a href="#Page-模块简介" class="headerlink" title="Page 模块简介"></a>Page 模块简介</h4><p>Page 模块的作用是提供了更高层次访问数据库文件的接口，它将原本面向字节的文件操作转换成了面向 page 的文件操作。Tree 模块完全依赖于 page 来访问数据。Page cache 通过将数据放在内存，加快数据的访问，并负责内存和磁盘间的数据同步。同时 Page 模块对事务，日志，锁管理负责。其中锁管理和日志管理在 SQLite 的事务原子提交特性中起着关键作用。<br>它为每个打开的 database file 维护一个单独的 page cache。如果同一个进程打开 database file 多次，会创建多个 cache 出来。<br>源码阅读参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/pfysw/article/details/79121815">https://blog.csdn.net/pfysw/article/details/79121815</a><br><img src="/images/sqlite/sqlite-5.1.png"></p>
<h4 id="Page-接口"><a href="#Page-接口" class="headerlink" title="Page 接口"></a>Page 接口</h4><p>模块提供了 Pager 对象，它跟 database file 一一对应。tree moudle 使用 pager 来调用读写功能。<br><img src="/images/sqlite/sqlite-5.2.png"></p>
<p>Pager 的结构中存储，日志文件描述符，数据库文件描述符，日志名，数据库文件名，页缓存，savepoint 数组等信息。<br><img src="/images/sqlite/sqlite-5.3.png"><br>当在用户事务中执行更新操作时是需要 savepoint 的用以失败时的回滚<br><img src="/images/sqlite/sqlite-5.4.png"></p>
<p>所有接口函数的定义都在<code>pager.c</code>，函数名都是以 sqlite3Pager 开头</p>
<h4 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h4><p>Page caches 位于应用进程的空间中，与操作系统的 cache 无关。每个进程中都保持独立的 Page Object，多个进程打开同一个 database file 的同一个区域，保存多份 page object。一个进程中的多个线程，他们既可以分别独立使用 cache 也可以共享 cache。<br><img src="/images/sqlite/sqlite-5.5.png"></p>
<ul>
<li>Cache State<br>Pager 结构体中 eState 和 eLock 两个控制 pager 的行为。<br>eState 有 7 个状态：PAGE_OPEN(pager 刚刚创建),PAGER_READER(位于读事务中，pager 可以读), PAGER_WRITER_LOCKED（位于写事务中，pager 可以写）,PAGER_WRITER_CACHEMOD（位于写事务中且 cache 已被修改）,PAGER_WRITER_DBMOD（位于写事务中且开始向 db file 中写）,PAGER_WRITER_FINISHED（位于写事务中且已写完 db file，准备提交）,PAGER_ERROR（发生读写错误，则进入到 ERROR）。<br>eLock 可以使 Pager 位于如下 4 种状态中：NO_LOCK(pager 没有访问数据),SHARED_LOCK(在多个读事务中，对应的多个 pager 正在读),RESERVED_LOCK(pager 已经预定了 database file 但是还没有开始写),EXCLUSIVE_LOCK（在写事务中，pager 已经在写） 中。<ul>
<li>一次 pager 的状态转换过程：<ol>
<li>一个 pager 刚开始是 NO_LOCK 状态；</li>
<li>tree 模块调用 sqlite3PagerGet()获取 page，pager 进入到 SHARED_LOCK 状态中；</li>
<li>tree 模块调用 sqlite3PagerUnref()释放所有 page，pager 进入到 NO_LOCK 状态；</li>
<li>tree 模块调用 sqlite3PagerWrite()，pager 进入到 RESERVED_LOCK 状态；</li>
<li>pager 进入到 EXCLUSIVE_LOCK，在真正将 page 修改写入到 database file 前；</li>
<li>在 sqlite3PagerRollback 或 sqlite3PagerCommit 执行过程中，pager 进入到 NO_LOCK 状态。</li>
</ol>
</li>
</ul>
</li>
<li>Cache 组织<br>每个 page cache 都通过一个 PCache handler 对象管理，pager 拥有 PCache handler 对象引用。如下是 PCache 对象的一些成员变量。<br><img src="/images/sqlite/sqlite-5.7.png"><br><code>为了理解Page的重点内容，这里解释下方的图</code>Pager 对象作为整个 Page 模块的主要对象,Pager 定义了成员<code>PCache *pPCache</code>。PCache 定义了成员<code>sqlite3_pcache *pCache</code>，这里 sqlite3_pcache 是一个可插拔模块，PCache1 实现了这个模块。PCache1 结构体中定义了<code>PgHdr1 *apHash</code>PgHdr1 是对 PgHdr 的具体实现。虚线框带包 page cache 的部分，这部分是可插拔的，接口在 sqlite3_pcache_methods2 中定义，PCache1 实现了这些接口。<br><img src="/images/sqlite/sqlite-5.8.png"></li>
<li>Cache 读<br>对 cache 进行读，使用 page number 作为 key 在 hash 表中搜索，如果搜到则返回。如果没有搜到从 disk 中加载到 cache，然后返回。如果加载时 hash table 没有空间了，则需要删除不用的 page 来加载新的 page，或者将脏页刷进 disk 来回收 page。<br>返回 page 后，改 page 标记为 pinned，使用后 unpinned。这个标记用于回收 page 时使用。</li>
<li>Cache 写<br>写时需要先刷 journal log，然后再写。同时写的过程中为 dirty，等待内容被刷入 disk。</li>
<li>Cache Fetch<br>SQlite 遵循 on command fetch，有些数据库能做到 prefetch。</li>
<li>Cache 管理<br>基本原则：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) Whenever there is a page in the cache, there is also a master copy of the   page in the database file. Whenever the cache copy is updated, the master copy may need to be updated too.</span><br><span class="line">(2) For a requested page that is not in the cache the master copy is referenced and a new cache copy is made from the  master.</span><br><span class="line">(3) If the cache is full and a new page is to be placed in the cache, a replacement algorithm is invoked to remove some old page from the cache to make room for the new one.</span><br></pre></td></tr></table></figure>
关键：cache 的管理是否合理的标准就是 cache 的命中率高不高。</li>
<li>Cache 回收机制<br>SQLite 使用了类似于 LRU 的机制。</li>
<li>源码阅读<br>testpcache 实现了 sqlite3_pcache_methods2 的接口可以认为是 sqlite3_pcache 的具体实现。可以通过阅读此部分源码，来理解 page cache 管理机制。<code>https://blog.csdn.net/pfysw/article/details/79186613</code>，最重要的函数 testpcacheFetch()。pgno 就是作为 hash 表中的 key。</li>
</ul>
<h4 id="事务管理-1"><a href="#事务管理-1" class="headerlink" title="事务管理"></a>事务管理</h4><p>pager 通过管理锁和日志来达到管理事务的目的。它负责决定锁类型，锁获取释放的时机。负责决定日志的内容。它通过两阶段协议来管理并发事务的顺序执行。事务管理分为两个方面：正常流程和恢复流程。</p>
<ul>
<li><p>正常流程<br>包括：读写 page，提交事务和 Statement 子事务，创建和保存 savepoints，回收 page cache 和刷新 page-cache 到 risk。</p>
<ol>
<li>读操作<br>sqlite3PagerGet()获取或创建 page 在 cache 中。在这个函数中，先获取 shared lock。读取成功后返回指向这个 page cache 的指针。如果是第一次读，这里可以参考 5.8figure，它将 private data 初始化为 0，然后供 tree moudle 调用初始化并存储数据。如何第一次获取锁，在获取 shared lock 时，会判断 hot journal file，如果存在则会先回滚。<br>最后，在 hashtable 中为 page 找到一个位置，然后将 disk 内容载入。</li>
<li>写操作<br>sqlite3PagerWrite()，负责 pinned the page。pager 需要获得 reserved lock，然后再升级为 exclusive lock。同时要在日志中写入旧数据并刷入 risk。再写入数据到 cache，最后刷到 risk。如果磁盘扇区大于 page 尺寸，则 SQLite 记录整个扇区而不是 page 到日志中。如果已经将 page 信息 copy 到 journal 文件中，则这个 page 不会有新的记录在 journal 文件中，因为这个 journal file 只负责回滚到事务最初状态。</li>
<li>Cache 刷盘<br>在两种情况下刷盘：1.cache 满了；2.事务提交。刷盘时先刷日志再刷数据。<br>具体过程参考：<a target="_blank" rel="noopener" href="https://www.sqlite.org/atomiccommit.html">https://www.sqlite.org/atomiccommit.html</a></li>
<li>Commit 操作<br>tree moudle 先调用 sqlite3PagerCommitPhaseOne(),获取 exclusive 锁然后调用系统 IO 接口写入数据并通过 fsync 强制刷盘。后调用 sqlite3PagerCommitPhaseTwo()，关闭 journal file，释放锁并降级锁至 NO_LOCK。<br>commit 的时间点发生在 journal file 被删除，这样才能保证宕机后不会让旧值覆盖了新值。<br>Multidatabase 的情况，需要 VM moudle 来协调，因为 pager 只负责单个数据。这时有个 master journal file 负责记录 single journal file 保证所有单数据的事务能够同步提交或在宕机后回滚。多个数据库的事务之间有可能因为要获取相同的锁，而造成死锁。SQLite 通过 retry 机制来解决。</li>
<li>Statement 操作<br>Statement 子事务按照匿名 savepoint 来实现，并且在结束时释放。分为 Read，Write,Commit 三种。Write 的操作有些复杂参看 SQLite Database System:5.4.1.5。</li>
<li>Savepoints<br>创建 Savepoints，当一个用户事务创建一个 savepoint 后，SQLite 就进入了 Savepoint 模式。这个模式下 SQLite 不再删除 statment journal 当 Statement 提交时。而是等到释放所有 Savepoint 才释放。<br>这里 page 存储的方式不同(没有 Savepoint 时，一个 trasaction 只在 journal 中存储一份 page)。当一个 page 被前一个 Statement 加入了 Statement journal，那么这个 page 可以被当前 Statement 加入同一个 Statement journal。这样同一个 stat journal 拥有一个 page 的多个 log。<br>释放 savepoints。当执行 release sp 命令时，PagerSavePoint 对象将被销毁。</li>
</ol>
</li>
<li><p>恢复过程<br>SQLite 需要能够将数据库从错误中恢复，保证数据库的一致性。分为四种情况。</p>
<ol>
<li>Transaction abort<br>当事务持有 RESERVED 或 PENDING lock 时，意味着数据文件没有被改变，所以 pager 删除缓存和 journal 文件即可。当事务持有 EXCLUSIVE lock 时，意味数据文件已经被改变。则需要扫描 journal 文件，恢复数据文件中原本的内容和大小，删除缓存，最后释放 EXCLUSIVE lock。</li>
<li>Statement subtransaction abort<br>SQLite 回滚所有日志从 statement journal 和 rollback journal。</li>
<li>Reverting to savepoints<br>SQLite 从 Statement journal file 中重放 Savepoint 之后的日志。其中 PagerSavepoint 对象的三个成员很关键：iOffset,iHdrOffset,iSubRec。如果是回滚整个事务，那么只需要回滚 rollback journal 并删除所有 PagerSavepoint 对象。</li>
<li>Recovery from failure<br>当系统发生宕机后，如果系统中有残留的 journal file 则意味着写事务在执行时失败了，需要使用 journal file 来回滚。<br>整体流程如下：<ol>
<li>获取 SHARED LOCK 在 database file</li>
<li>检查是否存在 hot journal file，如果没有则不需要恢复，如果有则继续按照如下步骤执行。</li>
<li>获取 EXCLUSIVE LOCK 在 database file。如果获取失败，则意味着另一个 pager 正在执行恢复。这是他返回 SQLITE_BUSY</li>
<li>它读取所有日志记录从 rollback journal file 并且回滚。</li>
<li>回滚后刷新磁盘，让记录存入 disk file。</li>
<li>删除 journal file</li>
<li>删除 master journal file 如果需要的话</li>
<li>将 lock 等级从 EXCLUSIVE 降低到 SHARED</li>
</ol>
</li>
</ol>
<p>检测 master journal 过期。如果 mj 中所有 rollback journal 都已经不存在，那么就删除 mj。</p>
</li>
<li><p>其他管理问题</p>
<ol>
<li>检查点<br>有时为减少故障恢复的时间，一些 database 会定期执行检查点，使得系统出错时可以直接从检查点恢复。SQLite 在 3.7.0 之前的版本并没有检查点。之后才引入检查点。</li>
<li>空间约束<br>一些 database 在回滚事务时产生了新的日志，此时可能会遇到问题，当系统没有更多空间来存储 journal file 时。SQLite 不会有这个问题，因为在回滚事务时，它不产生新的日志。但是空间不够在某种情况下，也会对 SQLite 造成影响。例如一种极端情况：事务执行时删除了一些数据导致 database file 缩小，当要恢复时文件系统的空间被操作系统其他进程占用了，导致无法在回滚时申请到所需要的空间。</li>
</ol>
</li>
</ul>
<h2 id="Tree-层"><a href="#Tree-层" class="headerlink" title="Tree 层"></a>Tree 层</h2><h2 id="Virtual-Machine-层"><a href="#Virtual-Machine-层" class="headerlink" title="Virtual-Machine 层"></a>Virtual-Machine 层</h2><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="Virtual-Machine-层-1"><a href="#Virtual-Machine-层-1" class="headerlink" title="Virtual-Machine 层"></a>Virtual-Machine 层</h2><h2 id="Parser-层"><a href="#Parser-层" class="headerlink" title="Parser 层"></a>Parser 层</h2><h2 id="Tokenizer-层"><a href="#Tokenizer-层" class="headerlink" title="Tokenizer 层"></a>Tokenizer 层</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/29/JMX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/29/JMX/" class="post-title-link" itemprop="url">JMX</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-29 19:11:30" itemprop="dateCreated datePublished" datetime="2021-01-29T19:11:30+08:00">2021-01-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-01-31 02:51:15" itemprop="dateModified" datetime="2021-01-31T02:51:15+08:00">2021-01-31</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Java 程序的运行过程中，对 JVM 和系统的监测一直是 Java 开发人员在开发过程所需要的。一直以来，Java 开发人员必须通过一些底层的 JVM API，比如 JVMPI 和 JVMTI 等，才能监测 Java 程序运行过程中的 JVM 和系统的一系列情况，这种方式一直以来被人所诟病，因为这需要大量的 C 程序和 JNI 调用，开发效率十分低下。于是出现了各种不同的专门做资源管理的程序包。为了解决这个问题，Sun 公司也在其 Java SE 5 版本中，正式提出了 Java 管理扩展（Java Management Extensions，JMX）用来管理检测 Java 程序（同时 JMX 也在 J2EE 1.4 中被发布）。</p>
<p>JMX 的提出，让 JDK 中开发自检测程序成为可能，也提供了大量轻量级的检测 JVM 和运行中对象 / 线程的方式，从而提高了 Java 语言自己的管理监测能力。</p>
<h2 id="JMX-和系统管理"><a href="#JMX-和系统管理" class="headerlink" title="JMX 和系统管理"></a>JMX 和系统管理</h2><p>管理系统（Management System）<br>要了解 JMX，我们就必须对当前的 IT 管理系统有一个初步的了解。随着企业 IT 规模的不断增长，IT 资源（IT resource）数量不断增加，IT 资源的分布也越来越分散。可以想象，甚至对于一家只有几百台 PC 公司的 IT 管理人员来说，分发一个安全补丁并且保证其在每台 PC 上的安装，如果只依赖人工来完成那简直就是一场噩梦。这样，IT 管理系统就应运而生。</p>
<p>然而，CPU、网卡、存储阵列是 IT 资源；OS、MS Office、Oracle database、IBM Websphere 也是 IT 资源。IT 管理系统若要对这些 IT 资源进行管理，就必须对这些管理对象有所了解：形形色色的 IT 资源就像是说着不同语言的人：Oralce 数据库表达内存紧张的方式和 Window XP 是绝然不同的， 而 IT 管理系统就像建造通天塔的经理，必须精通所有的语言， 这几乎是一个不可能完成的任务。难道 IT 管理系统是另外一个通天塔吗？当然不是！其实我们只要给每个 IT 资源配个翻译就可以了。</p>
<h2 id="管理系统的构架"><a href="#管理系统的构架" class="headerlink" title="管理系统的构架"></a>管理系统的构架</h2><p><img src="/images/java/jmx1.jpg"><br>图 1. 管理系统构架</p>
<p>上图分析了管理系统的基本构架模式。其中 Agent / SubAgent 起到的就是翻译的作用：把 IT 资源报告的消息以管理系统能理解的方式传送出去。</p>
<p>也许读者有会问，为什么需要 Agent 和 SubAgent 两层体系呢？这里有两个现实的原因：</p>
<p>管理系统一般是一个中央控制的控制软件，而 SubAgent 直接监控一些资源，往往和这些资源分布在同一物理位置。当这些 SubAgent 把状态信息传输到管理系统或者传达管理系统的控制指令的时候，需要提供一些网络传输的功能。<br>管理系统的消息是有一定规范的，消息的翻译本身是件复杂而枯燥的事情。<br>一般来说，管理系统会将同一物理分布或者功能类似的 SubAgent 分组成一组，由一个共用的 Agent 加以管理。在这个 Agent 里封装了 1 和 2 的功能。</p>
<h2 id="JMX-和管理系统"><a href="#JMX-和管理系统" class="headerlink" title="JMX 和管理系统"></a>JMX 和管理系统</h2><p>JMX 既是 Java 管理系统的一个标准，一个规范，也是一个接口，一个框架。图 2 展示了 JMX 的基本架构。</p>
<p><img src="/images/java/jmx2.jpg"><br>图 2. JMX 构架</p>
<p>和其它的资源系统一样，JMX 是管理系统和资源之间的一个接口，它定义了管理系统和资源之间交互的标准。 javax.management.MBeanServer 实现了 Agent 的功能，以标准的方式给出了管理系统访问 JMX 框架的接口。而 javax.management.MBeans 实现了 SubAgent 的功能，以标准的方式给出了 JMX 框架访问资源的接口。而从类库的层次上看，JMX 包括了核心类库 java.lang.management 和 javax.management 包。 java.lang.management 包提供了基本的 VM 监控功能，而 javax.management 包则向用户提供了扩展功能。</p>
<h2 id="JMX-的基本框架"><a href="#JMX-的基本框架" class="headerlink" title="JMX 的基本框架"></a>JMX 的基本框架</h2><p>JMX 使用了 Java Bean 模式来传递信息。一般说来，JMX 使用有名的 MBean，其内部包含了数据信息，这些信息可能是：应用程序配置信息、模块信息、系统信息、统计信息等。另外，MBean 也可以设立可读写的属性、直接操作某些函数甚至启动 MBean 可发送的 notification 等。MBean 包括 Standard，MXBean，Dynamic，Model，Open 等几种分类，其中最简单是标准 MBean 和 MXBean，而我们使用得最多的也是这两种。MXBean 主要是 java.lang.management 使用较多，将在下一节中介绍。我们先了解其他一些重要的 MBean 的种类。</p>
<h2 id="标准-MBean"><a href="#标准-MBean" class="headerlink" title="标准 MBean"></a>标准 MBean</h2><p>标准 MBean 是最简单的一类 MBean，与动态 Bean 不同，它并不实现 javax.management 包中的特殊的接口。说它是标准 MBean， 是因为其向外部公开其接口的方法和普通的 Java Bean 相同，是通过 lexical，或者说 coding convention 进行的。下面我们就用一个例子来展现，如何实现一个标准 MBean 来监控某个服务器 ServerImpl 状态的。ServerImpl 代表了用来演示的某个 Server 的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package standardbeans;</span><br><span class="line"> public class ServerImpl &#123;</span><br><span class="line">    public final long startTime;</span><br><span class="line">    public ServerImpl() &#123;</span><br><span class="line">        startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>显示更多<br>然后，我们打算使用一个标准 MBean，ServerMonitor 来监控 ServerImpl：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package standardbeans;</span><br><span class="line"> public class ServerMonitor implements ServerMonitorMBean &#123;</span><br><span class="line">    private final ServerImpl target;</span><br><span class="line">    public ServerMonitor(ServerImpl target)&#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line">    public long getUpTime()&#123;</span><br><span class="line">        return System.currentTimeMillis() - target.startTime;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>显示更多<br>这里的 ServerMonitorBean 又是怎么回事呢？ MXBean 规定了标准 MBean 也要实现一个接口，所有向外界公开的方法都要在这个接口中声明。否则，管理系统就不能从中获得相应的信息。此外，该接口的名字也有一定的规范：即在标准 MBean 类名之后加上”MBean”后缀。若 MBean 的类名叫做 MBeansName 的话，对应的接口就要叫做 MBeansNameMBean。</p>
<p>对于管理系统来说，这些在 MBean 中公开的方法，最终会被 JMX 转化成属性（Attribute）、监听（Listener）和调用（Invoke）的概念。如果读者对 Java Bean 有一些了解的话，不难看出， public long getUpTime() 对应了 Bean 中的一个称为”upTime”的只读属性。</p>
<p>下面我们就看一个模拟管理系统的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package standardbeans;</span><br><span class="line"> import javax.management.MBeanServer;</span><br><span class="line"> import javax.management.MBeanServerFactory;</span><br><span class="line"> import javax.management.ObjectName;</span><br><span class="line"> public class Main &#123;</span><br><span class="line">    private static ObjectName objectName ;</span><br><span class="line">    private static MBeanServer mBeanServer;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        init();</span><br><span class="line">        manage();</span><br><span class="line">    &#125;</span><br><span class="line">    private static void init() throws Exception&#123;</span><br><span class="line">        ServerImpl serverImpl &#x3D; new ServerImpl();</span><br><span class="line">        ServerMonitor serverMonitor &#x3D; new ServerMonitor(serverImpl);</span><br><span class="line">        mBeanServer &#x3D; MBeanServerFactory.createMBeanServer();</span><br><span class="line">        objectName &#x3D; new ObjectName(&quot;objectName:id&#x3D;ServerMonitor1&quot;);</span><br><span class="line">        mBeanServer.registerMBean(serverMonitor,objectName);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void manage() throws Exception&#123;</span><br><span class="line">        Long upTime &#x3D; (Long) mBeanServer.getAttribute(objectName,</span><br><span class="line">        &quot;upTime&quot;);</span><br><span class="line">        System.out.println(upTime);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>显示较少<br>JMX 的核心是 MBServer。Java SE 已经提供了一个默认实现，可以通过 MBServerFactory.createMBeanServer() 获得。每个资源监控者（MBean）一般都会有名称（ObjectName）， 登记在 MBServer 内部的一个 Repository 中。注意，这个 ObjectName 对于每一个 MBServer 必须是唯一的，只能对应于一个 MBean。（读者有兴趣的话，可以试着再给 mBeanServer 注册一个同名的 objectName，看看会怎么样。） 上述例子是在 init() 方法中完成向 MBeanServer 注册工作的。</p>
<p>在管理过程中，管理系统并不与资源或者 SubAgent 直接打交道，也就是说，这里不会直接引用到 MBean。而是通过 MBeanServer 的 getAttribute 方法取得对应 MBean 的属性的。</p>
<h2 id="动态-MBean"><a href="#动态-MBean" class="headerlink" title="动态 MBean"></a>动态 MBean</h2><h2 id="虚拟机检测"><a href="#虚拟机检测" class="headerlink" title="虚拟机检测"></a>虚拟机检测</h2><p>JMX 与虚拟机检测<br>JMX 的提出，为 Java 虚拟机提供了 Java 层上的检测机制。J2SE 中，新提出的 java.lang.management 包即是 JMX 在 JDK 的一个应用，它提供了大量的有用的接口，通过 MBean 方式，提供了对 Java 虚拟机和运行时远端的监控和检测方式，来帮助用户来检测本地或者远端的虚拟机的运行情况。有了 JMX 之后，我们可以设计一个客户端，来检测远端一个正在运行的虚拟机中的线程数、线程当前的 Stack、内存管理、GC 所占用的时间、虚拟机中的对象和当前虚拟机参数等重要的参数和运行时信息。JMX 另外的一个重要功能是对配置信息的检测和再配置。比如，我们可以在远端查看和修改当前 JVM 的 verbose 参数，以达到动态管理的目的。甚至，我们可以在远端指挥 JVM 做一次 GC，这在下文中有详细介绍。</p>
<h2 id="JMX-提供的虚拟机检测-API"><a href="#JMX-提供的虚拟机检测-API" class="headerlink" title="JMX 提供的虚拟机检测 API"></a>JMX 提供的虚拟机检测 API</h2><p>检测虚拟机当前的状态总是 Java 开放人员所关心的，也正是因为如此，出现了大量的 profiler 工具来检测当前的虚拟机状态。从 Java SE 5 之后，在 JDK 中，我们有了一些 Java 的虚拟机检测 API，即 java.lang.management 包。Management 包里面包括了许多 MXBean 的接口类和 LockInfo、MemoryUsage、MonitorInfo 和 ThreadInfo 等类。从名字可以看出，该包提供了虚拟机内存分配、垃圾收集（GC）情况、操作系统层、线程调度和共享锁，甚至编译情况的检测机制。这样一来，Java 的开发人员就可以很简单地为自己做一些轻量级的系统检测，来确定当前程序的各种状态，以便随时调整。</p>
<p>要获得这些信息，我们首先通过 java.lang.management.ManagementFactory 这个工厂类来获得一系列的 MXBean。包括：</p>
<ul>
<li>ClassLoadingMXBean</li>
</ul>
<p>ClassLoadMXBean 包括一些类的装载信息，比如有多少类已经装载 / 卸载（unloaded），虚拟机类装载的 verbose 选项（即命令行中的 Java – verbose:class 选项）是否打开，还可以帮助用户打开 / 关闭该选项。</p>
<ul>
<li>CompilationMXBean</li>
</ul>
<p>CompilationMXBean 帮助用户了解当前的编译器和编译情况，该 mxbean 提供的信息不多。</p>
<ul>
<li>GarbageCollectorMXBean</li>
</ul>
<p>相对于开放人员对 GC 的关注程度来说，该 mxbean 提供的信息十分有限，仅仅提供了 GC 的次数和 GC 花费总时间的近似值。但是这个包中还提供了三个的内存管理检测类：MemoryManagerMXBean，MemoryMXBean 和 MemoryPoolMXBean。</p>
<ul>
<li>MemoryManagerMXBean</li>
</ul>
<p>这个类相对简单，提供了内存管理类和内存池（memory pool）的名字信息。</p>
<ul>
<li>MemoryMXBean</li>
</ul>
<p>这个类提供了整个虚拟机中内存的使用情况，包括 Java 堆（heap）和非 Java 堆所占用的内存，提供当前等待 finalize 的对象数量，它甚至可以做 gc（实际上是调用 System.gc）。</p>
<ul>
<li>MemoryPoolMXBean</li>
</ul>
<p>该信息提供了大量的信息。在 JVM 中，可能有几个内存池，因此有对应的内存池信息，因此，在工厂类中，getMemoryPoolMXBean() 得到是一个 MemoryPoolMXBean 的 list。每一个 MemoryPoolMXBean 都包含了该内存池的详细信息，如是否可用、当前已使用内存 / 最大使用内存值、以及设置最大内存值等等。</p>
<ul>
<li>OperatingSystemMXBean</li>
</ul>
<p>该类提供的是操作系统的简单信息，如构架名称、当前 CPU 数、最近系统负载等。</p>
<ul>
<li>RuntimeMXBean</li>
</ul>
<p>运行时信息包括当前虚拟机的名称、提供商、版本号，以及 classpath、bootclasspath 和系统参数等等。</p>
<ul>
<li>ThreadMXBean</li>
</ul>
<p>在 Java 这个多线程的系统中，对线程的监控是相当重要的。ThreadMXBean 就是起到这个作用。ThreadMXBean 可以提供的信息包括各个线程的各种状态，CPU 占用情况，以及整个系统中的线程状况。从 ThreadMXBean 可以得到某一个线程的 ThreadInfo 对象。这个对象中则包含了这个线程的所有信息。</p>
<h2 id="java-lang-management-和虚拟机的关系"><a href="#java-lang-management-和虚拟机的关系" class="headerlink" title="java.lang.management 和虚拟机的关系"></a>java.lang.management 和虚拟机的关系</h2><p>我们知道，management 和底层虚拟机的关系是非常紧密的。其实，有一些的是直接依靠虚拟机提供的公开 API 实现的，比如 JVMTI；而另外一些则不然，很大一块都是由虚拟机底层提供某些不公开的 API / Native Code 提供的。这样的设计方式，保证了 management 包可以提供足够的信息，并且使这些信息的提供又有足够的效率；也使 management 包和底层的联系非常紧密。</p>
<h2 id="锁检测"><a href="#锁检测" class="headerlink" title="锁检测"></a>锁检测</h2><p>我们知道，同步是 Java 语言很重要的一个特性。在 Java SE 中，最主要的同步机制是依靠 synchronize 关键字对某一个对象加锁实现的；在 Java SE 5 之后的版本中，concurrent 包的加入，大大强化了 Java 语言的同步能力，concurrent 提供了很多不同类型的锁机制可供扩展。因此，要更好地观测当前的虚拟机状况和不同线程的运行态，去观察虚拟机中的各种锁，以及线程与锁的关系是非常必要的。很可惜的是，在过去的 JDK 中，我们并没有非常方便的 API 以供使用。一个比较直接的检测方式是查看线程的 stack trace，更为强大全面（但是也更复杂并且效率低下）的方案是得到一个 VM 所有对象的快照并查找之，这些策略的代价都比较大，而且往往需要编写复杂的 Native 代码。</p>
<p>JDK 6 里提供了一些相当简单的 API 来提供这个服务。首先了解两个新类，LockInfo 和 MonitorInfo 这两个类承载了锁的信息。LockInfo 可以是任何的 Java 锁，包括简单 Java 锁和 java.util.concurrent 包中所使用的锁（包括 AbstractOwnableSynchronizer 和 Condition 的实现类 / 子类），而 MonitorInfo 是简单的 Java 对象所代表的锁。要检测一个线程所拥有的锁和等待的锁，首先，要得到一个线程的 ThreadInfo，然后可以简单地调用：</p>
<p>getLockedMonitors()</p>
<p>返回一个所有当前线程已经掌握的锁对象的列表。</p>
<p>getLockedSynchronizers()</p>
<p>对于使用 concurrent 包的线程，返回一个该线程所掌握的”ownable synchronizer”（即 AbstractOwnableSynchronizer 及其子类）所组成的列表。</p>
<p>getLockInfo()</p>
<p>当前线程正在等待的那个锁对象的信息就可以知道线程所有的锁信息。通过这些锁信息，我们很方便的可以知道当前虚拟机的所有线程的锁信息。由此，我们还可以推导出更多的信息。</p>
<h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>死锁检测一直以来是软件工程师所重视的，显然一个死锁的系统永远是工程师最大的梦魇。Java 程序的死锁检测也一直以来是 Java 程序员所头痛的。为了解决线程间死锁问题，一般都有预防（代码实现阶段）和死锁后恢复（运行时）两种方式。以前 Java 程序员都重视前者，因为在运行态再来检测和恢复系统是相当麻烦的，缺少许多必要的信息；但是，对于一些比较复杂的系统，采取后者或者运行时调试死锁信息也是非常重要的。由上面所说，现在我们已经可以知道每一个线程所拥有和等待的锁，因此要计算出当前系统中是否有死锁的线程也是可行的了。当然，Java 6 里面也提供了一个 API 来完成这个功能，即：</p>
<p>ThreadMXBean.findDeadlockedThreads()</p>
<p>这个函数的功能就是检测出当前系统中已经死锁的线程。当然，这个功能复杂，因此比较费时。基本上仅仅将之用于调试，以便对复杂系统线程调用的改进。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/24/BNF&EBNF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/24/BNF&EBNF/" class="post-title-link" itemprop="url">BNF&EBNF</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-01-24 08:00:00 / Modified: 11:50:43" itemprop="dateCreated datePublished" datetime="2021-01-24T08:00:00+08:00">2021-01-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="BNF"><a href="#BNF" class="headerlink" title="BNF"></a>BNF</h2><p>巴科斯范式(BNF: Backus-Naur Form 的缩写)是由 John Backus 和 Peter Naur 首先引入的用来描述计算机语言语法的符号集。现在，几乎每一位新编程语言书籍的作者都使用巴科斯范式来定义编程语言的语法规则。</p>
<p>在 BNF 中，双引号中的字(“word”)代表着这些字符本身。而 double_quote 用来代表双引号。</p>
<p>在双引号外的字（有可能有下划线）代表着语法部分。</p>
<p>&lt; &gt; : 内包含的为必选项。<br>　　[ ] : 内包含的为可选项。<br>　　{ } : 内包含的为可重复 0 至无数次的项。<br>　　| : 表示在其左右两边任选一项，相当于”OR”的意思。<br>　　::= : 是“被定义为”的意思<br>　　“…” : 术语符号<br>　　[…] : 选项，最多出现一次<br>　　{…} : 重复项，任意次数，包括 0 次<br>　　(…) : 分组<br>　　| : 并列选项，只能选一个<br>　　斜体字: 参数，在其它地方有解释</p>
<p>下面是是用 BNF 来定义的 Java 语言中的 For 语句的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FOR_STATEMENT ::&#x3D;</span><br><span class="line">      &quot;for&quot; &quot;(&quot; ( variable_declaration |</span><br><span class="line">  ( expression &quot;;&quot; ) | &quot;;&quot; )</span><br><span class="line">      [ expression ] &quot;;&quot;</span><br><span class="line">      [ expression ] &quot;;&quot;</span><br><span class="line">      &quot;)&quot; statement</span><br></pre></td></tr></table></figure>

<h2 id="EBNF"><a href="#EBNF" class="headerlink" title="EBNF"></a>EBNF</h2><p>扩展巴科斯-瑙尔范式(Extended Backus–Naur Form,EBNF)是一种用于描述计算机编程语言等正式语言的与上下文无关语法的元语法(metasyntax)符号表示法。简而言之，它是一种描述语言的语言。它是基本巴科斯范式(BNF)元语法符号表示法的一种扩展。</p>
<p>最初由尼克劳斯·维尔特开发，最常用的 EBNF 变体由标准是 ISO-14977 所定义。</p>
<p>EBNF 的基本语法形式如下，这个形式也被叫做 production：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">左式(LeftHandSide) &#x3D; 右式(RightHandSide).</span><br></pre></td></tr></table></figure>

<p>左式也被叫做 非终端符号(non-terminal symbol)，而右式则描述了其的组成。</p>
<h4 id="终端符号与非终端符号"><a href="#终端符号与非终端符号" class="headerlink" title="终端符号与非终端符号"></a>终端符号与非终端符号</h4><ul>
<li>终端符号(Terminal symbols)：形成所描述的语言的最基本符号。所描述语言的标点符号(不是 EBNF 自己的)会被左右加引号(它们也是终端符号)，而其他终端符号会用粗体(这边因不方便加粗，就不加粗了)打印。</li>
<li>非终端符号：是用于描述语法的变量，它必须被定义在一个 production 中。或说，它们必须出现在某个地方的 production 的左式中。</li>
</ul>
<h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><p><img src="/images/ss/bnf1.png"></p>
<h4 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h4><p>1 .使用了如下约定:</p>
<ul>
<li>EBNF 的每个元标识符(meta-identifier)都被写为用连字符(“-“,hyphens)连接起来的一个或多个单词；</li>
<li>以 “-symbol” 结束的元标识符是 EBNF 的终端符号。</li>
</ul>
<p>2 .用普通字符表示的 EBNF 操作符按照优先级(顶部为最高优先级)排序为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*repetition-symbol(重复符)</span><br><span class="line">-except-symbol(除去符)</span><br><span class="line">, concatenate-symbol(连接符)</span><br><span class="line">| definition-separator-symbol</span><br><span class="line">&#x3D; defining-symbol(定义符)</span><br><span class="line">; terminator-symbol(结束符)</span><br><span class="line">. terminator-symbol(结束符)</span><br></pre></td></tr></table></figure>

<p>3 .以下的括号对(bracket pairs)能够改变优先级，括号对间也有优先级(顶部为最高优先级):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#39;  first-quote-symbol            first-quote-symbol  &#39;    (* 引用 *)</span><br><span class="line">&quot;  second-quote-symbol          second-quote-symbol  &quot;    (* 引用 *)</span><br><span class="line">(* start-comment-symbol          end-comment-symbol *)    (* 注释 *)</span><br><span class="line">(  start-group-symbol              end-group-symbol  )    (* 分组 *)</span><br><span class="line">[  start-option-symbol            end-option-symbol  ]    (* 可选 *)</span><br><span class="line">&#123;  start-repeat-symbol            end-repeat-symbol  &#125;    (* 重复 *)</span><br><span class="line">?  special-sequence-symbol   special-sequence-symbol ?    (* 特殊序列 *)</span><br></pre></td></tr></table></figure>

<p>下例示范了怎么表达重复：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aa &#x3D; &quot;A&quot;;</span><br><span class="line">bb &#x3D; 3 * aa, &quot;B&quot;;</span><br><span class="line">cc &#x3D; 3 * [aa], &quot;C&quot;;</span><br><span class="line">dd &#x3D; &#123;aa&#125;, &quot;D&quot;;</span><br><span class="line">ee &#x3D; aa, &#123;aa&#125;, &quot;E&quot;;</span><br><span class="line">ff &#x3D; 3 * aa, 3 * [aa], &quot;F&quot;;</span><br><span class="line">gg &#x3D; &#123;3 * aa&#125;, &quot;D&quot;;</span><br></pre></td></tr></table></figure>

<p>这些规则定义的终端字符串如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aa: A</span><br><span class="line">bb: AAAB</span><br><span class="line">cc: C AC AAC AAAC</span><br><span class="line">dd: D AD AAD AAAD AAAAD etc.</span><br><span class="line">ee: AE AAE AAAE AAAAE AAAAAE etc.</span><br><span class="line">ff: AAAF AAAAF AAAAAF AAAAAAF</span><br><span class="line">gg: D AAAD AAAAAAD etc.</span><br></pre></td></tr></table></figure>

<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>除了标准的定义，在 FREESCALE 文档中还使用了以下约定：</p>
<ul>
<li>计数重复：任何由”{“和”}”括起来并后跟一个上标 x 的东西必须准确地重复出现 x 次。x 也可能是一个非终端字符。比如下例中，Stars 相当于四个星号：<br>Stars = {“*”}4.</li>
<li>字节数：见到任何紧跟着由一对中括号“[”和“]”括起来的数字 n 的标识符，都应该认为它是一个高位字节在前的二进制数，并且字节数为 n，如：<br>Struct=RefNo FilePos[4].</li>
<li>在一些例子中，我们会使用”&lt;”和”&gt;”括起来一些文本。这些文本是 元文本(meta–literal)，它们的位置应该被它们所描述的东西替代掉，如，对于 &lt; any char &gt;，它的位置可以插入任意字符。</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>以下提供一些示例以直观的理解 EBNF。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">digit excluding zero &#x3D; &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot; ;</span><br><span class="line">digit                &#x3D; &quot;0&quot; | digit excluding zero ;</span><br><span class="line">natural number &#x3D; digit excluding zero, &#123; digit &#125; ;</span><br><span class="line">integer &#x3D; &quot;0&quot; | [ &quot;-&quot; ], natural number ;</span><br></pre></td></tr></table></figure>

<p>digit excluding zero 可以是 1 到 9 任意一个字符，digit 则扩展为 0 到 9 任意一个字符。<br>natural number 可以是 1、2、…、10、…、12345、…，因为{}代表重复任意次，包括 0 次。<br>integer 则可以是 0 或者可能带个负号的自然数。</p>
<p>这是用 EBNF 描述的 EBNF 自身语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Production     &#x3D; NonTerminal &quot;&#x3D;&quot; Expression &quot;.&quot;.</span><br><span class="line">Expression     &#x3D; Term &#123;&quot;|&quot; Term&#125;.</span><br><span class="line">Term           &#x3D; Factor &#123;Factor&#125;.</span><br><span class="line">Factor         &#x3D; NonTerminal</span><br><span class="line">                 | Terminal</span><br><span class="line">                 | &quot;(&quot; Expression &quot;)&quot;</span><br><span class="line">                 | &quot;[&quot; Expression &quot;]&quot;</span><br><span class="line">                 | &quot;&#123;&quot; Expression &quot;&#125;&quot;.</span><br><span class="line">Terminal       &#x3D; Identifier | “&quot;“ &lt;any char&gt; “&quot;“.</span><br><span class="line">NonTerminal    &#x3D; Identifier.</span><br></pre></td></tr></table></figure>

<p>非终端符号可以是任意你喜欢的名字，而终端符号则要不然是出现在被描述的语言中的标识符，要不然就是任何被引号括起来的字符序列。<br>然后 Factor(参数)可以是终端字符、非终端字符、三种括号中任意一种括起来的表达式。<br>Term(术语)由起码一个 Factor 组合而成……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(* a simple program syntax in EBNF − Wikipedia *)</span><br><span class="line">program &#x3D; &#39;PROGRAM&#39;, white space, identifier, white space,</span><br><span class="line">           &#39;BEGIN&#39;, white space,</span><br><span class="line">           &#123; assignment, &quot;;&quot;, white space &#125;,</span><br><span class="line">           &#39;END.&#39; ;</span><br><span class="line">identifier &#x3D; alphabetic character, &#123; alphabetic character | digit &#125; ;</span><br><span class="line">number &#x3D; [ &quot;-&quot; ], digit, &#123; digit &#125; ;</span><br><span class="line">string &#x3D; &#39;&quot;&#39; , &#123; all characters - &#39;&quot;&#39; &#125;, &#39;&quot;&#39; ;</span><br><span class="line">assignment &#x3D; identifier , &quot;:&#x3D;&quot; , ( number | identifier | string ) ;</span><br><span class="line">alphabetic character &#x3D; &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; | &quot;G&quot;</span><br><span class="line">                     | &quot;H&quot; | &quot;I&quot; | &quot;J&quot; | &quot;K&quot; | &quot;L&quot; | &quot;M&quot; | &quot;N&quot;</span><br><span class="line">                     | &quot;O&quot; | &quot;P&quot; | &quot;Q&quot; | &quot;R&quot; | &quot;S&quot; | &quot;T&quot; | &quot;U&quot;</span><br><span class="line">                     | &quot;V&quot; | &quot;W&quot; | &quot;X&quot; | &quot;Y&quot; | &quot;Z&quot; ;</span><br><span class="line">digit &#x3D; &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot; ;</span><br><span class="line">white space &#x3D; ? white space characters ? ;</span><br><span class="line">all characters &#x3D; ? all visible characters ? ;</span><br></pre></td></tr></table></figure>

<p>对应的语法正确的程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PROGRAM DEMO1</span><br><span class="line">BEGIN</span><br><span class="line">  A:&#x3D;3;</span><br><span class="line">  B:&#x3D;45;</span><br><span class="line">  H:&#x3D;-100023;</span><br><span class="line">  C:&#x3D;A;</span><br><span class="line">  D123:&#x3D;B34A;</span><br><span class="line">  BABOON:&#x3D;GIRAFFE;</span><br><span class="line">  TEXT:&#x3D;&quot;Hello world!&quot;;</span><br><span class="line">END.</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/22/K8S/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/22/K8S/" class="post-title-link" itemprop="url">K8S</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-01-22 09:53:37 / Modified: 13:59:50" itemprop="dateCreated datePublished" datetime="2021-01-22T09:53:37+08:00">2021-01-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li>查看 pod：kubectl get pod -n <namespace> kubectl describe pod <pod> -n <namespace></namespace></pod></namespace></li>
<li>查看 pod 运行在哪个 node 节点：kubectl get pod -o wide -n <namespace></namespace></li>
<li>查看 pod 有哪些 label：kubectl get pod –show-labels -n <namespace></namespace></li>
<li>查看 node 有哪些 label：kubectl get nodes –show-labels</li>
<li>查看 service：kubectl get svc -n <namespace></namespace></li>
<li>进入容器的交互式 shell：kubectl exec <pod> -it - /bin/bash -n <namespace></namespace></pod></li>
<li>查看日志：kubectl logs <pod> -n <namespace></namespace></pod></li>
<li>查看后十行日志：kubectl logs <pod> –tail=10</pod></li>
<li>查看上次启动的日志：kubectl logs <pod> -p</pod></li>
<li>修改 image 版本：kubectl set image deployment nginx(deploy name) nginx(container name)=nginx:1.9.1</li>
<li>修改副本数：kubectl scale –replicas=3 deployment mysql</li>
<li>拷贝文件：kubectl cp mysql-478535978-1dnm2:/tmp/message.log message.log</li>
<li>查看 yaml 文件：cd /etc/kubernetes/apps/</li>
<li>应用 yaml 文件：kubectl apply -f xxx.yml</li>
</ul>
<h2 id="关键命令"><a href="#关键命令" class="headerlink" title="关键命令"></a>关键命令</h2><ul>
<li>驱逐 node 上所有 pod：kubectl taint node <node_name> key1=value1:NoExecute</node_name></li>
<li>驱逐 node 上 pod，不驱逐 ds：kubectl drain <node_name> –delete-local-data –force –ignore-daemonsets</node_name></li>
<li>恢复调度：kubectl uncordon <node_name></node_name></li>
<li>强制删除 namespace：kubectl delete namespace NAMESPACENAME –force –grace-period=0</li>
<li>命令行方式重启 Deployment：kubectl patch deployment my-app –patch ‘{“spec”: {“template”: {“metadata”: {“annotations”: {“version/config”: “20180411” }}}}}’</li>
<li>查看某个资源的字段意义：kubectl explain deployment.spec.template.spec.dnsPolicy</li>
<li>查看资源类型及版本：kubectl api-resources kubectl api-versions</li>
<li>创建一个测试的 deployment：kubectl run curl -it –image=pstauffer/curl 或 kubectl run curl -it –image=registry.sensetime.com/viper-test/curl</li>
<li>创建一个 nginx 的 deployment 并暴露服务：kubectl run nginx –image=nginx –expose –port=80</li>
<li>清理 docker 镜像：docker system prune -f 命令可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络，以及 dangling 镜像(即无 tag 的镜像)；docker system prune -af 命令清理得更加彻底，可以将没有容器使用 Docker 镜像都删掉。注意，这两个命令会把你暂时关闭的容器，以及暂时没有用到的 Docker 镜像都删掉。</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="deployment-yml"><a href="#deployment-yml" class="headerlink" title="deployment.yml"></a>deployment.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="service-yml"><a href="#service-yml" class="headerlink" title="service.yml"></a>service.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ingress-yml"><a href="#ingress-yml" class="headerlink" title="ingress.yml"></a>ingress.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="serviceMonitor-yml"><a href="#serviceMonitor-yml" class="headerlink" title="serviceMonitor.yml"></a>serviceMonitor.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/18/JDBC%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/18/JDBC%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">JDBC相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-18 10:00:00" itemprop="dateCreated datePublished" datetime="2021-01-18T10:00:00+08:00">2021-01-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-01-20 14:22:25" itemprop="dateModified" datetime="2021-01-20T14:22:25+08:00">2021-01-20</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="jdk8-源码解析之-sql-包：JDBC-源码解析"><a href="#jdk8-源码解析之-sql-包：JDBC-源码解析" class="headerlink" title="jdk8 源码解析之 sql 包：JDBC 源码解析"></a>jdk8 源码解析之 sql 包：JDBC 源码解析</h1><p>参考连接:<a target="_blank" rel="noopener" href="https://blog.csdn.net/mxy88888/article/details/94315198">https://blog.csdn.net/mxy88888/article/details/94315198</a></p>
<p>在开发项目时我们经常会需要与数据库进行交互，为了统一标准，在 java jdk 中提供了一组与数据库交互的 api（java.sql.*），每个厂商通过继承实现 sql 包下的接口和类完成与数据库交互的工作(例如 mysql-connector-java)。以 mysql 为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] arg) throws Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">    Connection connection&#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&quot;,&quot;root&quot;,&quot;123456&quot;);</span><br><span class="line">    PreparedStatement prepareStatement&#x3D;connection.prepareStatement(&quot;select * from student&quot;);</span><br><span class="line">    ResultSet resultSet&#x3D;prepareStatement.executeQuery();</span><br><span class="line">    while(resultSet.next())&#123;</span><br><span class="line">      System.out.println(resultSet.getString(&quot;id&quot;)+&quot;:&quot;+resultSet.getString(&quot;studname&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/jdbc2.png"></p>
<p>JDBC (Java Database Connectivity) API，即 Java 数据库编程接口，是一组标准的 Java 语言中的接口和类，使用这些接口和类，Java 客户端程序可以访问各种不同类型的数据库。比如建立数据库连接、执行 SQL 语句进行数据的存取操作。</p>
<p>JDBC 规范采用接口和实现分离的思想设计了 Java 数据库编程的框架。接口包含在 java.sql 及 javax.sql 包中，其中 java.sql 属于 JavaSE，javax.sql 属于 JavaEE。这些接口的实现类叫做数据库驱动程序，由数据库的厂商或其它的厂商或个人提供。</p>
<p>为了使客户端程序独立于特定的数据库驱动程序，JDBC 规范建议开发者使用基于接口的编程方式，即尽量使应用仅依赖 java.sql 及 javax.sql 中的接口和类。<br><img src="/images/jdbc1.png"></p>
<p>JDBC 驱动程序是各个数据库厂家根据 JDBC 的规范制作的 JDBC 实现类.</p>
<p>主要涉及到的类有：</p>
<ul>
<li>connection:接口类，mysql 封装了连接数据库的参数，辅助类，提供了 sql 语句执行，创建 statement 对象，提交，回滚等功能。</li>
<li>preparedStatement:接口类，保存 sql 执行语句，并提供查询，修改等方法。</li>
<li>Driver:驱动类，子类提供了返回 connection 对象方法的实现，以及一些辅助方法</li>
<li>DriverManager：驱动管理类，注册 Driver 对象<br>下面我们来一步步解析查询数据库的过程:</li>
</ul>
<ol>
<li><p>驱动类加载</p>
<p><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code><br>当我们看到这行代码时我们可能会有些疑惑：为什么开始要加载初始化这个驱动？那我们先看看它里面有什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Driver 类</span><br><span class="line">static &#123;</span><br><span class="line">try &#123;</span><br><span class="line">    java.sql.DriverManager.registerDriver(new Driver()); &#x2F;&#x2F;注册驱动</span><br><span class="line">&#125; catch (SQLException E) &#123;</span><br><span class="line">    throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;DriverManager 类</span><br><span class="line">private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers &#x3D; new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">public static synchronized void registerDriver(java.sql.Driver driver,</span><br><span class="line">        DriverAction da)</span><br><span class="line">    throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Register the driver if it has not already been added to our list *&#x2F;</span><br><span class="line">    if(driver !&#x3D; null) &#123;</span><br><span class="line">        registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); &#x2F;&#x2F;封装注册类并村主导</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; This is for compatibility with the original DriverManager</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(&quot;registerDriver: &quot; + driver);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到这里我们知道初始化类是为了调用 DriverManager.registerDriver 方法对 Driver 进行注册。在注册方法中将获取到的 Driver 对象封装了一遍存入 registeredDrivers 集合里，这里 registeredDrivers 是 DirverManager 里的一个 list 集合对象，CopyOnWriteArrayList 是一个线程安全 list 集合类。所以 jdbc 可以允许我们在同一项目中加载不同的驱动类去连接多个的数据库。</p>
<p>Driver 类加载完成之后接下来是<br><code>Connection connection= DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;,&quot;root&quot;,&quot;123456&quot;);</code><br>这一段是返回 connection 对象的操作，我们看一下 DriverManager 内源码，其中有一段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    loadInitialDrivers();  &#x2F;加载初始化其他驱动类</span><br><span class="line">    println(&quot;JDBC DriverManager initialized&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void loadInitialDrivers() &#123;</span><br><span class="line">    String drivers;</span><br><span class="line">    try &#123;</span><br><span class="line">        drivers &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() &#123;  &#x2F;&#x2F;跳过权限验证从系统变量中获取驱动</span><br><span class="line">            public String run() &#123;</span><br><span class="line">                return System.getProperty(&quot;jdbc.drivers&quot;); &#x2F;&#x2F;获取jdbc.drivers变量</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">        drivers &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; If the driver is packaged as a Service Provider, load it.</span><br><span class="line">    &#x2F;&#x2F; Get all the drivers through the classloader</span><br><span class="line">    &#x2F;&#x2F; exposed as a java.sql.Driver.class service.</span><br><span class="line">    &#x2F;&#x2F; ServiceLoader.load() replaces the sun.misc.Providers()</span><br><span class="line"></span><br><span class="line">    AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        public Void run() &#123;</span><br><span class="line"></span><br><span class="line">            ServiceLoader&lt;Driver&gt; loadedDrivers &#x3D; ServiceLoader.load(Driver.class);&#x2F;&#x2F;通过ServiceLoader动态加载驱动类</span><br><span class="line">            Iterator&lt;Driver&gt; driversIterator &#x3D; loadedDrivers.iterator();</span><br><span class="line"></span><br><span class="line">            &#x2F;* Load these drivers, so that they can be instantiated.</span><br><span class="line">            * It may be the case that the driver class may not be there</span><br><span class="line">            * i.e. there may be a packaged driver with the service class</span><br><span class="line">            * as implementation of java.sql.Driver but the actual class</span><br><span class="line">            * may be missing. In that case a java.util.ServiceConfigurationError</span><br><span class="line">            * will be thrown at runtime by the VM trying to locate</span><br><span class="line">            * and load the service.</span><br><span class="line">            *</span><br><span class="line">            * Adding a try catch block to catch those runtime errors</span><br><span class="line">            * if driver not available in classpath but it&#39;s</span><br><span class="line">            * packaged as service and that service is there in classpath.</span><br><span class="line">            *&#x2F;</span><br><span class="line">            try&#123;</span><br><span class="line">                while(driversIterator.hasNext()) &#123;</span><br><span class="line">                    driversIterator.next(); &#x2F;&#x2F;遍历并初始化对象</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch(Throwable t) &#123;</span><br><span class="line">            &#x2F;&#x2F; Do nothing</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    println(&quot;DriverManager.initialize: jdbc.drivers &#x3D; &quot; + drivers);</span><br><span class="line"></span><br><span class="line">    if (drivers &#x3D;&#x3D; null || drivers.equals(&quot;&quot;)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] driversList &#x3D; drivers.split(&quot;:&quot;); &#x2F;&#x2F;从系统变量中获取的完全限定名</span><br><span class="line">    println(&quot;number of Drivers:&quot; + driversList.length);</span><br><span class="line">    for (String aDriver : driversList) &#123;  &#x2F;&#x2F;遍历驱动名并初始化</span><br><span class="line">        try &#123;</span><br><span class="line">            println(&quot;DriverManager.Initialize: loading &quot; + aDriver);</span><br><span class="line">            Class.forName(aDriver, true,</span><br><span class="line">                    ClassLoader.getSystemClassLoader());</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            println(&quot;DriverManager.Initialize: load failed: &quot; + ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 DriverMnager 中有一段静态代码块，我们第一次调用时会执行里面的 loadInitialDrivers 方法完成第二次驱动的加载，这里加载驱动的方式有两种。一种是通过获取系统的环境变量 jdbc.drivers 得到驱动类的完全限定名并通过反射进行初始化注册，另一个是通过 serviceLoader（参考 Java 的 SPI）动态获取驱动类对象完成注册，两种方式都在 AccessController.doPrivileged 内执行，是为了跳过<code>虚拟机权限验证</code>。</p>
</li>
<li><p>返回 connection 对象<br>再次定位到这行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection connection&#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&quot;,&quot;root&quot;,&quot;123456&quot;);</span><br></pre></td></tr></table></figure>

<p>查看 getConnection 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">@CallerSensitive</span><br><span class="line">public static Connection getConnection(String url,</span><br><span class="line">    String user, String password) throws SQLException &#123;</span><br><span class="line">    java.util.Properties info &#x3D; new java.util.Properties();</span><br><span class="line"></span><br><span class="line">    if (user !&#x3D; null) &#123;</span><br><span class="line">        info.put(&quot;user&quot;, user);</span><br><span class="line">    &#125;</span><br><span class="line">    if (password !&#x3D; null) &#123;</span><br><span class="line">        info.put(&quot;password&quot;, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Connection getConnection(</span><br><span class="line">    String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    * When callerCl is null, we should check the application&#39;s</span><br><span class="line">    * (which is invoking this class indirectly)</span><br><span class="line">    * classloader, so that the JDBC driver class outside rt.jar</span><br><span class="line">    * can be loaded from here.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    ClassLoader callerCL &#x3D; caller !&#x3D; null ? caller.getClassLoader() : null; &#x2F;&#x2F;获取当前线程的类加载器</span><br><span class="line">    synchronized(DriverManager.class) &#123;</span><br><span class="line">        &#x2F;&#x2F; synchronize loading of the correct classloader.</span><br><span class="line">        if (callerCL &#x3D;&#x3D; null) &#123;</span><br><span class="line">            callerCL &#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(url &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new SQLException(&quot;The url cannot be null&quot;, &quot;08001&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(&quot;DriverManager.getConnection(\&quot;&quot; + url + &quot;\&quot;)&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Walk through the loaded registeredDrivers attempting to make a connection.</span><br><span class="line">    &#x2F;&#x2F; Remember the first exception that gets raised so we can reraise it.</span><br><span class="line">    SQLException reason &#x3D; null;</span><br><span class="line"></span><br><span class="line">    for(DriverInfo aDriver : registeredDrivers) &#123;  &#x2F;&#x2F;遍历注册信息</span><br><span class="line">        &#x2F;&#x2F; If the caller does not have permission to load the driver then</span><br><span class="line">        &#x2F;&#x2F; skip it.</span><br><span class="line">        if(isDriverAllowed(aDriver.driver, callerCL)) &#123;  &#x2F;&#x2F;判断该驱动是否是callerCL加载器加载的</span><br><span class="line">            try &#123;</span><br><span class="line">                println(&quot;    trying &quot; + aDriver.driver.getClass().getName());</span><br><span class="line">                Connection con &#x3D; aDriver.driver.connect(url, info);  &#x2F;&#x2F;通过驱动器返回connection对象</span><br><span class="line">                if (con !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Success!</span><br><span class="line">                    println(&quot;getConnection returning &quot; + aDriver.driver.getClass().getName());</span><br><span class="line">                    return (con);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException ex) &#123;</span><br><span class="line">                if (reason &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    reason &#x3D; ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println(&quot;    skipping: &quot; + aDriver.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; if we got here nobody could connect.</span><br><span class="line">    if (reason !&#x3D; null)    &#123;</span><br><span class="line">        println(&quot;getConnection failed: &quot; + reason);</span><br><span class="line">        throw reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(&quot;getConnection: no suitable driver found for &quot;+ url);</span><br><span class="line">    throw new SQLException(&quot;No suitable driver found for &quot;+ url, &quot;08001&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上通过备注我们知道，这个是一个获取 connection 对象的过程，先是遍历 registerDrivers 集合获取每个驱动器，然后进行验证，成功后返回该驱动器。到这里 jdbc 的源码解析就结束了，因为 sql 包中很多都是接口需要子类进行实现，所以接下来要说的都是 mysql 继承接口中的实现，我也不细说大概点一下。</p>
</li>
<li><p>获取 PreparedStatement 对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement prepareStatement&#x3D;connection.prepareStatement(&quot;select * from student&quot;);</span><br></pre></td></tr></table></figure>

<p>这里我们通过 connection 得到了 preparedstatement，preparedstatement 继承自 statement，里面保存了 sql 语句对象，并提供了查询 sql 的方法。</p>
</li>
<li><p>获取 ResultSet 对象<br><code>ResultSet resultSet=prepareStatement.executeQuery();</code></p>
<p>在这里 statement 对象调用了 executeQuery 方法，里面将会执行发送 sql 以及获取数据的操作，在 mysql 中是通过 Socket 对象进行操作的。方法返回 ResultSet，存储了查询的结果。获取 resultSet 对象后通过 next 方法移动游标定位信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(resultSet.next())&#123;</span><br><span class="line">System.out.println(resultSet.getString(&quot;id&quot;)+&quot;:&quot;+resultSet.getString(&quot;studname&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上就是 jdbc 源码的讲解。</p>
</li>
</ol>
<h1 id="java-sql-里面有什么？"><a href="#java-sql-里面有什么？" class="headerlink" title="java.sql 里面有什么？"></a>java.sql 里面有什么？</h1><p>java.sql 包中包含用于以下方面的 API：</p>
<ul>
<li>通过 DriverManager 实用程序建立与数据库的连接 bai</li>
<li>DriverManager 类：建立与驱动程序的连接</li>
<li>SQLPermission 类：代码在 Security Manager（比如 applet）中运行时提供权限，试图通过 DriverManager 设置一个记录流</li>
<li>Driver 接口：提供用来注册和连接基于 JDBC 技术（“JDBC 驱动程序”）的驱动程序的 API，通常仅由 DriverManager 类使用</li>
<li>DriverPropertyInfo 类：提供 JDBC 驱动程序的属性，不是供一般用户使用的向数据库发送 SQL 语句</li>
<li>Statement：用于发送基本 SQL 语句</li>
<li>PreparedStatement：用于发送准备好的语句或基本 SQL 语句（派生自 Statement）</li>
<li>CallableStatement：用于调用数据库存储过程（派生自 PreparedStatement）</li>
<li>Connection 接口：提供创建语句以及管理连接及其属性的方法</li>
<li>Savepoint：在事务中提供保存点</li>
<li>获取和更新查询的结果</li>
<li>ResultSet 接口</li>
<li>SQL 类型到 Java 编程语言中的类和接口的标准映射关系<ul>
<li>Array 接口：SQL ARRAY 的映射关系</li>
<li>Blob 接口：SQL BLOB 的映射关系</li>
<li>Clob 接口：SQL CLOB 的映射关系</li>
<li>Date 类：SQL DATE 的映射关系</li>
<li>…..</li>
</ul>
</li>
<li>元数据<ul>
<li>DatabaseMetaData 接口：提供有关数据库的信息</li>
<li>ResultSetMetaData 接口：提供有关 ResultSet 对象的列的信息</li>
<li>ParameterMetaData 接口：提供有关 PreparedStatement 命令的参数的信息</li>
</ul>
</li>
<li>异常<ul>
<li>SQLException：由大多数方法在访问数据出问题时抛出，以及因为其他原因由其他一些方法抛出</li>
<li>SQLWarning：为了指示一个警告而抛出</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/17/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/17/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD/" class="post-title-link" itemprop="url">Web服务器高并发和高性能</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-01-17 21:00:00 / Modified: 11:15:40" itemprop="dateCreated datePublished" datetime="2021-01-17T21:00:00+08:00">2021-01-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>从根上理解高性能、高并发<br>链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/imstudy/p/14179129.html">https://www.cnblogs.com/imstudy/p/14179129.html</a></p>
<p>高性能网络编程<br>链接： <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/214330310">https://zhuanlan.zhihu.com/p/214330310</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
