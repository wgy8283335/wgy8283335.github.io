<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'default'
  };
</script>
<title>Hexo</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/29/tmux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/29/tmux/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-11-29 16:59:30 / Modified: 17:01:20" itemprop="dateCreated datePublished" datetime="2020-11-29T16:59:30+08:00">2020-11-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>tmux 是 Linux 中窗口管理程序，适用于终端复用，尤其适合远程连接。最近，我正苦闷与 ssh 自动超时退出和 broken pipe，决定投入 tmux 怀抱。<br>使用 tmux 最直接的好处，便是可以在一个远程连接中开启多个控制台，而不用浪费额外的终端来连接远程主机。更不用说 tmux 方便的 attach/detach,随时保存工作状态，还有方便的复制粘贴功能。</p>
<p>基本使用<br>tmux 的主要元素分为三层：</p>
<p>Session: 一组窗口的集合，通常用来概括同一个任务。session 可以有自己的名字便于任务之间的切换。<br>Window: 单个可见窗口。Windows 有自己的编号，也可以认为和 ITerm2 中的 Tab 类似。<br>Pane: 窗格，被划分成小块的窗口，类似于 Vim 中 C-w +v 后的效果。</p>
<p>在安装好 tmux 后，直接在终端中输入 tmux 并回车，就进入了一个全新的 tmux 会话，输入 exit 即可退出。<br>可以在一台计算机上创建多个会话，并且通过为每个会话指定一个唯一的名称来管理它们：<br>tmux new-session -s basic<br>此命令可简化为：tmux new -s basic。<br>由于我们的程序是在 tmux 环境里运行的，因此需要一种方式来告诉 tmux 当前所输入的命令是为了让 tmux 去执行而不是 tmux 里的应用程序去执行，这就是命令前缀的作用。tmux 中默认的命令前缀是 CTRL-b 组合键，但 CTRL-b 组合键使用不是很方便，可将其修改为 CTRL-a 组合键。按下命令前缀组合键，松开，再按相应键，即发送 tmux 命令。</p>
<p>tmux 创建会话</p>
<ul>
<li>tmux new-session 创建一个未命名的会话。可以简写为 tmux new 或者就一个简单的 tmux</li>
<li>tmux new -s development 创建一个名为 development 的会话</li>
<li>tmux new -s development -n editor 创建一个名为 development 的会话并把该会话的第一个窗口命名为 editor</li>
<li>tmux attach -t development 连接到一个名为 development 的会话</li>
</ul>
<p>tmux 会话、窗口和面板的默认快捷键</p>
<ul>
<li>PREFIX d 从一个会话中分离，让该会话在后台运行。</li>
<li>PREFIX : 进入命令模式</li>
<li>PREFIX c 在当前 tmux 会话创建一个新的窗口，是 new-window 命令的简写</li>
<li>PREFIX 0…9 根据窗口的编号选择窗口</li>
<li>PREFIX w 显示当前会话中所有窗口的可选择列表</li>
<li>PREFIX , 显示一个提示符来重命名一个窗口</li>
<li>PREFIX &amp; 杀死当前窗口，带有确认提示</li>
<li>PREFIX % 把当前窗口垂直地一分为二，分割后的两个面板各占 50% 大小</li>
<li>PREFIX “ 把当前窗口水平地一分为二，分割后的两个面板各占 50% 大小</li>
<li>PREFIX o 在已打开的面板之间循环移动当前焦点</li>
<li>PREFIX q 短暂地显示每个面板的编号</li>
<li>PREFIX x 关闭当前面板，带有确认提示</li>
<li>PREFIX SPACE 循环地使用 tmux 的几个默认面板布局</li>
</ul>
<p>tmux 复制粘贴</p>
<ul>
<li>PREFIX [ 进入复制模式</li>
<li>PREFIX ] 粘贴<br>进入复制模式后，可以用 vi 风格的快捷键进行移动（按上文的设置）。按下 sapce 就可以选择文本。回车键进行复制。然后再通过]进行粘贴。<br>也可以将复制粘贴设置为类似 vi 的模式，使用 esc 进入复制模式，v 进入粘贴模式，选择后 y 进行复制。Prefix-p 进行粘贴。</li>
</ul>
<h1 id="Copy-and-paste-like-in-vim"><a href="#Copy-and-paste-like-in-vim" class="headerlink" title="Copy and paste like in vim"></a>Copy and paste like in vim</h1><p>unbind [<br>bind Escape copy-mode<br>unbind p<br>bind p paste-buffer<br>bind -t vi-copy ‘v’ begin-selection<br>bind -t vi-copy ‘y’ copy-selection</p>
<p>所有的复制都会被记录到缓冲区，输入#或者 tmux list-buffers 查看缓冲区,同时也进入了复制模式。也可以使用”=”来选择并粘贴缓冲区内容。tmux 的缓冲区和系统剪贴板是完全独立的。</p>
<p>自主配置</p>
<h1 id="把前缀键从-C-b-更改为-C-a"><a href="#把前缀键从-C-b-更改为-C-a" class="headerlink" title="把前缀键从 C-b 更改为 C-a"></a>把前缀键从 C-b 更改为 C-a</h1><p>set -g prefix C-a</p>
<h1 id="释放之前的-Ctrl-b-前缀快捷键"><a href="#释放之前的-Ctrl-b-前缀快捷键" class="headerlink" title="释放之前的 Ctrl-b 前缀快捷键"></a>释放之前的 Ctrl-b 前缀快捷键</h1><p>unbind C-b</p>
<h1 id="设定前缀键和命令键之间的延时"><a href="#设定前缀键和命令键之间的延时" class="headerlink" title="设定前缀键和命令键之间的延时"></a>设定前缀键和命令键之间的延时</h1><p>set -sg escape-time 1</p>
<h1 id="确保可以向其它程序发送-Ctrl-A"><a href="#确保可以向其它程序发送-Ctrl-A" class="headerlink" title="确保可以向其它程序发送 Ctrl-A"></a>确保可以向其它程序发送 Ctrl-A</h1><p>bind C-a send-prefix</p>
<h1 id="把窗口的初始索引值从-0-改为-1"><a href="#把窗口的初始索引值从-0-改为-1" class="headerlink" title="把窗口的初始索引值从 0 改为 1"></a>把窗口的初始索引值从 0 改为 1</h1><p>set -g base-index 1</p>
<h1 id="把面板的初始索引值从-0-改为-1"><a href="#把面板的初始索引值从-0-改为-1" class="headerlink" title="把面板的初始索引值从 0 改为 1"></a>把面板的初始索引值从 0 改为 1</h1><p>setw -g pane-base-index 1</p>
<h1 id="使用-Prefix-r-重新加载配置文件"><a href="#使用-Prefix-r-重新加载配置文件" class="headerlink" title="使用 Prefix r 重新加载配置文件"></a>使用 Prefix r 重新加载配置文件</h1><p>bind r source-file ~/.tmux.conf ; display “Reloaded!”</p>
<h1 id="分割面板"><a href="#分割面板" class="headerlink" title="分割面板"></a>分割面板</h1><p>bind | split-window -h<br>bind - split-window -v</p>
<h1 id="在面板之间移动"><a href="#在面板之间移动" class="headerlink" title="在面板之间移动"></a>在面板之间移动</h1><p>bind h select-pane -L<br>bind j select-pane -D<br>bind k select-pane -U<br>bind l select-pane -R</p>
<h1 id="快速选择面板"><a href="#快速选择面板" class="headerlink" title="快速选择面板"></a>快速选择面板</h1><p>bind -r C-h select-window -t :-<br>bind -r C-l select-window -t :+</p>
<h1 id="调整面板大小"><a href="#调整面板大小" class="headerlink" title="调整面板大小"></a>调整面板大小</h1><p>bind -r H resize-pane -L 5<br>bind -r J resize-pane -D 5<br>bind -r K resize-pane -U 5<br>bind -r L resize-pane -R 5</p>
<h1 id="鼠标支持-如果你想使用的话把-off-改为-on"><a href="#鼠标支持-如果你想使用的话把-off-改为-on" class="headerlink" title="鼠标支持 - 如果你想使用的话把 off 改为 on"></a>鼠标支持 - 如果你想使用的话把 off 改为 on</h1><p>setw -g mode-mouse off<br>set -g mouse-select-pane off<br>set -g mouse-resize-pane off<br>set -g mouse-select-window off</p>
<h1 id="设置默认的终端模式为-256-色模式"><a href="#设置默认的终端模式为-256-色模式" class="headerlink" title="设置默认的终端模式为 256 色模式"></a>设置默认的终端模式为 256 色模式</h1><p>set -g default-terminal “screen-256color”</p>
<h1 id="开启活动通知"><a href="#开启活动通知" class="headerlink" title="开启活动通知"></a>开启活动通知</h1><p>setw -g monitor-activity on<br>set -g visual-activity on</p>
<h1 id="设置状态栏的颜色"><a href="#设置状态栏的颜色" class="headerlink" title="设置状态栏的颜色"></a>设置状态栏的颜色</h1><p>set -g status-fg white<br>set -g status-bg black</p>
<h1 id="设置窗口列表的颜色"><a href="#设置窗口列表的颜色" class="headerlink" title="设置窗口列表的颜色"></a>设置窗口列表的颜色</h1><p>setw -g window-status-fg cyan<br>setw -g window-status-bg default<br>setw -g window-status-attr dim</p>
<h1 id="设置活动窗口的颜色"><a href="#设置活动窗口的颜色" class="headerlink" title="设置活动窗口的颜色"></a>设置活动窗口的颜色</h1><p>setw -g window-status-current-fg white<br>setw -g window-status-current-bg red<br>setw -g window-status-current-attr bright</p>
<h1 id="设置面板和活动面板的颜色"><a href="#设置面板和活动面板的颜色" class="headerlink" title="设置面板和活动面板的颜色"></a>设置面板和活动面板的颜色</h1><p>set -g pane-border-fg green<br>set -g pane-border-bg black<br>set -g pane-active-border-fg white<br>set -g pane-active-border-bg yellow</p>
<h1 id="设置命令行或消息的颜色"><a href="#设置命令行或消息的颜色" class="headerlink" title="设置命令行或消息的颜色"></a>设置命令行或消息的颜色</h1><p>set -g message-fg white<br>set -g message-bg black<br>set -g message-attr bright</p>
<h1 id="设置状态栏左侧的内容和颜色"><a href="#设置状态栏左侧的内容和颜色" class="headerlink" title="设置状态栏左侧的内容和颜色"></a>设置状态栏左侧的内容和颜色</h1><p>set -g status-left-length 40<br>set -g status-left “#[fg=green]Session: #S #[fg=yellow]#I #[fg=cyan]#P”<br>set -g status-utf8 on</p>
<h1 id="设置状态栏右侧的内容和颜色"><a href="#设置状态栏右侧的内容和颜色" class="headerlink" title="设置状态栏右侧的内容和颜色"></a>设置状态栏右侧的内容和颜色</h1><h1 id="15-28-Nov-18-15"><a href="#15-28-Nov-18-15" class="headerlink" title="15% | 28 Nov 18:15"></a>15% | 28 Nov 18:15</h1><p>set -g status-right “#(~/battery Discharging) | #[fg=cyan]%d %b %R”</p>
<h1 id="每-60-秒更新一次状态栏"><a href="#每-60-秒更新一次状态栏" class="headerlink" title="每 60 秒更新一次状态栏"></a>每 60 秒更新一次状态栏</h1><p>set -g status-interval 60</p>
<h1 id="设置窗口列表居中显示"><a href="#设置窗口列表居中显示" class="headerlink" title="设置窗口列表居中显示"></a>设置窗口列表居中显示</h1><p>set -g status-justify centre</p>
<h1 id="开启-vi-按键"><a href="#开启-vi-按键" class="headerlink" title="开启 vi 按键"></a>开启 vi 按键</h1><p>setw -g mode-keys vi</p>
<h1 id="在相同目录下使用-tmux-panes-脚本开启面板"><a href="#在相同目录下使用-tmux-panes-脚本开启面板" class="headerlink" title="在相同目录下使用 tmux-panes 脚本开启面板"></a>在相同目录下使用 tmux-panes 脚本开启面板</h1><p>unbind v<br>unbind n<br>bind v send-keys “ ~/tmux-panes -h” C-m<br>bind n send-keys “ ~/tmux-panes -v” C-m</p>
<h1 id="临时最大化面板或恢复面板大小"><a href="#临时最大化面板或恢复面板大小" class="headerlink" title="临时最大化面板或恢复面板大小"></a>临时最大化面板或恢复面板大小</h1><p>unbind Up<br>bind Up new-window -d -n tmp ; swap-pane -s tmp.1 ; select-window -t tmp<br>unbind Down<br>bind Down last-window ; swap-pane -s tmp.1 ; kill-window -t tmp</p>
<h1 id="把日志输出到指定文件"><a href="#把日志输出到指定文件" class="headerlink" title="把日志输出到指定文件"></a>把日志输出到指定文件</h1><p>bind P pipe-pane -o “cat &gt;&gt;~/#W.log” ; display “Toggled logging to ~/#W.log”</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/29/ANTLR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/29/ANTLR/" class="post-title-link" itemprop="url">Antlr相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-29 16:07:30" itemprop="dateCreated datePublished" datetime="2020-11-29T16:07:30+08:00">2020-11-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-30 22:30:37" itemprop="dateModified" datetime="2020-11-30T22:30:37+08:00">2020-11-30</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="实例入门"><a href="#实例入门" class="headerlink" title="实例入门"></a>实例入门</h1><p>在安装完 antlr 之后，可以编写简单的 g4 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grammar Hello;</span><br><span class="line">r:&#39;hello&#39; ID ;</span><br><span class="line">ID:[a-z]+ ;</span><br><span class="line">WS:[\t\r\n]+ -&gt; skip;</span><br></pre></td></tr></table></figure>

<p>运行如下命令</p>
<ul>
<li><code>antlr Hello.g4</code></li>
<li><code>javac *.java</code></li>
<li><code>alias grun=‘java org.antlr.v4.runtime.misc.TestRig’</code> TestRig 是一个调试工具，使用 alias 给它起了一个别名。直接执行<code>grun</code>可以得到帮助信息。</li>
<li><code>grun Hello r -tokens</code></li>
<li><code>hello parrt</code></li>
<li><code>EOF</code></li>
</ul>
<p>得到如下结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[@0,0:4&#x3D;&#39;hello&#39;,&lt;&#39;hello&#39;&gt;,1:0]</span><br><span class="line">[@1,6:10&#x3D;&#39;parrt&#39;,&lt;ID&gt;,1:6]</span><br><span class="line">[@2,12:11&#x3D;&#39;&lt;EOF&gt;&#39;,&lt;EOF&gt;,2:0]</span><br></pre></td></tr></table></figure>

<p>解析结果：比如 parrt。@1 表明该词法符号在第 2 个位置，parrt 位于第 6 个到第 10 个位置之间，词法符号类型是 ID，位于输入文本的第 1 行，第 6 个位置处。</p>
<h1 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/29/Golang%E7%9A%84%E5%8C%85%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/29/Golang%E7%9A%84%E5%8C%85%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">Golang 的包管理机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-11-29 16:07:30 / Modified: 16:30:30" itemprop="dateCreated datePublished" datetime="2020-11-29T16:07:30+08:00">2020-11-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在 Go1.5 之前用 GOPATH 以及 GOROOT 这两个环境变量来管理包的位置，GOROOT 为 Go 的安装目录，以及编译过程中使用到的系统库存放位置，如 fmt。Go1.5 到 Go1.7 开始稳定到 Vendor 方式，即依赖包需要放到 $GOPATH/src/vendor 目录下，这样每个项目都有自己的 vendor 目录，但是如果依赖同样的三方包，很容易造成资源重复，Go vendor 出现了几种主流的管理工具，包括 godep、govendor、golide 等。</p>
<p>在 Go1.11 之前，GOPATH 是开发时的工作目录，其中包含三个子目录：</p>
<p>src 目录：存放 go 项目源码和依赖源码，包括使用 go get 下载的包<br>bin 目录：通过使用 go install 命令将 go build 编译出的二进制可执行文件存放于此<br>pkg 目录：go 源码包编译生成的 lib 文件存储的地方<br>在 Go1.11 之前，import 包时的搜索路径</p>
<p>GOROOT/src: 该目录保存了 Go 标准库代码(首先搜寻导入包的地方)<br>GOPATH/src: 该目录保存了应用自身的各个包代码和第三方依赖的代码<br>./vendor ：vendor 方式第三方依赖包（如果支持 Vendor）<br>在 Unix 和类 Unix 系统上，GOPATH 默认值是 $HOME/go，Go1.11 版本后，开启 GO Modules 后，GOPATH 的作用仅仅为存放依赖的目录了。</p>
<p>在 Go 的 1.11 版本之前，GOPATH 是必需的，且所有的 Go 项目代码都要保存在 GOPATH/src 目录下，也就是如果想引用本地的包，你需要将包放在 $GOPATH/src 目录下才能找得到。Go 的 1.11 版本之后，GO 官方引入了 Go Modules，不仅仅方便的使用我们的依赖，而且还对依赖的版本进行了管理。</p>
<p>在 Go1.11 后通过 go mod vendor 和 -mod=vendor 来实现 Vendor 管理依赖方式。本来在 vgo 项目(Go Modules 前身)是要完全放弃 vendor，但是在社区反馈下还是保留了。总之就是在 Go.1.11 之后需要开启 Go Modules 条件下才能使用 Vendor，具体地感兴趣或还沿用了 Vendor 的朋友可以去了解下，不过建议以后仅使用 Go Modules 包管理方式了。</p>
<h2 id="dep-govendor-机制"><a href="#dep-govendor-机制" class="headerlink" title="dep/govendor 机制"></a>dep/govendor 机制</h2><h4 id="vendor-使用限制"><a href="#vendor-使用限制" class="headerlink" title="vendor 使用限制"></a>vendor 使用限制</h4><p>使用 vendor 来管理包的项目，必须位于$GOPATH/src 下面。</p>
<h4 id="vendor-目录和-json-文件"><a href="#vendor-目录和-json-文件" class="headerlink" title="vendor 目录和 json 文件"></a>vendor 目录和 json 文件</h4><p>该工具将项目依赖的外部包拷贝到项目下的 vendor 目录下，并通过 vendor.json 文件来记录依赖包的版本，方便用户使用相对稳定的依赖。</p>
<h4 id="vendor-机制下，如何搜索包依赖"><a href="#vendor-机制下，如何搜索包依赖" class="headerlink" title="vendor 机制下，如何搜索包依赖"></a>vendor 机制下，如何搜索包依赖</h4><p>那么查找依赖包路径的解决方案如下：</p>
<ul>
<li>当前包下的 vendor 目录。</li>
<li>向上级目录查找，直到找到 src 下的 vendor 目录。</li>
<li>在 GOPATH 下面查找依赖包。</li>
<li>在 GOROOT 目录下查找</li>
</ul>
<h4 id="如果我们已经使用-GOPATH-去存储-packages-了，问什么还需要使用-vendor-目录呢？"><a href="#如果我们已经使用-GOPATH-去存储-packages-了，问什么还需要使用-vendor-目录呢？" class="headerlink" title="如果我们已经使用 GOPATH 去存储 packages 了，问什么还需要使用 vendor 目录呢？"></a>如果我们已经使用 GOPATH 去存储 packages 了，问什么还需要使用 vendor 目录呢？</h4><p>这是一个很实战的问题。假如多个应用使用一个依赖包的不同版本？这个问题不只是 Go 应用，其他语言也会有这个问题。<br>vendor 目录允许不同的代码库拥有它自己的依赖包，并且不同于其他代码库的版本，这就很好的做到了工程的隔离。<br>每个项目都有各自的 vendor，每个 vendor 可以存放不同版本的依赖包。</p>
<h2 id="module-机制"><a href="#module-机制" class="headerlink" title="module 机制"></a>module 机制</h2><p>在 go1.11 版本中，新增了 module 管理模块功能，用来管理依赖包。要知道，在这个之前，想要对 go 语言包进行管理，只能依赖第三方库实现，比如 Vendor,GoVendor,GoDep,Dep,Glide 等等，对于初学者来说，真的是选择困难症。</p>
<h4 id="开启-module-特性"><a href="#开启-module-特性" class="headerlink" title="开启 module 特性"></a>开启 module 特性</h4><p>要开始使用 go module 的特性， 需要先设置 GO111MODULE 环境变量。<br>开启 GO111MODULE。<br>要使用 go module,首先要设置 GO111MODULE=on,这没什么可说的，如果没设置，执行命令的时候会有提示，这个大家应该都了解了</p>
<h4 id="在-GOAPTH-src-中创建项目"><a href="#在-GOAPTH-src-中创建项目" class="headerlink" title="在$GOAPTH/src 中创建项目"></a>在$GOAPTH/src 中创建项目</h4><p>在$GOPATH/src 目录下创建 github.com/cnwyt/mytest 目录，mytest 为项目目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $GOPATH&#x2F;src&#x2F;github.com&#x2F;cnwyt&#x2F;mytest</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ export GO111MODULE&#x3D;on</span><br><span class="line">$ go mod init github.com&#x2F;cnwyt&#x2F;mytest</span><br><span class="line">go: creating new go.mod: module github.com&#x2F;cnwyt&#x2F;mytest</span><br></pre></td></tr></table></figure>

<p>当然这个 go 模块可以创建在任意位置，不强制邀请放在 GOPATH 路径下。</p>
<h4 id="在-GOPATH-src-外也可以创建项目"><a href="#在-GOPATH-src-外也可以创建项目" class="headerlink" title="在$GOPATH/src 外也可以创建项目"></a>在$GOPATH/src 外也可以创建项目</h4><p>在 GOPATH 以外的模块，创建一个 helloworld 目录，用来调用刚刚创建的 mytest 模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir helloworld &amp;&amp; cd helloworld</span><br><span class="line">$ vi main.go</span><br></pre></td></tr></table></figure>

<p>创建一个 main.go 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">&#x2F;&#x2F;import &quot;github.com&#x2F;cnwyt&#x2F;mytest&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;Hello, World!&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;mytest.ShowTest1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>初始化该模块，引入 github.com/cnwyt/mytest 模块，指定版本为 latest:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init helloworld</span><br><span class="line">$ go mod edit -require github.com&#x2F;cnwyt&#x2F;mytest@latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>初始化后，会生成一个 go.mod 文件，类似 npm 里的 package.json 或者 composer 的 composer.json 的一个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module helloworld</span><br><span class="line"></span><br><span class="line">require github.com&#x2F;cnwyt&#x2F;mytest v0.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样直接执行 go test 或者 go run main.go 会报错:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go test</span><br><span class="line">build helloworld: cannot find module for path github.com&#x2F;cnwyt&#x2F;mytest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是为啥呢？ 这是因为我们虽然创建了一个名为 github.com/cnwyt/mytest 模块，在 GOPATH 路径里也有这个模块。但是，GO 模块去 Github 去找这个模块，而不是在 GOPATH 路径里去找，所以找不到。</p>
<p>那该怎么办呢?<br>有两个解决办法：<br>第一个办法，很简单，就是直接将 cnwyt/mytest 模块推送的 GitHub 上。<br>但是，如果我要修改 cnwyt/mytest 里的代码，都得先推送到 GitHub 上，才能生效，实在太麻烦了。<br>那就直接使用第二个办法， 使用 go replace:</p>
<p>直接修改 go.mod，新增一行 replace:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module helloworld</span><br><span class="line"></span><br><span class="line">require github.com&#x2F;cnwyt&#x2F;mytest v0.0.0</span><br><span class="line"></span><br><span class="line">replace github.com&#x2F;cnwyt&#x2F;mytest &#x3D;&gt; &#x2F;Users&#x2F;wangtom&#x2F;goworkspace&#x2F;mytest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意版本号必须填写，可以填 v0.0.0 或者 latest.</p>
<h4 id="调用第三方模块"><a href="#调用第三方模块" class="headerlink" title="调用第三方模块"></a>调用第三方模块</h4><p>比如项目中会用到比较流行的路由模块 gorilla/mux:</p>
<p>直接修改 go.mod，新增一行 require，不指定版本可以直接写 latest 获取最新版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require github.com&#x2F;gorilla&#x2F;mux latest</span><br></pre></td></tr></table></figure>

<p>运行 go build 或 go test 会自动从 GitHub 下载模块，并会修改 go.mod 文件。</p>
<p>比如运行后会把 latest 直接修改成目前最新的版本 v1.6.2 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module helloworld</span><br><span class="line"></span><br><span class="line">require github.com&#x2F;cnwyt&#x2F;mytest v0.0.0</span><br><span class="line">require github.com&#x2F;gorilla&#x2F;mux v1.6.2</span><br><span class="line"></span><br><span class="line">replace github.com&#x2F;cnwyt&#x2F;mytest &#x3D;&gt; &#x2F;Users&#x2F;wangtom&#x2F;goworkspace&#x2F;godict</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到模块 gorilla/mux 代码会下载到 $GOPATH/pkg/mod/ 模块下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ll &#x2F;Users&#x2F;wangtom&#x2F;goworkspace&#x2F;pkg&#x2F;mod&#x2F;github.com&#x2F;gorilla</span><br><span class="line">total 0</span><br><span class="line">dr-xr-xr-x  22 wangtom  staff 704B 12 24 22:14 mux@v1.6.2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="不使用-vendor-和-module-机制时，可以手动下载所有依赖"><a href="#不使用-vendor-和-module-机制时，可以手动下载所有依赖" class="headerlink" title="不使用 vendor 和 module 机制时，可以手动下载所有依赖"></a>不使用 vendor 和 module 机制时，可以手动下载所有依赖</h2><p>在不使用 vendor 和 module 的情况下，可以使用较原始的方式，将代码中依赖的内容全部下载并编译在$GOPATH 路径下。<br>在项目目录下，执行如下命令：<br>go get -d -v ./…</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/29/git%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/29/git%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">Git相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-11-29 16:07:30 / Modified: 16:30:33" itemprop="dateCreated datePublished" datetime="2020-11-29T16:07:30+08:00">2020-11-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Git-区域的划分与提交回滚"><a href="#Git-区域的划分与提交回滚" class="headerlink" title="Git 区域的划分与提交回滚"></a>Git 区域的划分与提交回滚</h3><p><img src="/images/git-1.png"></p>
<h3 id="区域划分"><a href="#区域划分" class="headerlink" title="区域划分"></a>区域划分</h3><p>分为工作区，本地库(暂存区和分支)，远程库。<br>工作区：分为原文件和已经修改但是未暂存的文件。<br>暂存区：存放已经 git add 添加后的文件,此区位于本地库。<br>分支：存放已经 git commit 提交后的文件，此区位于本地库<br>远程库：存放已经 git push 后的文件。</p>
<ol>
<li><p>修改本地已被跟踪文件，文件进入未暂存区域。</p>
</li>
<li><p>未暂存区域转到暂存区域 git add files</p>
</li>
<li><p>暂存区提交到本地仓库 git commit -m</p>
</li>
<li><p>直接从未暂存区提交到本地仓库<br>git commit -am<br>经测试，对已跟踪的文件可以正确执行，而对于未跟踪文件（即新增文件）则会出错</p>
</li>
<li><p>本地库回退到暂存区<br>git reset –soft hash 值<br>git reset –soft origin/master<br>一般回退到暂存区的文件作排查用，不要直接修改，不然会同时出现在暂存区和未暂存区（其实即使修改了也木有太大关系）</p>
</li>
<li><p>本地库回退到未暂存区<br>git reset –mixed hash 值<br>git reset –mixed origin/master<br>一般回退到未暂存状态就是为了进一步的修改</p>
</li>
<li><p>本地库回退到文件初始状态（即此版本的）<br>git reset –hard hash 值<br>注意这里，通常先执行一次 fetch，保证本地版本是 origin 的最新版本，然后再回退。（最厉害的是，这么操作不会有冲突，直接让文件变成和 origin 保持一致）<br>git fetch origin<br>git reset –hard origin/master<br>特别注意：这么操作会使你对文件的修改全部消失，还原成最初状态。<br>(针对上一条情况衍生讲解)通常在推送到 origin 时，先要 pull，然后再推送，一般是修改提交了的文件和 pull 下来的同一个文件产生冲突（所以建议修改代码前，一定先要 pull）<br>git pull<br>git push origin master</p>
</li>
<li><p>暂存区回退到未暂存区<br>git reset – files<br>git rest<br>撤销所有暂存区的文件</p>
</li>
<li><p>未暂存区回退到文件初始状态<br>git checkout – files</p>
</li>
<li><p>暂存区回退到文件初始状态<br>git checkout head – files</p>
</li>
</ol>
<h3 id="换一个角度看"><a href="#换一个角度看" class="headerlink" title="换一个角度看"></a>换一个角度看</h3><ul>
<li>从工作区一直到远程仓库的过程是：git add files,git commit, git push.</li>
<li>从远程仓库到工作区的过程是:git fetch/git clone/git pull,git reset – files, git checkout – files。<br>files 是指文件名。<br><img src="/images/git-2.png"></li>
</ul>
<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><img src="/images/git-3.png"></p>
<ul>
<li>git reset –soft,重置位置的同时，保留 working Tree 工作目录和 index 暂存区的内容，只让 repository 中的内容和 reset 目标节点(reset 目标节点是指 reset 命令执行后，head 所指向的节点，或者说 commit 记录)保持一致，因此原节点和 reset 节点之间的【差异变更集】会放入 index 暂存区中(Staged files)。所以效果看起来就是工作目录的内容不变，暂存区原有的内容也不变，只是原节点和 Reset 节点之间的所有差异都会放到暂存区中。</li>
<li>git reset –mixed,重置位置的同时，只保留 Working Tree 工作目录的內容，但会将 Index 暂存区 和 Repository 中的內容更改和 reset 目标节点一致，因此原节点和 Reset 节点之间的【差异变更集】会放入 Working Tree 工作目录中。所以效果看起来就是原节点和 Reset 节点之间的所有差异都会放到工作目录中。</li>
<li>git reset –hard,重置位置的同时，直接将 working Tree 工作目录、 index 暂存区及 repository 都重置成目标 Reset 节点的內容,所以效果看起来等同于清空暂存区和工作区。可以使用 **git reset –hard HEAD^ 来回退到上一次 commit 的状态。<br>此命令可以用来回退到任意版本：git reset –hard commitid **</li>
<li>git reset,用来从暂存区撤销上一次 git add 添加的修改内容。可以使用 git reset HEAD filepathname （比如： git reset HEAD readme.md）来放弃指定文件的缓存，放弃所有的缓存可以使用 git reset HEAD . 命令。不影响工作区中的内容。<br>git reset 详细解释可以参看，<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c2ec5f06cf1a">https://www.jianshu.com/p/c2ec5f06cf1a</a></li>
</ul>
<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p><img src="/images/git-4.png"></p>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>这要从 git 的分支说起，git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。git 是如何知道你当前在哪个分支上工作的呢？<br>其实答案也很简单，它保存着一个名为 HEAD 的特别指针。在 git 中，它是一个指向你正在工作中的本地分支的指针，可以将 HEAD 想象为当前分支的别名。<br><img src="/images/git-5.png"></p>
<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>git 的四个工作区<br><img src="/images/git-6.png"></p>
<p>git diff：是查看 workspace（工作区） 与 index（暂存区） 的差别的。<br>git diff –cached：是查看 index（暂存区） 与 local repositorty（本地仓库） 的差别的。<br>git diff HEAD：是查看 workspace 和 local repository 的差别的。（HEAD 指向的是 local repository 中最新提交的版本）</p>
<p>注：git diff 后跟两个参数，如果只写一个参数，表示默认跟 workspace 中的代码作比较。git diff 显示的结果为 第二个参数所指的代码在第一个参数所指代码基础上的修改。如，git diff HEAD 表示 workspace 在 最新 commit 的基础上所做的修改</p>
<h4 id="比较工作区与暂存区"><a href="#比较工作区与暂存区" class="headerlink" title="比较工作区与暂存区"></a>比较工作区与暂存区</h4><p><img src="/images/git-7.png"></p>
<h4 id="比较本地库的当前版本和上一次版本"><a href="#比较本地库的当前版本和上一次版本" class="headerlink" title="比较本地库的当前版本和上一次版本"></a>比较本地库的当前版本和上一次版本</h4><p><img src="/images/git-8.png"></p>
<h3 id="git-pull-时冲突了怎么办"><a href="#git-pull-时冲突了怎么办" class="headerlink" title="git pull 时冲突了怎么办"></a>git pull 时冲突了怎么办</h3><ol>
<li>忽略本地修改，强制拉取远程到本地</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line"></span><br><span class="line">git reset --hard origin&#x2F;dev</span><br><span class="line"></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>未 commit 先 pull，视本地修改量选择 revert 或 stash</p>
<ul>
<li>本地修改量小。<code>-&gt; revert(把自己的代码取消) -&gt; 重新pull -&gt; 在最新代码上修改 -&gt; [pull确认最新] -&gt; commit&amp;push</code></li>
<li>本地修改量大。<code>-&gt; stash save(把自己的代码隐藏存起来) -&gt; 重新pull -&gt; stash pop(把存起来的隐藏的代码取回来 ) -&gt; 代码文件会显示冲突 -&gt; 右键选择resolve conflict -&gt; 打开文件解决冲突 -&gt;commit&amp;push</code><br>git stash 能够将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录。</li>
</ul>
</li>
<li><p>已 commit 未 push，视本地修改量选择 reset 或直接 merge</p>
<ul>
<li>修改量小。<code>-&gt; reset(回退到未修改之前，选hard模式，把自己的更改取消) -&gt; 重新pull -&gt; 在最新代码上修改 -&gt; [pull确认最新] -&gt; commit&amp;push</code></li>
<li>修改量大。<code>-&gt; commit后pull显示冲突 -&gt; 手动merge解决冲突 -&gt; 重新commit -&gt; push</code></li>
</ul>
</li>
</ol>
<h3 id="git-revert-和-reset-的区别"><a href="#git-revert-和-reset-的区别" class="headerlink" title="git revert 和 reset 的区别"></a>git revert 和 reset 的区别</h3><p>git revert 和 git reset 的区别</p>
<ul>
<li>git revert 是用一次新的 commit 来回滚之前的 commit，此次提交之前的 commit 都会被保留；</li>
<li>git reset 是回到某次提交，提交及之前的 commit 都会被保留，但是此 commit id 之后的修改都会被删除</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/29/mockito/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/29/mockito/" class="post-title-link" itemprop="url">Mockito相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-29 16:07:30" itemprop="dateCreated datePublished" datetime="2020-11-29T16:07:30+08:00">2020-11-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-06 11:49:08" itemprop="dateModified" datetime="2020-12-06T11:49:08+08:00">2020-12-06</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-Mockito-介绍"><a href="#1-Mockito-介绍" class="headerlink" title="1 Mockito 介绍"></a>1 Mockito 介绍</h1><h2 id="1-1-Mockito-是什么？"><a href="#1-1-Mockito-是什么？" class="headerlink" title="1.1 Mockito 是什么？"></a>1.1 Mockito 是什么？</h2><p>Mockito 是 mocking 框架，它让你用简洁的 API 做测试。而且 Mockito 简单易学，它可读性强和验证语法简洁。</p>
<h2 id="1-2-为什么需要-Mock"><a href="#1-2-为什么需要-Mock" class="headerlink" title="1.2 为什么需要 Mock"></a>1.2 为什么需要 Mock</h2><p>测试驱动的开发( TDD)要求我们先写单元测试，再写实现代码。在写单元测试的过程中，我们往往会遇到要测试的类有很多依赖，这些依赖的类/对象/资源又有别的依赖，从而形成一个大的依赖树，要在单元测试的环境中完整地构建这样的依赖，是一件很困难的事情。如下图所示：<br><img src="/images/mockito-1.png"><br>为了测试类 A，我们需要 Mock B 类和 C 类（用虚拟对象来代替）如下图所示：<br><img src="/images/mockito-2.png"></p>
<h2 id="1-3-Stub-和-Mock-异同-1"><a href="#1-3-Stub-和-Mock-异同-1" class="headerlink" title="1.3 Stub 和 Mock 异同[1]"></a>1.3 Stub 和 Mock 异同[1]</h2><p>相同：Stub 和 Mock 都是模拟外部依赖<br>不同：Stub 是完全模拟一个外部依赖， 而 Mock 还可以用来判断测试通过还是失败</p>
<h2 id="1-4-Mockito-资源"><a href="#1-4-Mockito-资源" class="headerlink" title="1.4 Mockito 资源"></a>1.4 Mockito 资源</h2><p>官网： <a target="_blank" rel="noopener" href="http://mockito.org/">http://mockito.org</a></p>
<p>API 文档：<a target="_blank" rel="noopener" href="http://docs.mockito.googlecode.com/hg/org/mockito/Mockito.html">http://docs.mockito.googlecode.com/hg/org/mockito/Mockito.html</a></p>
<p>项目源码：<a target="_blank" rel="noopener" href="https://github.com/mockito/mockito">https://github.com/mockito/mockito</a></p>
<h2 id="1-5-使用场景"><a href="#1-5-使用场景" class="headerlink" title="1.5 使用场景"></a>1.5 使用场景</h2><p>提前创建测试; TDD（测试驱动开发）<br>团队可以并行工作<br>你可以创建一个验证或者演示程序<br>为无法访问的资源编写测试<br>Mock 可以交给用户<br>隔离系统</p>
<h1 id="2-使用-Mockito"><a href="#2-使用-Mockito" class="headerlink" title="2 使用 Mockito"></a>2 使用 Mockito</h1><p>添加 maven 依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mockito&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mockito-all&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.9.5&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>添加 junit 依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.11&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>添加引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import static org.mockito.Mockito._;</span><br><span class="line">import static org.junit.Assert._;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-验证行为"><a href="#2-1-验证行为" class="headerlink" title="2.1 验证行为"></a>2.1 验证行为</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void verify_behaviour()&#123;</span><br><span class="line">&#x2F;&#x2F;模拟创建一个 List 对象</span><br><span class="line">List mock &#x3D; mock(List.class);</span><br><span class="line">&#x2F;&#x2F;使用 mock 的对象</span><br><span class="line">mock.add(1);</span><br><span class="line">mock.clear();</span><br><span class="line">&#x2F;&#x2F;验证 add(1)和 clear()行为是否发生</span><br><span class="line">verify(mock).add(1);</span><br><span class="line">verify(mock).clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-模拟我们所期望的结果"><a href="#2-2-模拟我们所期望的结果" class="headerlink" title="2.2 模拟我们所期望的结果"></a>2.2 模拟我们所期望的结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void when_thenReturn()&#123;</span><br><span class="line">&#x2F;&#x2F;mock 一个 Iterator 类</span><br><span class="line">Iterator iterator &#x3D; mock(Iterator.class);</span><br><span class="line">&#x2F;&#x2F;预设当 iterator 调用 next()时第一次返回 hello，第 n 次都返回 world</span><br><span class="line">when(iterator.next()).thenReturn(&quot;hello&quot;).thenReturn(&quot;world&quot;);</span><br><span class="line">&#x2F;&#x2F;使用 mock 的对象</span><br><span class="line">String result &#x3D; iterator.next() + &quot; &quot; + iterator.next() + &quot; &quot; + iterator.next();</span><br><span class="line">&#x2F;&#x2F;验证结果</span><br><span class="line">assertEquals(&quot;hello world world&quot;,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test(expected &#x3D; IOException.class)</span><br><span class="line">public void when_thenThrow() throws IOException &#123;</span><br><span class="line">OutputStream outputStream &#x3D; mock(OutputStream.class);</span><br><span class="line">OutputStreamWriter writer &#x3D; new OutputStreamWriter(outputStream);</span><br><span class="line">&#x2F;&#x2F;预设当流关闭时抛出异常</span><br><span class="line">doThrow(new IOException()).when(outputStream).close();</span><br><span class="line">outputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-RETURNS-SMART-NULLS-和-RETURNS-DEEP-STUBS"><a href="#2-3-RETURNS-SMART-NULLS-和-RETURNS-DEEP-STUBS" class="headerlink" title="2.3 RETURNS_SMART_NULLS 和 RETURNS_DEEP_STUBS"></a>2.3 RETURNS_SMART_NULLS 和 RETURNS_DEEP_STUBS</h2><p>RETURNS_SMART_NULLS 实现了 Answer 接口的对象，它是创建 mock 对象时的一个可选参数，mock(Class,Answer)。</p>
<p>在创建 mock 对象时，有的方法我们没有进行 stubbing，所以调用时会放回 Null 这样在进行操作是很可能抛出 NullPointerException。如果通过 RETURNS_SMART_NULLS 参数创建的 mock 对象在没有调用 stubbed 方法时会返回 SmartNull。例如：返回类型是 String，会返回””;是 int，会返回 0；是 List，会返回空的 List。另外，在控制台窗口中可以看到 SmartNull 的友好提示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void returnsSmartNullsTest() &#123;</span><br><span class="line">List mock &#x3D; mock(List.class, RETURNS_SMART_NULLS);</span><br><span class="line">System.out.println(mock.get(0));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用 RETURNS_SMART_NULLS 参数创建的 mock 对象，不会抛出 NullPointerException 异常。另外控制台窗口会提示信息“SmartNull returned by unstubbed get() method on mock”</span><br><span class="line">System.out.println(mock.toArray().length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RETURNS_DEEP_STUBS 也是创建 mock 对象时的备选参数</p>
<p>RETURNS_DEEP_STUBS 参数程序会自动进行 mock 所需的对象，方法 deepstubsTest 和 deepstubsTest2 是等价的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void deepstubsTest()&#123;</span><br><span class="line">Account account&#x3D;mock(Account.class,RETURNS_DEEP_STUBS);</span><br><span class="line">when(account.getRailwayTicket().getDestination()).thenReturn(&quot;Beijing&quot;);</span><br><span class="line">account.getRailwayTicket().getDestination();</span><br><span class="line">verify(account.getRailwayTicket()).getDestination();</span><br><span class="line">assertEquals(&quot;Beijing&quot;,account.getRailwayTicket().getDestination());</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void deepstubsTest2()&#123;</span><br><span class="line">Account account&#x3D;mock(Account.class);</span><br><span class="line">RailwayTicket railwayTicket&#x3D;mock(RailwayTicket.class);</span><br><span class="line"> when(account.getRailwayTicket()).thenReturn(railwayTicket);</span><br><span class="line">when(railwayTicket.getDestination()).thenReturn(&quot;Beijing&quot;);</span><br><span class="line"></span><br><span class="line">account.getRailwayTicket().getDestination();</span><br><span class="line">verify(account.getRailwayTicket()).getDestination();</span><br><span class="line"> assertEquals(&quot;Beijing&quot;,account.getRailwayTicket().getDestination());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RailwayTicket&#123;</span><br><span class="line">private String destination;</span><br><span class="line"></span><br><span class="line">        public String getDestination() &#123;</span><br><span class="line">            return destination;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setDestination(String destination) &#123;</span><br><span class="line">            this.destination &#x3D; destination;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class Account&#123;</span><br><span class="line">        private RailwayTicket railwayTicket;</span><br><span class="line"></span><br><span class="line">        public RailwayTicket getRailwayTicket() &#123;</span><br><span class="line">            return railwayTicket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setRailwayTicket(RailwayTicket railwayTicket) &#123;</span><br><span class="line">            this.railwayTicket &#x3D; railwayTicket;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-4-模拟方法体抛出异常"><a href="#2-4-模拟方法体抛出异常" class="headerlink" title="2.4 模拟方法体抛出异常"></a>2.4 模拟方法体抛出异常</h2><p>@Test(expected = RuntimeException.class)<br>public void doThrow_when(){<br>List list = mock(List.class);<br>doThrow(new RuntimeException()).when(list).add(1);<br>list.add(1);<br>}</p>
<h2 id="2-5-使用注解来快速模拟"><a href="#2-5-使用注解来快速模拟" class="headerlink" title="2.5 使用注解来快速模拟"></a>2.5 使用注解来快速模拟</h2><p>在上面的测试中我们在每个测试方法里都 mock 了一个 List 对象，为了避免重复的 mock，是测试类更具有可读性，我们可以使用下面的注解方式来快速模拟对象：</p>
<pre><code>@Mock
private List mockList;</code></pre>
<p>OK，我们再用注解的 mock 对象试试</p>
<pre><code>@Test
public void shorthand()&#123;
    mockList.add(1);
    verify(mockList).add(1);
&#125;</code></pre>
<p>运行这个测试类你会发现报错了，mock 的对象为 NULL，为此我们必须在基类中添加初始化 mock 的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MockitoExample2 &#123;</span><br><span class="line">@Mock</span><br><span class="line">private List mockList;</span><br><span class="line"></span><br><span class="line">    public MockitoExample2()&#123;</span><br><span class="line">        MockitoAnnotations.initMocks(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void shorthand()&#123;</span><br><span class="line">        mockList.add(1);</span><br><span class="line">        verify(mockList).add(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用 built-in runner：MockitoJUnitRunner</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(MockitoJUnitRunner.class)</span><br><span class="line">public class MockitoExample2 &#123;</span><br><span class="line">@Mock</span><br><span class="line">private List mockList;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void shorthand()&#123;</span><br><span class="line">        mockList.add(1);</span><br><span class="line">        verify(mockList).add(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-参数匹配"><a href="#2-6-参数匹配" class="headerlink" title="2.6 参数匹配"></a>2.6 参数匹配</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void with_arguments()&#123;</span><br><span class="line">Comparable comparable &#x3D; mock(Comparable.class);</span><br><span class="line">&#x2F;&#x2F;预设根据不同的参数返回不同的结果</span><br><span class="line">when(comparable.compareTo(&quot;Test&quot;)).thenReturn(1);</span><br><span class="line">when(comparable.compareTo(&quot;Omg&quot;)).thenReturn(2);</span><br><span class="line">assertEquals(1, comparable.compareTo(&quot;Test&quot;));</span><br><span class="line">assertEquals(2, comparable.compareTo(&quot;Omg&quot;));</span><br><span class="line">&#x2F;&#x2F;对于没有预设的情况会返回默认值</span><br><span class="line">assertEquals(0, comparable.compareTo(&quot;Not stub&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了匹配制定参数外，还可以匹配自己想要的任意参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void with_unspecified_arguments()&#123;</span><br><span class="line">List list &#x3D; mock(List.class);</span><br><span class="line">&#x2F;&#x2F;匹配任意参数</span><br><span class="line">when(list.get(anyInt())).thenReturn(1);</span><br><span class="line">when(list.contains(argThat(new IsValid()))).thenReturn(true);</span><br><span class="line">assertEquals(1, list.get(1));</span><br><span class="line">assertEquals(1, list.get(999));</span><br><span class="line">assertTrue(list.contains(1));</span><br><span class="line">assertTrue(!list.contains(3));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    private class IsValid extends ArgumentMatcher&lt;List&gt;&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean matches(Object o) &#123;</span><br><span class="line">            return o &#x3D;&#x3D; 1 || o &#x3D;&#x3D; 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：如果你使用了参数匹配，那么所有的参数都必须通过 matchers 来匹配，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void all_arguments_provided_by_matchers()&#123;</span><br><span class="line">Comparator comparator &#x3D; mock(Comparator.class);</span><br><span class="line">comparator.compare(&quot;nihao&quot;,&quot;hello&quot;);</span><br><span class="line">&#x2F;&#x2F;如果你使用了参数匹配，那么所有的参数都必须通过 matchers 来匹配</span><br><span class="line">verify(comparator).compare(anyString(),eq(&quot;hello&quot;));</span><br><span class="line">&#x2F;&#x2F;下面的为无效的参数匹配使用</span><br><span class="line">&#x2F;&#x2F;verify(comparator).compare(anyString(),&quot;hello&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7-自定义参数匹配"><a href="#2-7-自定义参数匹配" class="headerlink" title="2.7 自定义参数匹配"></a>2.7 自定义参数匹配</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void argumentMatchersTest()&#123;</span><br><span class="line">&#x2F;&#x2F;创建 mock 对象</span><br><span class="line">List&lt;String&gt; mock &#x3D; mock(List.class);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;argThat(Matches&lt;T&gt; matcher)方法用来应用自定义的规则，可以传入任何实现Matcher接口的实现类。</span><br><span class="line">        when(mock.addAll(argThat(new IsListofTwoElements()))).thenReturn(true);</span><br><span class="line"></span><br><span class="line">        mock.addAll(Arrays.asList(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;));</span><br><span class="line">        &#x2F;&#x2F;IsListofTwoElements用来匹配size为2的List，因为例子传入List为三个元素，所以此时将失败。</span><br><span class="line">        verify(mock).addAll(argThat(new IsListofTwoElements()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class IsListofTwoElements extends ArgumentMatcher&lt;List&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        public boolean matches(Object list)</span><br><span class="line">        &#123;</span><br><span class="line">            return((List)list).size()&#x3D;&#x3D;2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-8-捕获参数来进一步断言"><a href="#2-8-捕获参数来进一步断言" class="headerlink" title="2.8 捕获参数来进一步断言"></a>2.8 捕获参数来进一步断言</h2><p>较复杂的参数匹配器会降低代码的可读性，有些地方使用参数捕获器更加合适。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void capturing_args()&#123;</span><br><span class="line">PersonDao personDao &#x3D; mock(PersonDao.class);</span><br><span class="line">PersonService personService &#x3D; new PersonService(personDao);</span><br><span class="line"></span><br><span class="line">        ArgumentCaptor&lt;Person&gt; argument &#x3D; ArgumentCaptor.forClass(Person.class);</span><br><span class="line">        personService.update(1,&quot;jack&quot;);</span><br><span class="line">        verify(personDao).update(argument.capture());</span><br><span class="line">        assertEquals(1,argument.getValue().getId());</span><br><span class="line">        assertEquals(&quot;jack&quot;,argument.getValue().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     class Person&#123;</span><br><span class="line">        private int id;</span><br><span class="line">        private String name;</span><br><span class="line"></span><br><span class="line">        Person(int id, String name) &#123;</span><br><span class="line">            this.id &#x3D; id;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getId() &#123;</span><br><span class="line">            return id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface PersonDao&#123;</span><br><span class="line">        public void update(Person person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class PersonService&#123;</span><br><span class="line">        private PersonDao personDao;</span><br><span class="line"></span><br><span class="line">        PersonService(PersonDao personDao) &#123;</span><br><span class="line">            this.personDao &#x3D; personDao;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void update(int id,String name)&#123;</span><br><span class="line">            personDao.update(new Person(id,name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-9-使用方法预期回调接口生成期望值（Answer-结构）"><a href="#2-9-使用方法预期回调接口生成期望值（Answer-结构）" class="headerlink" title="2.9 使用方法预期回调接口生成期望值（Answer 结构）"></a>2.9 使用方法预期回调接口生成期望值（Answer 结构）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void answerTest()&#123;</span><br><span class="line">when(mockList.get(anyInt())).thenAnswer(new CustomAnswer());</span><br><span class="line">assertEquals(&quot;hello world:0&quot;,mockList.get(0));</span><br><span class="line">assertEquals(&quot;hello world:999&quot;,mockList.get(999));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    private class CustomAnswer implements Answer&lt;String&gt;&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String answer(InvocationOnMock invocation) throws Throwable &#123;</span><br><span class="line">            Object[] args &#x3D; invocation.getArguments();</span><br><span class="line">            return &quot;hello world:&quot;+args[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也可使用匿名内部类实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void answer_with_callback()&#123;</span><br><span class="line">&#x2F;&#x2F;使用 Answer 来生成我们我们期望的返回</span><br><span class="line">when(mockList.get(anyInt())).thenAnswer(new Answer&lt;Object&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Object answer(InvocationOnMock invocation) throws Throwable &#123;</span><br><span class="line">Object[] args &#x3D; invocation.getArguments();</span><br><span class="line">return &quot;hello world:&quot;+args[0];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">assertEquals(&quot;hello world:0&quot;,mockList.get(0));</span><br><span class="line">assertEquals(&quot;hello world:999&quot;,mockList.get(999));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-10-修改对未预设的调用返回默认期望"><a href="#2-10-修改对未预设的调用返回默认期望" class="headerlink" title="2.10 修改对未预设的调用返回默认期望"></a>2.10 修改对未预设的调用返回默认期望</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void unstubbed_invocations()&#123;</span><br><span class="line">&#x2F;&#x2F;mock 对象使用 Answer 来对未预设的调用返回默认期望值</span><br><span class="line">List mock &#x3D; mock(List.class,new Answer() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Object answer(InvocationOnMock invocation) throws Throwable &#123;</span><br><span class="line">return 999;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;下面的 get(1)没有预设，通常情况下会返回 NULL，但是使用了 Answer 改变了默认期望值</span><br><span class="line">assertEquals(999, mock.get(1));</span><br><span class="line">&#x2F;&#x2F;下面的 size()没有预设，通常情况下会返回 0，但是使用了 Answer 改变了默认期望值</span><br><span class="line">assertEquals(999,mock.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-11-用-spy-监控真实对象"><a href="#2-11-用-spy-监控真实对象" class="headerlink" title="2.11 用 spy 监控真实对象"></a>2.11 用 spy 监控真实对象</h2><p>Mock 不是真实的对象，它只是用类型的 class 创建了一个虚拟对象，并可以设置对象行为<br>Spy 是一个真实的对象，但它可以设置对象行为<br>InjectMocks 创建这个类的对象并自动将标记@Mock、@Spy 等注解的属性值注入到这个中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Test(expected &#x3D; IndexOutOfBoundsException.class)</span><br><span class="line">public void spy_on_real_objects()&#123;</span><br><span class="line">List list &#x3D; new LinkedList();</span><br><span class="line">List spy &#x3D; spy(list);</span><br><span class="line">&#x2F;&#x2F;下面预设的 spy.get(0)会报错，因为会调用真实对象的 get(0)，所以会抛出越界异常</span><br><span class="line">&#x2F;&#x2F;when(spy.get(0)).thenReturn(3);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;使用doReturn-when可以避免when-thenReturn调用真实对象api</span><br><span class="line">        doReturn(999).when(spy).get(999);</span><br><span class="line">        &#x2F;&#x2F;预设size()期望值</span><br><span class="line">        when(spy.size()).thenReturn(100);</span><br><span class="line">        &#x2F;&#x2F;调用真实对象的api</span><br><span class="line">        spy.add(1);</span><br><span class="line">        spy.add(2);</span><br><span class="line">        assertEquals(100,spy.size());</span><br><span class="line">        assertEquals(1,spy.get(0));</span><br><span class="line">        assertEquals(2,spy.get(1));</span><br><span class="line">        verify(spy).add(1);</span><br><span class="line">        verify(spy).add(2);</span><br><span class="line">        assertEquals(999,spy.get(999));</span><br><span class="line">        spy.get(2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-12-真实的部分-mock"><a href="#2-12-真实的部分-mock" class="headerlink" title="2.12 真实的部分 mock"></a>2.12 真实的部分 mock</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void real_partial_mock()&#123;</span><br><span class="line">&#x2F;&#x2F;通过 spy 来调用真实的 api</span><br><span class="line">List list &#x3D; spy(new ArrayList());</span><br><span class="line">assertEquals(0,list.size());</span><br><span class="line">A a &#x3D; mock(A.class);</span><br><span class="line">&#x2F;&#x2F;通过 thenCallRealMethod 来调用真实的 api</span><br><span class="line">when(a.doSomething(anyInt())).thenCallRealMethod();</span><br><span class="line">assertEquals(999,a.doSomething(999));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    class A&#123;</span><br><span class="line">        public int doSomething(int i)&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-13-重置-mock"><a href="#2-13-重置-mock" class="headerlink" title="2.13 重置 mock"></a>2.13 重置 mock</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void reset_mock()&#123;</span><br><span class="line">List list &#x3D; mock(List.class);</span><br><span class="line">when(list.size()).thenReturn(10);</span><br><span class="line">list.add(1);</span><br><span class="line">assertEquals(10,list.size());</span><br><span class="line">&#x2F;&#x2F;重置 mock，清除所有的互动和预设</span><br><span class="line">reset(list);</span><br><span class="line">assertEquals(0,list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-14-验证确切的调用次数"><a href="#2-14-验证确切的调用次数" class="headerlink" title="2.14 验证确切的调用次数"></a>2.14 验证确切的调用次数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void verifying_number_of_invocations()&#123;</span><br><span class="line">List list &#x3D; mock(List.class);</span><br><span class="line">list.add(1);</span><br><span class="line">list.add(2);</span><br><span class="line">list.add(2);</span><br><span class="line">list.add(3);</span><br><span class="line">list.add(3);</span><br><span class="line">list.add(3);</span><br><span class="line">&#x2F;&#x2F;验证是否被调用一次，等效于下面的 times(1)</span><br><span class="line">verify(list).add(1);</span><br><span class="line">verify(list,times(1)).add(1);</span><br><span class="line">&#x2F;&#x2F;验证是否被调用 2 次</span><br><span class="line">verify(list,times(2)).add(2);</span><br><span class="line">&#x2F;&#x2F;验证是否被调用 3 次</span><br><span class="line">verify(list,times(3)).add(3);</span><br><span class="line">&#x2F;&#x2F;验证是否从未被调用过</span><br><span class="line">verify(list,never()).add(4);</span><br><span class="line">&#x2F;&#x2F;验证至少调用一次</span><br><span class="line">verify(list,atLeastOnce()).add(1);</span><br><span class="line">&#x2F;&#x2F;验证至少调用 2 次</span><br><span class="line">verify(list,atLeast(2)).add(2);</span><br><span class="line">&#x2F;&#x2F;验证至多调用 3 次</span><br><span class="line">verify(list,atMost(3)).add(3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-15-连续调用"><a href="#2-15-连续调用" class="headerlink" title="2.15 连续调用"></a>2.15 连续调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test(expected &#x3D; RuntimeException.class)</span><br><span class="line">public void consecutive_calls()&#123;</span><br><span class="line">&#x2F;&#x2F;模拟连续调用返回期望值，如果分开，则只有最后一个有效</span><br><span class="line">when(mockList.get(0)).thenReturn(0);</span><br><span class="line">when(mockList.get(0)).thenReturn(1);</span><br><span class="line">when(mockList.get(0)).thenReturn(2);</span><br><span class="line">when(mockList.get(1)).thenReturn(0).thenReturn(1).thenThrow(new RuntimeException());</span><br><span class="line">assertEquals(2,mockList.get(0));</span><br><span class="line">assertEquals(2,mockList.get(0));</span><br><span class="line">assertEquals(0,mockList.get(1));</span><br><span class="line">assertEquals(1,mockList.get(1));</span><br><span class="line">&#x2F;&#x2F;第三次或更多调用都会抛出异常</span><br><span class="line">mockList.get(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-16-验证执行顺序"><a href="#2-16-验证执行顺序" class="headerlink" title="2.16 验证执行顺序"></a>2.16 验证执行顺序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void verification_in_order()&#123;</span><br><span class="line">List list &#x3D; mock(List.class);</span><br><span class="line">List list2 &#x3D; mock(List.class);</span><br><span class="line">list.add(1);</span><br><span class="line">list2.add(&quot;hello&quot;);</span><br><span class="line">list.add(2);</span><br><span class="line">list2.add(&quot;world&quot;);</span><br><span class="line">&#x2F;&#x2F;将需要排序的 mock 对象放入 InOrder</span><br><span class="line">InOrder inOrder &#x3D; inOrder(list,list2);</span><br><span class="line">&#x2F;&#x2F;下面的代码不能颠倒顺序，验证执行顺序</span><br><span class="line">inOrder.verify(list).add(1);</span><br><span class="line">inOrder.verify(list2).add(&quot;hello&quot;);</span><br><span class="line">inOrder.verify(list).add(2);</span><br><span class="line">inOrder.verify(list2).add(&quot;world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-17-确保模拟对象上无互动发生"><a href="#2-17-确保模拟对象上无互动发生" class="headerlink" title="2.17 确保模拟对象上无互动发生"></a>2.17 确保模拟对象上无互动发生</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void verify_interaction()&#123;</span><br><span class="line">List list &#x3D; mock(List.class);</span><br><span class="line">List list2 &#x3D; mock(List.class);</span><br><span class="line">List list3 &#x3D; mock(List.class);</span><br><span class="line">list.add(1);</span><br><span class="line">verify(list).add(1);</span><br><span class="line">verify(list,never()).add(2);</span><br><span class="line">&#x2F;&#x2F;验证零互动行为</span><br><span class="line">verifyZeroInteractions(list2,list3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-18-找出冗余的互动-即未被验证到的"><a href="#2-18-找出冗余的互动-即未被验证到的" class="headerlink" title="2.18 找出冗余的互动(即未被验证到的)"></a>2.18 找出冗余的互动(即未被验证到的)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test(expected &#x3D; NoInteractionsWanted.class)</span><br><span class="line">public void find_redundant_interaction()&#123;</span><br><span class="line">List list &#x3D; mock(List.class);</span><br><span class="line">list.add(1);</span><br><span class="line">list.add(2);</span><br><span class="line">verify(list,times(2)).add(anyInt());</span><br><span class="line">&#x2F;&#x2F;检查是否有未被验证的互动行为，因为 add(1)和 add(2)都会被上面的 anyInt()验证到，所以下面的代码会通过</span><br><span class="line">verifyNoMoreInteractions(list);</span><br><span class="line"></span><br><span class="line">        List list2 &#x3D; mock(List.class);</span><br><span class="line">        list2.add(1);</span><br><span class="line">        list2.add(2);</span><br><span class="line">        verify(list2).add(1);</span><br><span class="line">        &#x2F;&#x2F;检查是否有未被验证的互动行为，因为add(2)没有被验证，所以下面的代码会失败抛出异常</span><br><span class="line">        verifyNoMoreInteractions(list2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-Mockito-如何实现-Mock"><a href="#3-Mockito-如何实现-Mock" class="headerlink" title="3 Mockito 如何实现 Mock"></a>3 Mockito 如何实现 Mock</h1><p>Mockito 并不是创建一个真实的对象，而是模拟这个对象，他用简单的 when(mock.method(params)).thenRetrun(result)语句设置 mock 对象的行为，如下语句：</p>
<p>// 设置 mock 对象的行为 － 当调用其 get 方法获取第 0 个元素时，返回”first”<br>Mockito.when(mockedList.get(0)).thenReturn(“first”);<br>在 Mock 对象的时候，创建一个 proxy 对象，保存被调用的方法名（get），以及调用时候传递的参数（0），然后在调用 thenReturn 方法时再把“first”保存起来，这样，就有了构建一个 stub 方法所需的所有信息，构建一个 stub。当 get 方法被调用的时候，实际上调用的是之前保存的 proxy 对象的 get 方法，返回之前保存的数据。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/22/Java%E7%9A%84SPI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/22/Java%E7%9A%84SPI/" class="post-title-link" itemprop="url">JAVA SPI</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-22 12:01:22" itemprop="dateCreated datePublished" datetime="2020-11-22T12:01:22+08:00">2020-11-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-29 16:08:28" itemprop="dateModified" datetime="2020-11-29T16:08:28+08:00">2020-11-29</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="spi-使用"><a href="#spi-使用" class="headerlink" title="spi 使用"></a>spi 使用</h1><p>首先，通过一张图来看，完成 spi 的实现，需要哪些操作，需要遵循哪些规范？</p>
<h2 id="1-代码编写"><a href="#1-代码编写" class="headerlink" title="1.代码编写"></a>1.代码编写</h2><p>既然是 spi，那么就必须先定义好接口。其次，就是定义好接口的实现类。</p>
<h2 id="2-创建一个文件夹"><a href="#2-创建一个文件夹" class="headerlink" title="2.创建一个文件夹"></a>2.创建一个文件夹</h2><p>在项目的\src\main\resources\下创建\META-INF<br>\services 目录(笔者在网上找了很多文章，很多都没有告知具体这个文件夹放在哪，放在其他位置下无法加载得到)</p>
<h2 id="3-文件夹下增加配置文件"><a href="#3-文件夹下增加配置文件" class="headerlink" title="3.文件夹下增加配置文件"></a>3.文件夹下增加配置文件</h2><p>在上面 META-INF<br>\services 的目录下再增加一个配置文件，这个文件必须以接口的全限定类名保持一致，例如：com.jiaboyan.test.HelloService</p>
<h2 id="4-配置文件增加描述"><a href="#4-配置文件增加描述" class="headerlink" title="4.配置文件增加描述"></a>4.配置文件增加描述</h2><p>上面介绍 spi 时说道，除了代码上的接口实现之外，你还需要把该实现的描述提供给 JDK。那么，此步骤就是在配置文件中撰写接口实现描述。很简单，就是在配置文件中写入具体实现类的全限定类名，如有多个便换行写入。</p>
<h2 id="5-使用-JDK-来载入"><a href="#5-使用-JDK-来载入" class="headerlink" title="5.使用 JDK 来载入"></a>5.使用 JDK 来载入</h2><p>编写 main()方法，输出测试接口。使用 JDK 提供的 ServiceLoader.load()来加载配置文件中的描述信息，完成类加载操作。</p>
<p><img src="/images/spi-1.png"></p>
<p>接口定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface HelloService &#123;</span><br><span class="line"></span><br><span class="line">    void hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class HelloService1Impl implements HelloService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(&quot;hello jiaboyan&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HelloService2Impl implements HelloService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加 JDK 描述，在 META-INF\services 目录下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.jiaboyan.test.impl.HelloService1Impl</span><br><span class="line">com.jiaboyan.test.impl.HelloService2Impl</span><br></pre></td></tr></table></figure>

<p>编写 main()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] agrs) &#123;</span><br><span class="line">        ServiceLoader&lt;HelloService&gt; loaders &#x3D; ServiceLoader.load(HelloService.class);</span><br><span class="line">        for (HelloService helloService : loaders) &#123;</span><br><span class="line">            helloService.hello();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SPI-机制"><a href="#SPI-机制" class="headerlink" title="SPI-机制"></a>SPI-机制</h1><p>SPI 全称为 Service Provider Interface，是 JDK 内置的一种服务提供发现机制。简单来说，它就是一种动态替换发现机制。例如：有个接口想在运行时才发现具体的实现类，那么你只需要在程序运行前添加一个实现即可，并把新加的实现描述给 JDK 即可。此外，在程序的运行过程中，也可以随时对该描述进行修改，完成具体实现的替换。</p>
<p>Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。</p>
<p>这些 SPI 的接口是由 Java 核心库来提供，而 SPI 的实现则是作为 Java 应用所依赖的 jar 包被包含进类路径（CLASSPATH）中。例如：JDBC 的实现 mysql 就是通过 maven 被依赖进来。</p>
<p>那么问题来了，SPI 的接口是 Java 核心库的一部分，是由引导类加载器(Bootstrap Classloader)来加载的。SPI 的实现类是由系统类加载器(System ClassLoader)来加载的。</p>
<p>引导类加载器在加载时是无法找到 SPI 的实现类的，因为双亲委派模型中规定，引导类加载器 BootstrapClassloader 无法委派系统类加载器 AppClassLoader 来加载。这时候，该如何解决此问题？</p>
<p>线程上下文类加载由此诞生，它的出现也破坏了类加载器的双亲委派模型，使得程序可以进行逆向类加载</p>
<h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>通过名字可知，线程上下文类加载，就是当前线程所拥有的类加载器，可通过 Thread.currentThread()获取当前线程。</p>
<p>线程上下文类加载器（Thread Context ClassLoader）可以通过 java.lang.Thread 类的 setContextClassLoader()方法设置，创建线程时候未指定的话，则默认从父线程中继承。</p>
<p>那父线程中也没指定呢？那么会默认为应用程序的类加载器。例如：main 方法的线程上下文类加载器就是 sun.misc.Launcher$AppClassLoader。</p>
<p>前两篇文章中，我们讲解了类加载器的双亲委派模型，该模型的实现是通过类加载器中的 parent 属性(父加载器)来完成的，默认统一交给最上层类加载器去尝试加载。</p>
<p>那，这个线程上下文类加载器又是干啥的？</p>
<p>在介绍线程上下文类加载前，我们先了解下 Java 的 SPI 机制。</p>
<h2 id="线程上下文类加载实现"><a href="#线程上下文类加载实现" class="headerlink" title="线程上下文类加载实现"></a>线程上下文类加载实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class JVMTest6 &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] agrs) throws ClassNotFoundException &#123;</span><br><span class="line">       ClassLoader loader &#x3D; JVMTest6.class.getClassLoader();</span><br><span class="line">       System.out.println(loader); &#x2F;&#x2F;默认是应用类加载器</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;此时获得上下文类加载器：</span><br><span class="line">       ClassLoader loader2 &#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">       System.out.println(loader2);&#x2F;&#x2F;默认也是应用类加载器</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;设置为自定义类加载器：</span><br><span class="line">       Thread.currentThread().setContextClassLoader(</span><br><span class="line">               new ClassLoaderTest(&quot;d:&#x2F;&quot;));</span><br><span class="line">       System.out.println(Thread.currentThread().getContextClassLoader());</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;使用自定义类加载器加载：</span><br><span class="line">       Class c &#x3D; Thread.currentThread().getContextClassLoader().loadClass(&quot;HelloWorld&quot;);</span><br><span class="line">       System.out.println(c.getClassLoader());&#x2F;&#x2F;线程上下文类加载器</span><br><span class="line"></span><br><span class="line">       ClassLoader loader3 &#x3D; String.class.getClassLoader();</span><br><span class="line">       System.out.println(loader3);&#x2F;&#x2F;启动类加载器 &#x3D; null</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@41dee0d7</span><br><span class="line">sun.misc.Launcher$AppClassLoader@41dee0d7</span><br><span class="line">ClassLoaderTest@516a4aef</span><br><span class="line">ClassLoaderTest@516a4aef</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<h2 id="spi-具体实现："><a href="#spi-具体实现：" class="headerlink" title="spi 具体实现："></a>spi 具体实现：</h2><p>在下面代码中，通过 SPI 方式来完成 java.sql.Driver 接口实现类的类加载操作。</p>
<p>java.sql.DriverManager 包中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">    public Void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;通过SPI方式，读取META-INF&#x2F;services下文件中的类名：</span><br><span class="line">        ServiceLoader&lt;Driver&gt; loadedDrivers &#x3D; ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator driversIterator &#x3D; loadedDrivers.iterator();</span><br><span class="line">        try&#123;</span><br><span class="line">            while(driversIterator.hasNext()) &#123;</span><br><span class="line">                driversIterator.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(Throwable t) &#123;&#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>获取到 ServiceLoader 对象后，进行遍历操作，遍历出所有 META-INF/services 文件夹下的实现类名称，之后再进行 Class.forName(“”)类加载操作。类加载操作在 driversIterator.next()中完成。</p>
<p>java.util.ServiceLoader 包中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123;</span><br><span class="line">    &#x2F;&#x2F;获取线程上下文类加载器：</span><br><span class="line">    ClassLoader cl &#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">    &#x2F;&#x2F;生成ServiceLoader对象：</span><br><span class="line">    return ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service,</span><br><span class="line">                                        ClassLoader loader)&#123;</span><br><span class="line">    return new ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) &#123;</span><br><span class="line">    service &#x3D; svc;</span><br><span class="line">    loader &#x3D; cl;</span><br><span class="line">    reload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在获取 ServiceLoader 对象时，获取了此时线程上下文中的类加载器，将此类加载赋值给 ServiceLoader 类中的 loader 成员变量。在后续类加载过程中，都是使用的此类加载来完成。这一步的操作，直接打破了双亲委派模型，实现了逆向类加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    while(driversIterator.hasNext()) &#123;</span><br><span class="line">        driversIterator.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch(Throwable t) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>通过 debug 发现，driversIterator.next()方法内部会调用 Class c = Class.forName(cn, false, loader)方法进行类加载操作。而此时传递的 loader 就是之前获取的线程上下文类加载器，传递的 cn 就是 META-INF/services 文件中的具体实现类。</p>
<p>由于笔者是通过本地的 test 进行测试，所以上文中涉及到的类加载器都是 AppClassLoader 系统类加载器。</p>
<p>作者：贾博岩<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e4262536000d">https://www.jianshu.com/p/e4262536000d</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/28/sharding-core-merge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/28/sharding-core-merge/" class="post-title-link" itemprop="url">sharding-core-merge</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-10-28 12:17:30" itemprop="dateCreated datePublished" datetime="2019-10-28T12:17:30+08:00">2019-10-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-22 14:14:28" itemprop="dateModified" datetime="2020-11-22T14:14:28+08:00">2020-11-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>模块结构<br>sharding-core-merge的主要功能是利用属性<code>DatabaseType databaseType;</code>，<code>SQLRouteResult routeResult;</code>(route产生)，<code>SelectSQLStatementContext selectSQLStatementContext;</code>(preprocess产生)，<code>List&lt;QueryResult&gt; queryResults;</code>(execute模块产生)，产生MergedResult。按功能分类可以分成三个部分：</li>
</ul>
<ol>
<li>org.apache.shardingsphere.core.merge.dal。包含若干DAL操作相关的MergedResult实现类和DALMergeEngine是一个合并引擎。此引擎对外提供merge()功能,负责将DAL操作的相关结果合并，返回包内定义的MergedResult实体类。</li>
<li>org.apache.shardingsphere.core.merge.dql。包含若干DQL操作相关的MergedResult实现类和DQLMergeEngine是一个合并引擎。此引擎对外提供merge()功能,负责将DQL操作的相关结果合并，返回包内定义的MergedResult实体类。</li>
<li>org.apache.shardingsphere.core.merge。包含MergedResult和MergeEngine接口的定义。MergeEngineFactory，负责创建MergeEngine实例。TransparentMergeEngine是一个合并引擎，实现了MergeEngine接口，此方法不对queryResults进行处理，直接返回迭代流式MergeResult。</li>
</ol>
<ul>
<li>模块结构图<br><img src="/images/sharding-core-merge.png"></li>
<li>主要逻辑流程和关键类分析<br>分片执行的主要逻辑是从***MergeEngine实现类开始的。这里以DQLMergeEngine为例子，进行分析。首先判断<code>List&lt;QueryResult&gt; queryResults;</code>是否为1，如果为1则不需要处理，直接创建迭代流式归并MergedResult。否则，判断是否为orderBy或groupby，并创建相关MergedResult。最后，对分页进行处理，也就是在decorate()方法中，根据数据库类型，创建不同MergeResult。<br><img src="/images/sharding-core-merge-flow-graph.png"></li>
<li>设计模式和设计原则</li>
</ul>
<ol>
<li>简单工厂方法<br>MergeEngineFactory.newInstance（）方法，根据SQLStatement类型来创建不同的MergeEngine。具体的MergeEngine类型为：DQLMergeEngine，DALMergeEngine，TransparentMergeEngine。MergeEngineFactory的存在方便了不同类型的MergeEngine创建，调用者不再需要关心如何创建MergeEngine，而只需要把这件事交给MergeEngineFactory就行。</li>
<li>适配器模式<br>LocalMergedResultAdapter类是一个抽象类，它实现了MergedResult接口的部分方法，使得它的子类<code>ShowDatabasesMergedResult</code>和<code>ShowShardingCTLMergedResult</code>无需MergedResult接口的所有方法。当实现类和接口的方法无法完全匹配时，可以考虑使用适配器模式。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/27/sharding-sql-test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/27/sharding-sql-test/" class="post-title-link" itemprop="url">sharding-sql-test</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-10-27 14:58:30" itemprop="dateCreated datePublished" datetime="2019-10-27T14:58:30+08:00">2019-10-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-22 14:14:20" itemprop="dateModified" datetime="2020-11-22T14:14:20+08:00">2020-11-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>模块结构<br>sharding-sql-test的主要功能是对sql测试用例xml文件进行加载，生成测试用例封装在SQLCases对象中，JAXB 实现java对象与xml之间互相转换<br>。包含三个部分：</li>
</ul>
<ol>
<li>org.apache.shardingsphere.test.sql.loader。对外提供了SQL Cases的三种注册中心，里面含有SQLCasesLoader属性来读取配置文件。</li>
<li>org.apache.shardingsphere.test.sql.SQLCase。对应与xml里部分的实体类，包含属性：id,value,databaseTypes和sqlType。</li>
<li>org.apache.shardingsphere.test.sql.SQLCases。对应与xml里部分的实体类，包含属性：databaseTypes和sqlCases。</li>
<li>org.apache.shardingsphere.test.sql.SQLCaseType。定义两种SQL类型，Literal是指值已经写在sql语句中，Placeholder是指sql语句使用?来做parameter的占位符。</li>
</ol>
<ul>
<li><p>模块结构图<br><img src="/images/sharding-sql-test.png"></p>
</li>
<li><p>设计模式和设计原则</p>
</li>
</ul>
<ol>
<li>单例模式<br>EncryptSQLCasesRegistry,ShardingSQLCasesRegistry,ShardingUnsupportedSQLCasesRegistry这三个都采用了单例模式。内部只有一个属性<code>private SQLCasesLoader sqlCasesLoader;</code>用于加载测试用例文件。<br>保证一个类仅有一个实例，并提供一个访问它的全局访问点。避免一个全局使用的类频繁地创建与销毁，此外单个实例还节省了内存资源。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/26/sharding-core-entry/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/26/sharding-core-entry/" class="post-title-link" itemprop="url">sharding-core-entry</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-10-26 19:11:30" itemprop="dateCreated datePublished" datetime="2019-10-26T19:11:30+08:00">2019-10-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-22 14:14:17" itemprop="dateModified" datetime="2020-11-22T14:14:17+08:00">2020-11-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>模块结构<br>sharding-core-entry的主要功能是对sql进行分片得到SQLRouteResult，包含三个类：</li>
</ul>
<ol>
<li>BaseShardingEngine。是抽象类，对外提供SQLRouteResult shard(final String sql, final List<Object> parameters)方法。此方法是模板方法，可以将一些子算法的实现，延迟到实现类中。cloneParameters()和route()的实现就是在子类完成的。</Object></li>
<li>PreparedQueryShardingEngine。它是BaseShardingEngine的实现类，实现了cloneParameters()和route()的实现就是在子类完成的。含有属性<code>PreparedStatementRoutingEngine routingEngine;</code>，它在route()中发挥了作用。</li>
<li>SimpleQueryShardingEngine。它是BaseShardingEngine的实现类，实现了cloneParameters()和route()的实现就是在子类完成的。含有属性<code>StatementRoutingEngine routingEngine;</code>，它在route()中发挥了作用。</li>
</ol>
<ul>
<li><p>模块结构图<br><img src="/images/sharding-core-entry.png"></p>
</li>
<li><p>设计模式和设计原则</p>
</li>
</ul>
<ol>
<li>模板方法<br>BaseShardingEngine类的SQLRouteResult shard(final String sql, final List<Object> parameters)方法使用了模板方法模式，父类BaseShardingEngine定义了整个算法的骨架，让子类去实现具体的细节。route()和cloneParameters()就是留给子类自定义的细节部分，使得子类在不变更整体算法的情况下，就可以重新定义该算法的特定步骤。</Object></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/24/sharding-core-execute/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/24/sharding-core-execute/" class="post-title-link" itemprop="url">sharding-core-execute</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-10-24 19:11:30" itemprop="dateCreated datePublished" datetime="2019-10-24T19:11:30+08:00">2019-10-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-22 14:14:30" itemprop="dateModified" datetime="2020-11-22T14:14:30+08:00">2020-11-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>模块结构<br>sharding-core-execute的主要功能是将路由和改写生成的RoutingUnit对象（RoutingUnit内部含有SQLUnit），产生执行QueryResult。按功能分类可以分成四个部分：</li>
</ul>
<ol>
<li>org.apache.shardingsphere.core.execute.hook。在执行的关键操作过程中，发送事件，用于跟踪和事务。</li>
<li>org.apache.shardingsphere.core.execute.metadata。主要提供了加载获取TableMetaData的功能，主要存储表的元数据信息，如表中的列名，数据类，列是否为主键。</li>
<li>org.apache.shardingsphere.core.execute.sql。主要有两个子包：prepare和execute。prepare的作用是在执行前搜集信息，产生ShardingExecuteGroup的集合。<br>execute的作用是将ShardingExecuteGroup中StatementExecuteUnit发送到数据库进行执行。</li>
<li>org.apache.shardingsphere.core.execute。 包含ShardingExecuteEngine、SharidngExecuteCallback等重要类，是整个执行模块的核心部分。</li>
</ol>
<ul>
<li>模块结构图<br><img src="/images/sharding-core-execute.png"></li>
<li>主要逻辑流程和关键类分析<br>分片执行的主要逻辑是从sharding-jdbc-core的StatementExecutor开始的，真正执行的部分位于sharding-core-execute中，以查询为例，主要逻辑流程图如下。其中，虚线箭头表示从属关系，实线表示执行顺序。<br><img src="/images/sharding-core-execute-flow-graph.jpg"></li>
<li>设计模式和设计原则</li>
</ul>
<ol>
<li>模板方法<br>SQLExecuteCallback类的execute(final Collection statementExecuteUnits, final boolean isTrunkThread, final Map shardingExecuteDataMap)方法使用了模板方法模式，父类SQLExecuteCallback定义了整个算法的骨架，让子类去实现具体的细节。executeSQL(RouteUnit routeUnit, Statement statement, ConnectionMode connectionMode)就是留给子类自定义的细节部分，使得子类在不变更整体算法的情况下，就可以重新定义该算法的特定步骤。</li>
<li>依赖倒转原则<br>SQLExecutePrepareCallback是一个接口类。BatchPreparedStatementExecutor和PreparedStatementExecutor对与这个类有依赖，由于这个类是个接口，所以调用者可以，在使用前根据实际情况，再定义接口中的抽象方法。这种使用方式对于调用者更加灵活，可以依据场景和需求，自定义相关抽象方法。</li>
</ol>
<ul>
<li>Java编程技巧</li>
</ul>
<ol>
<li>com.google.common.collect.Lists<br>SQLExecutePrepareTemplate.getSQLExecuteGroups()方法中使用了Lists，<code>Lists.partition(sqlUnits, desiredPartitionSize);</code>，可以将原本的List切分成多个List。</li>
<li>com.google.common.util.concurrent<br>ShardingExecutorService.ShardingExecutorService(final int executorSize, final String nameFormat)方法中，使用了异步回调线程池。同时，设定了JVM关闭时线程池采用的动作。<br>在多线程编程中异步回调使得原本需要阻塞等待的异步结果，因为回调的存在而不用等待。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">executorService &#x3D; MoreExecutors.listeningDecorator(getExecutorService(executorSize, nameFormat));</span><br><span class="line">MoreExecutors.addDelayedShutdownHook(executorService, 60, TimeUnit.SECONDS);</span><br><span class="line"></span><br></pre></td></tr></table></figure>








</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
