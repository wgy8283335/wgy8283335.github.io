<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'default'
  };
</script>
<title>Hexo</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/07/gradle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/07/gradle/" class="post-title-link" itemprop="url">Gradle</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-01-07 12:00:00 / Modified: 14:12:14" itemprop="dateCreated datePublished" datetime="2021-01-07T12:00:00+08:00">2021-01-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Gradle是一门基于groovy的DSL(特定领域语言)语言，也就是说它只能在某一特定领域使用，而不通用。</p>
<h2 id="项目中gradle相关文件"><a href="#项目中gradle相关文件" class="headerlink" title="项目中gradle相关文件"></a>项目中gradle相关文件</h2><ul>
<li>.gradle gradle项目产生文件（自动编译工具产生的文件）</li>
<li>build 自动构建时生成文件的地方</li>
<li>gradle 自动完成gradle环境支持文件夹</li>
<li>build.gradle gradle 项目自动编译的配置文件</li>
<li>gradle.properties gradle 运行环境配置文件</li>
<li>setting.gradle gradle 项目的子项目包含文件</li>
<li>gradlew 自动完成 gradle 环境的linux mac 脚本，配合gradle 文件夹使用 代替gradle 命令实现自动完成gradle环境搭建,配合gradle文件夹的内容</li>
<li>gradlew.bat 自动完成 gradle 环境的windows 脚本，配合gradle 文件夹使用<br>上面两个文件会做如下几件事情  </li>
</ul>
<ol>
<li>解析 gradle/wrapper/gradle-wrapper.properties 文件，获取项目需要的 gradle 版本下载地址</li>
<li>判断本地用户目录下的 ./gradle 目录下是否存在该版本，不存在该版本，走第3点，存在走第4点</li>
<li>下载 gradle-wrapper.properties 指定版本，并解压到用户目录的下 ./gradle 文件下</li>
<li>利用 ./gradle 目录下对应的版本的 gradle 进行相应自动编译操作</li>
</ol>
<h2 id="gradle版本问题"><a href="#gradle版本问题" class="headerlink" title="gradle版本问题"></a>gradle版本问题</h2><p>gradle版本对于项目是否能够成功构建影响很大，所以一般都是在gradle文件夹中指定版本，然后gradlew脚本配合完成环境的搭建，以保证项目在任何地点构建时使用的gradle版本保持一致。</p>
<h2 id="对比maven"><a href="#对比maven" class="headerlink" title="对比maven"></a>对比maven</h2><p>Java世界中主要有三大构建工具：Ant、Maven和Gradle。经过几年的发展，Ant几乎销声匿迹、Maven也日薄西山，而Gradle的发展则如日中天。总的说来Gradle在延续了Maven的优点上，增添了更多的灵活性，如多模块构建，依赖管理等。<br>参考 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/huang0925/p/5209563.html">https://www.cnblogs.com/huang0925/p/5209563.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/04/shardingsphere-sql-parser/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/04/shardingsphere-sql-parser/" class="post-title-link" itemprop="url">shardingsphere-sql-parser</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-04 10:00:00" itemprop="dateCreated datePublished" datetime="2021-01-04T10:00:00+08:00">2021-01-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-01-11 10:31:00" itemprop="dateModified" datetime="2021-01-11T10:31:00+08:00">2021-01-11</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>结构图如下<br><img src="/images/ss/shardingsphere-sql-parser1.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/03/MIME/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/03/MIME/" class="post-title-link" itemprop="url">MIME</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-01-03 16:07:30 / Modified: 12:20:48" itemprop="dateCreated datePublished" datetime="2021-01-03T16:07:30+08:00">2021-01-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。<br>MIME 意为多目 Internet 邮件扩展，它设计的最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。然而当它被 HTTP 协议支持之后，它的意义就更为显著了。它使得 HTTP 传输的不仅是普通的文本，而变得丰富多彩。</p>
<p>我们要了解浏览器是如何处理内容的。在浏览器中显示的内容有 HTML、有 XML、有 GIF、还有 Flash ……那么，浏览器是如何区分它们，决定什么内容用什么形式来显示呢？答案是 MIME Type，也就是该资源的媒体类型。<br>媒体类型通常是通过 HTTP 协议，由 Web 服务器告知浏览器的，更准确地说，是通过 Content-Type 来表示的，例如:</p>
<p>Content-Type: text/HTML</p>
<p>表示内容是 text/HTML 类型，也就是超文本文件。为什么是“text/HTML”而不是“HTML/text”或者别的什么？MIME Type 不是个人指定的，是经过 ietf 组织协商，以 RFC 的形式作为建议的标准发布在网上的，大多数的 Web 服务器和用户代理都会支持这个规范 (顺便说一句，Email 附件的类型也是通过 MIME Type 指定的)。</p>
<p>通常只有一些在互联网上获得广泛应用的格式才会获得一个 MIME Type，如果是某个客户端自己定义的格式，一般只能以 application/x- 开头。</p>
<p>在把输出结果传送到浏览器上的时候，浏览器必须启动适当的应用程序来处理这个输出文档。这可以通过多种类型 MIME（多功能网际邮件扩充协议）来完成。在 HTTP 中，MIME 类型被定义在 Content-Type header 中。</p>
<p>例如，架设你要传送一个 Microsoft Excel 文件到客户端。那么这时的 MIME 类型就是“application/vnd.ms-excel”。在大多数实际情况中，这个文件然后将传送给 Execl 来处理（假设我们设定 Execl 为处理特殊 MIME 类型的应用程序）</p>
<p>每个 MIME 类型由两部分组成，前面是数据的大类别，例如声音 audio、图象 image 等，后面定义具体的种类。</p>
<p>常见的 MIME 类型</p>
<ul>
<li>超文本标记语言文本 .html,.html text/html</li>
<li>普通文本 .txt text/plain</li>
<li>RTF 文本 .rtf application/rtf</li>
<li>GIF 图形 .gif image/gif</li>
<li>JPEG 图形 .ipeg,.jpg image/jpeg</li>
<li>au 声音文件 .au audio/basic</li>
<li>MIDI 音乐文件 mid,.midi audio/midi,audio/x-midi</li>
<li>RealAudio 音乐文件 .ra, .ram audio/x-pn-realaudio</li>
<li>MPEG 文件 .mpg,.mpeg video/mpeg</li>
<li>AVI 文件 .avi video/x-msvideo</li>
<li>GZIP 文件 .gz application/x-gzip</li>
<li>TAR 文件 .tar application/x-tar</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/02/ORACLE%E5%AF%B9%E6%AF%94MYSQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/02/ORACLE%E5%AF%B9%E6%AF%94MYSQL/" class="post-title-link" itemprop="url">ORACLE对比MYSQL</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-01-02 21:00:00 / Modified: 15:03:44" itemprop="dateCreated datePublished" datetime="2021-01-02T21:00:00+08:00">2021-01-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ORACLE-对比-MYSQL"><a href="#ORACLE-对比-MYSQL" class="headerlink" title="ORACLE 对比 MYSQL"></a>ORACLE 对比 MYSQL</h1><h2 id="行业比对"><a href="#行业比对" class="headerlink" title="行业比对"></a>行业比对</h2><ol>
<li>Oracle 能背锅，MySQL 不能背锅。</li>
<li>Oracle 发展于传统行业，行业特点是数据量少，但是每条数据价值很高（银行账户的一笔交易记录）。Mysql 发展于互联网行业，业务特点是数量巨大，但是数据价值小（一次点击操作）。因为单条价值高，随意使用付费 ORACLE 软件也合理。</li>
<li>企业应用中使用 Oracle 时大多数业务都在数据库的存储过程中实现，而 Web 应用使用 Mysql 时很多业务逻辑是在 web 服务端上实现。</li>
<li>oracle 目前来说还是占据着主流。除了互联网之外的传统行业基本上还是用的 oracle，无论从规模还是数量上，比 sql 有着大不知道多少倍的基数，想要改弦易辙，何其难也？</li>
<li>传统行业讲究“稳”字。传统行业的数据生态是基于数据库架构搭建起来的，很多核心业务都已经牢牢绑定了 oracle 这样的重型系统，一旦改用 sql 触动了核心业务，就势必会带来安全问题，传统行业没有必要冒这个风险。（另外，这么牛叉的开源技术也不是几句话就能有的）</li>
<li>互联网行业讲究“快”字。互联网就是一场赛跑游戏，谁跑的慢谁就要挨打，所以互联网企业可以在更加纯粹的开源环境里不断试错，sql 明显更适合互联网企业的开发和创新。</li>
<li>数据完整性要求不一致。传统行业不会允许数据出现完整性、一致性的错误，比如对于互联网企业来说，微博上的评论丢了几条没有关系，但是对于传统行业来说哪怕账户上少了一分钱，就足以引起传统行业的重视。</li>
<li>数据重心不一样。Oracle 的业务数据库规模都不是很大，如果有上百台就是很大的规模了，而互联网行业里面的 MySQL 使用广泛，几百台都是很平常的事情。</li>
<li>Oracle 的产品已经做得足够好了，满足了传统行业的要求。Oracle DBA 的管理模式主要是集中式，因为业务面大，出问题的概率会更高，高级人才在性能优化这方面投入的精力更多，但对于传统行业来说并不是什么问题。</li>
<li>国内对于 MySQL 和 Oracle 使用的一个误区就是把 MySQL 当 Oracle 用，把 Oracle 当 MySQL 用。单纯比性能其实意义不大，Oracle 肯定完胜 MySQL，要比较水平扩展能力，那还是 MySQL 更加轻量。当然啦。</li>
</ol>
<h2 id="技术比对"><a href="#技术比对" class="headerlink" title="技术比对"></a>技术比对</h2><ol>
<li><p>hash join 。Oracle 引进这的时候应该是 90 年代，而今天，Mysql 还没有。这样连接性能肯定不行。当然，这个用变通解决可以绕过去。</p>
</li>
<li><p>with as 。Oracle 中可以 select 查询作为一个中间结果，然后多处引用。这个 mysql 好像最近的 8.X 才有。多土啊，这可是最有用的功能之一。</p>
</li>
<li><p>rownumber。到目前为止，mysql 还没有 row_number。这可是程序员最常用到的功能之一。当然，可以变通解决。</p>
</li>
<li><p>Ananlytic function 和 window function。 这个 Oracle 很强大（比如当前行引用前一行的值）。Mysql 基本可以说是没有（当然也可以变通解决）</p>
</li>
<li><p>Stored procedure 这个 mysql 差太远太远，基本上是步枪对机枪。Mysql 没有 role 吧？程序员得造轮子。（查了下，8.0 有了。）</p>
</li>
<li><p>ORACLE 数据库自带 oracle apex 开发。好像数据库里只有 oracle 愿意投钱搞这个。</p>
</li>
<li><p>vpd,materialized view ,workflow,geological…… 这些 mysql 或者没有或者菜，当然 oracle 也不是每个版本都有。不过这些功能并不是日常必然用到的，所以还好啦。</p>
</li>
</ol>
<p>总之，mysql 短处不少，不过，用熟了之后，大多数是可以找到变通解决方法的。比如大家诟病很多的 Hashjoin 连接，用冗余字段解决，效果肯定比 hashjoin 好。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>两种数据库出生在不同时代，ORACLE 作为商用产品是面向企业用户的，mysql 作为免费开源产品是保证一定程度上满足应用对数据库的需要，在 mysql 被 ORACLE 收购之前，功能比较简单，性能也比较一般。但在收购之后，mysql 从功能和性能上都获得了很大的提升，很多方面也在想 ORACLE 数据库看齐。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">浏览器原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-01 21:00:00" itemprop="dateCreated datePublished" datetime="2021-01-01T21:00:00+08:00">2021-01-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-01-03 11:59:48" itemprop="dateModified" datetime="2021-01-03T11:59:48+08:00">2021-01-03</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="浏览器原理"><a href="#浏览器原理" class="headerlink" title="浏览器原理"></a>浏览器原理</h1><p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/47407398">https://zhuanlan.zhihu.com/p/47407398</a><br>这里以 chrome 为例进行展示说明。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Chrome 采用多进程架构，其顶层存在一个 Browser process 用以协调浏览器的其它进程。<br><img src="/images/browser/web-brower-1.png"><br>具体说来，Chrome 的主要进程及其职责如下：</p>
<ul>
<li>Browser Process：<br>负责包括地址栏，书签栏，前进后退按钮等部分的工作；<br>负责处理浏览器的一些不可见的底层操作，比如网络请求和文件访问；</li>
<li>Renderer Process：<br>负责一个 tab 内关于网页呈现的所有事情</li>
<li>Plugin Process：<br>负责控制一个网页用到的所有插件，如 flash</li>
<li>GPU Process<br>负责处理 GPU 相关的任务<br>Chrome 还为我们提供了「任务管理器」，供我们方便的查看当前浏览器中运行的所有进程及每个进程占用的系统资源，右键单击还可以查看更多类别信息。</li>
</ul>
<h2 id="Chrome-多进程架构的优缺点"><a href="#Chrome-多进程架构的优缺点" class="headerlink" title="Chrome 多进程架构的优缺点"></a>Chrome 多进程架构的优缺点</h2><p>优点</p>
<ul>
<li>某一渲染进程出问题不会影响其他进程</li>
<li>更为安全，在系统层面上限定了不同进程的权限<br>缺点</li>
<li>由于不同进程间的内存不共享，不同进程的内存常常需要包含相同的内容。</li>
<li>为了节省内存，Chrome 限制了最多的进程数，最大进程数量由设备的内存和 CPU 能力决定，当达到这一限制时，新打开的 Tab 会共用之前同一个站点的渲染进程。</li>
</ul>
<p>Chrome 把浏览器不同程序的功能看做服务，这些服务可以方便的分割为不同的进程或者合并为一个进程。以 Broswer Process 为例，如果 Chrome 运行在强大的硬件上，它会分割不同的服务到不同的进程，这样 Chrome 整体的运行会更加稳定，但是如果 Chrome 运行在资源贫瘠的设备上，这些服务又会合并到同一个进程中运行，这样可以节省内存，示意图如下。<br><img src="/images/browser/web-brower-2.png"><br><img src="/images/browser/web-brower-3.png"></p>
<p>Site Isolation 机制从 Chrome 67 开始默认启用。这种机制允许在同一个 Tab 下的跨站 iframe 使用单独的进程来渲染，这样会更为安全。<br>Site Isolation 被大家看做里程碑式的功能， 其成功实现是多年工程努力的结果。Site Isolation 不是简单的叠加多个进程。这种机制在底层改变了 iframe 之间通信的方法，Chrome 的其它功能都需要做对应的调整，比如说 devtools 需要相应的支持，甚至 Ctrl + F 也需要支持。<br><img src="/images/browser/web-brower-4.png"></p>
<h2 id="导航过程发生了什么"><a href="#导航过程发生了什么" class="headerlink" title="导航过程发生了什么"></a>导航过程发生了什么</h2><p>也许大多数人使用 Chrome 最多的场景就是在地址栏输入关键字进行搜索或者输入地址导航到某个网站，我们来看看浏览器是怎么看待这个过程的。</p>
<p>我们知道浏览器 Tab 外的工作主要由 Browser Process 掌控，Browser Process 又对这些工作进一步划分，使用不同线程进行处理：</p>
<ul>
<li>UI thread ： 控制浏览器上的按钮及输入框；</li>
<li>network thread: 处理网络请求，从网上获取数据；</li>
<li>storage thread: 控制文件等的访问；</li>
</ul>
<p>分为以下几步：</p>
<ol>
<li><p>处理输入<br>UI thread 需要判断用户输入的是 URL 还是 query；</p>
</li>
<li><p>开始导航<br>当用户点击回车键，UI thread 通知 network thread 获取网页内容，并控制 tab 上的 spinner 展现，表示正在加载中。<br>network thread 会执行 DNS 查询，随后为请求建立 TLS 连接。如果 network thread 接收到了重定向请求头如 301，network thread 会通知 UI thread 服务器要求重定向，之后，另外一个 URL 请求会被触发。</p>
</li>
<li><p>读取响应</p>
<p>当请求响应返回的时候，network thread 会依据 Content-Type 及 MIME Type sniffing 判断响应内容的格式如果响应内容的格式是 HTML ，下一步将会把这些数据传递给 renderer process，如果是 zip 文件或者其它文件，会把相关数据传输给下载管理器。<br>Safe Browsing 检查也会在此时触发，如果域名或者请求内容匹配到已知的恶意站点，network thread 会展示一个警告页。此外 CORB 检测也会触发确保敏感数据不会被传递给渲染进程。</p>
</li>
<li><p>查找渲染进程</p>
<p>当上述所有检查完成，network thread 确信浏览器可以导航到请求网页，network thread 会通知 UI thread 数据已经准备好，UI thread 会查找到一个 renderer process 进行网页的渲染。<br>由于网络请求获取响应需要时间，这里其实还存在着一个加速方案。当 UI thread 发送 URL 请求给 network thread 时，浏览器其实已经知道了将要导航到那个站点。UI thread 会并行的预先查找和启动一个渲染进程，如果一切正常，当 network thread 接收到数据时，渲染进程已经准备就绪了，但是如果遇到重定向，准备好的渲染进程也许就不可用了，这时候就需要重启一个新的渲染进程。</p>
</li>
<li><p>确认导航</p>
<p>进过了上述过程，数据以及渲染进程都可用了， Browser Process 会给 renderer process 发送 IPC 消息来确认导航，一旦 Browser Process 收到 renderer process 的渲染确认消息，导航过程结束，页面加载过程开始。</p>
<p>此时，地址栏会更新，展示出新页面的网页信息。history tab 会更新，可通过返回键返回导航来的页面，为了让关闭 tab 或者窗口后便于恢复，这些信息会存放在硬盘中。</p>
</li>
<li><p>额外的步骤</p>
<p>一旦导航被确认，renderer process 会使用相关的资源渲染页面，下文中我们将重点介绍渲染流程。当 renderer process 渲染结束（渲染结束意味着该页面内的所有的页面，包括所有 iframe 都触发了 onload 时），会发送 IPC 信号到 Browser process， UI thread 会停止展示 tab 中的 spinner。当然上面的流程只是网页首帧渲染完成，在此之后，客户端依旧可下载额外的资源渲染出新的视图。</p>
<p>在这里我们可以明确一点，所有的 JS 代码其实都由 renderer Process 控制的，所以在你浏览网页内容的过程大部分时候不会涉及到其它的进程。不过也许你也曾经监听过 beforeunload 事件，这个事件再次涉及到 Browser Process 和 renderer Process 的交互，当当前页面关闭时（关闭 Tab ，刷新等等），Browser Process 需要通知 renderer Process 进行相关的检查，对相关事件进行处理。</p>
<p>如果导航由 renderer process 触发（比如在用户点击某链接，或者 JS 执行 <code>window.location = &quot;http://newsite.com&quot;</code> ） renderer process 会首先检查是否有 <code>beforeunload</code> 事件处理器，导航请求由 renderer process 传递给 Browser process</p>
<p>如果导航到新的网站，会启用一个新的 render process 来处理新页面的渲染，老的进程会留下来处理类似 <code>unload</code> 等事件。</p>
<p>除了上述流程，有些页面还拥有 Service Worker （服务工作线程），Service Worker 让开发者对本地缓存及判断何时从网络上获取信息有了更多的控制权，如果 Service Worker 被设置为从本地 cache 中加载数据，那么就没有必要从网上获取更多数据了。</p>
<p>值得注意的是 service worker 也是运行在渲染进程中的 JS 代码，因此对于拥有 Service Worker 的页面，上述流程有些许的不同。</p>
<p>当有 Service Worker 被注册时，其作用域会被保存，当有导航时，network thread 会在注册过的 Service Worker 的作用域中检查相关域名，如果存在对应的 Service worker，UI thread 会找到一个 renderer process 来处理相关代码，Service Worker 可能会从 cache 中加载数据，从而终止对网络的请求，也可能从网上请求新的数据。</p>
<p>如果 Service Worker 最终决定通过网上获取数据，Browser 进程 和 renderer 进程的交互其实会延后数据的请求时间 。Navigation Preload 是一种与 Service Worker 并行的加速加载资源的机制，服务端通过请求头可以识别这类请求，而做出相应的处理。</p>
</li>
</ol>
<h2 id="渲染进程是如何工作的"><a href="#渲染进程是如何工作的" class="headerlink" title="渲染进程是如何工作的"></a>渲染进程是如何工作的</h2><p>渲染进程几乎负责 Tab 内的所有事情，渲染进程的核心目的在于转换 HTML CSS JS 为用户可交互的 web 页面。渲染进程中主要包含以下线程：</p>
<ul>
<li>主线程 Main thread</li>
<li>工作线程 Worker thread</li>
<li>排版线程 Compositor thread</li>
<li>光栅线程 Raster thread</li>
</ul>
<ol>
<li>构建 DOM<br>当渲染进程接收到导航的确认信息，开始接受 HTML 数据时，主线程会解析文本字符串为 DOM。</li>
</ol>
<p>渲染 html 为 DOM 的方法由 HTML Standard 定义。</p>
<ol start="2">
<li><p>加载次级的资源</p>
<p>网页中常常包含诸如图片，CSS，JS 等额外的资源，这些资源需要从网络上或者 cache 中获取。主进程可以在构建 DOM 的过程中会逐一请求它们，为了加速 preload scanner 会同时运行，如果在 html 中存在 <code>&lt;img&gt;</code> <code>&lt;link&gt;</code> 等标签，preload scanner 会把这些请求传递给 Browser process 中的 network thread 进行相关资源的下载。</p>
</li>
<li><p>JS 的下载与执行</p>
<p>当遇到 <code>&lt;script&gt;</code> 标签时，渲染进程会停止解析 HTML，而去加载，解析和执行 JS 代码，停止解析 html 的原因在于 JS 可能会改变 DOM 的结构（使用诸如 <code>document.write()</code>等 API）。</p>
<p>不过开发者其实也有多种方式来告知浏览器应对如何应对某个资源，比如说如果在<code>&lt;script&gt;</code> 标签上添加了 <code>async</code> 或 <code>defer</code> 等属性，浏览器会异步的加载和执行 JS 代码，而不会阻塞渲染。</p>
</li>
<li><p>样式计算</p>
<p>仅仅渲染 DOM 还不足以获知页面的具体样式，主进程还会基于 CSS 选择器解析 CSS 获取每一个节点的最终的计算样式值。即使不提供任何 CSS，浏览器对每个元素也会有一个默认的样式。<br><img src="/images/browser/web-brower-9.png"></p>
</li>
<li><p>获取布局</p>
<p>想要渲染一个完整的页面，除了获知每个节点的具体样式，还需要获知每一个节点在页面上的位置，布局其实是找到所有元素的几何关系的过程。其具体过程如下：</p>
<p>通过遍历 DOM 及相关元素的计算样式，主线程会构建出包含每个元素的坐标信息及盒子大小的布局树。布局树和 DOM 树类似，但是其中只包含页面可见的元素，如果一个元素设置了 <code>display:none</code> ，这个元素不会出现在布局树上，伪元素虽然在 DOM 树上不可见，但是在布局树上是可见的。<br><img src="/images/browser/web-brower-10.png"></p>
</li>
<li><p>绘制各元素</p>
<p>即使知道了不同元素的位置及样式信息，我们还需要知道不同元素的绘制先后顺序才能正确绘制出整个页面。在绘制阶段，主线程会遍历布局树以创建绘制记录。绘制记录可以看做是记录各元素绘制先后顺序的笔记。<br><img src="/images/browser/web-brower-11.png"></p>
</li>
<li><p>合成帧</p>
<p>熟悉 PS 等绘图软件的童鞋肯定对图层这一概念不陌生，现代 Chrome 其实利用了这一概念来组合不同的层。</p>
<p>复合是一种分割页面为不同的层，并单独栅格化，随后组合为帧的技术。不同层的组合由 compositor 线程（合成器线程）完成。</p>
<p>主线程会遍历布局树来创建层树（layer tree），添加了 <code>will-change</code> CSS 属性的元素，会被看做单独的一层<br><img src="/images/browser/web-brower-5.png"></p>
<p>你可能会想给每一个元素都添加上 <code>will-change</code>，不过组合过多的层也许会比在每一帧都栅格化页面中的某些小部分更慢。为了更合理的使用层，可参考 坚持仅合成器的属性和管理层计数 。</p>
<p>一旦层树被创建，渲染顺序被确定，主线程会把这些信息通知给合成器线程，合成器线程会栅格化每一层。有的层的可以达到整个页面的大小，因此，合成器线程将它们分成多个磁贴，并将每个磁贴发送到栅格线程，栅格线程会栅格化每一个磁贴并存储在 GPU 显存中。<br><img src="/images/browser/web-brower-6.png"><br>一旦磁贴被光栅化，合成器线程会收集称为绘制四边形的磁贴信息以创建合成帧。</p>
<p>合成帧随后会通过 IPC 消息传递给浏览器进程，由于浏览器的 UI 改变或者其它拓展的渲染进程也可以添加合成帧，这些合成帧会被传递给 GPU 用以展示在屏幕上，如果滚动发生，合成器线程会创建另一个合成帧发送给 GPU。<br><img src="/images/browser/web-brower-7.png"></p>
</li>
</ol>
<h2 id="重排-重绘-动画"><a href="#重排-重绘-动画" class="headerlink" title="重排 重绘 动画"></a>重排 重绘 动画</h2><p><img src="/images/browser/web-brower-12.png"></p>
<ul>
<li><p>当改变一个元素的尺寸，位置，属性时发生重排。触发样式计算，布局，绘制记录，图层的步骤都要进行。</p>
</li>
<li><p>当改变一个元素的颜色时发生重绘。触发样式计算和绘制记录。</p>
</li>
</ul>
<h3 id="动画与-JS-的矛盾"><a href="#动画与-JS-的矛盾" class="headerlink" title="动画与 JS 的矛盾"></a>动画与 JS 的矛盾</h3><p>渲染进程中的主线程，除了执行上图的那五个操作之后，还会有 JavaScript 占用主线程。 如果主线程中有每帧都需要重排重绘的动画，那么主线程在每帧都要分一部分时间执行重排重绘。如果此时还有一个 JavaSript 来抢占主线程，那么有可能发生动画卡顿。<br><img src="/images/browser/web-brower-13.png"><br><img src="/images/browser/web-brower-14.png"></p>
<ul>
<li>方法一<br>通过使用 requestAnimationFrame()方法，可以把 js 分隔成若干片段，在每帧运行。避免了与重排重绘占用时间。React Fiber 使用了这个 API 做了很多优化。<br><img src="/images/browser/web-brower-15.png"></li>
<li>方法二<br>通过 Transform 属性，这样动画只占用合成器线程和栅格线程，不会与主线程上的 JS 冲突。<br><img src="/images/browser/web-brower-16.png"></li>
</ul>
<h2 id="浏览器对事件的处理"><a href="#浏览器对事件的处理" class="headerlink" title="浏览器对事件的处理"></a>浏览器对事件的处理</h2><p>浏览器通过对不同事件的处理来满足各种交互需求，这一部分我们一起看看从浏览器的视角，事件是什么，在此我们先主要考虑鼠标事件。</p>
<p>在浏览器的看来，用户的所有手势都是输入，鼠标滚动，悬置，点击等等都是。<br>当用户在屏幕上触发诸如 touch 等手势时，首先收到手势信息的是 Browser process， 不过 Browser process 只会感知到在哪里发生了手势，对 tab 内内容的处理是还是由渲染进程控制的。</p>
<p>事件发生时，浏览器进程会发送事件类型及相应的坐标给渲染进程，渲染进程随后找到事件对象并执行所有绑定在其上的相关事件处理函数。<br>前文中，我们提到过合成器可以独立于主线程之外通过合成栅格化层平滑的处理滚动。如果页面中没有绑定相关事件，组合器线程可以独立于主线程创建组合帧。如果页面绑定了相关事件处理器，主线程就不得不出来工作了。这时候合成器线程会怎么处理呢？</p>
<p>这里涉及到一个专业名词「理解非快速滚动区域（non-fast scrollable region）」由于执行 JS 是主线程的工作，当页面合成时，合成器线程会标记页面中绑定有事件处理器的区域为 non-fast scrollable region ，如果存在这个标注，合成器线程会把发生在此处的事件发送给主线程，如果事件不是发生在这些区域，合成器线程则会直接合成新的帧而不用等到主线程的响应。</p>
<p>** 事件的优化 **</p>
<p>一般我们屏幕的刷新速率为 60fps，但是某些事件的触发量会不止这个值，出于优化的目的，Chrome 会合并连续的事件(如 wheel, mousewheel, mousemove, pointermove, touchmove )，并延迟到下一帧渲染时候执行 。</p>
<p>而如 keydown, keyup, mouseup, mousedown, touchstart, 和 touchend 等非连续性事件则会立即被触发。<br><img src="/images/browser/web-brower-8.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/29/gRPC%E5%92%8CProtobuf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/29/gRPC%E5%92%8CProtobuf/" class="post-title-link" itemprop="url">gRPC和Protobuf</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-29 21:00:00" itemprop="dateCreated datePublished" datetime="2020-12-29T21:00:00+08:00">2020-12-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-31 14:06:44" itemprop="dateModified" datetime="2020-12-31T14:06:44+08:00">2020-12-31</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="gRPC-是什么？"><a href="#gRPC-是什么？" class="headerlink" title="gRPC 是什么？"></a>gRPC 是什么？</h1><p>参考 <a target="_blank" rel="noopener" href="http://doc.oschina.net/grpc?t=58008">http://doc.oschina.net/grpc?t=58008</a><br>在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。<br><img src="/images/grpc-protobuf/grpc1.png"><br>gRPC 客户端和服务端可以在多种环境中运行和交互 - 从 google 内部的服务器到你自己的笔记本，并且可以用任何 gRPC 支持的语言来编写。所以，你可以很容易地用 Java 创建一个 gRPC 服务端，用 Go、Python、Ruby 来创建客户端。</p>
<h1 id="使用-protocol-buffers"><a href="#使用-protocol-buffers" class="headerlink" title="使用 protocol buffers"></a>使用 protocol buffers</h1><p>gRPC 默认使用 protocol buffers，这是 Google 开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如 JSON）。正如你将在下方例子里所看到的，你用 proto files 创建 gRPC 服务，用 protocol buffers 消息类型来定义方法参数和返回类型。</p>
<h2 id="protobuf-定义服务，JAVA-实现"><a href="#protobuf-定义服务，JAVA-实现" class="headerlink" title="protobuf 定义服务，JAVA 实现"></a>protobuf 定义服务，JAVA 实现</h2><p>protobuf 的详细用法<a target="_blank" rel="noopener" href="https://blog.51cto.com/9291927/2331980">https://blog.51cto.com/9291927/2331980</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option java_package &#x3D; &quot;io.grpc.examples&quot;;</span><br><span class="line"></span><br><span class="line">package helloworld;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The greeter service definition.</span><br><span class="line">service Greeter &#123;</span><br><span class="line">  &#x2F;&#x2F; Sends a greeting</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The request message containing the user&#39;s name.</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The response message containing the greetings</span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  string message &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编译-protobuf-生成服务端接口和客户端存根"><a href="#编译-protobuf-生成服务端接口和客户端存根" class="headerlink" title="编译 protobuf 生成服务端接口和客户端存根"></a>编译 protobuf 生成服务端接口和客户端存根</h3><p>一旦定义好服务，我们可以使用 protocol buffer 编译器 protoc 来生成创建应用所需的特定客户端和服务端的代码 - 你可以生成任意 gRPC 支持的语言的代码，当然 PHP 和 Objective-C 仅支持创建客户端代码。生成的代码同时包括客户端的存根和服务端要实现的抽象接口，均包含 Greeter 所定义的方法。<br>以下类包含所有我们需要创建这个例子所有的代码：</p>
<ul>
<li>HelloRequest.java， HelloResponse.java 和其他文件包含所有 protocol buffer 用来填充、序列化和提取 HelloRequest 和 HelloReply 消息类型的代码。</li>
<li>GreeterGrpc.java， 包含 (还有其他有用的代码)：<br>Greeter 服务端需要实现的接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static interface Greeter &#123;</span><br><span class="line">    public void sayHello(Helloworld.HelloRequest request,</span><br><span class="line">    StreamObserver&lt;HelloReply&gt; responseObserver);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>客户端用来与 Greeter 服务端进行对话的 存根 类。就像你所看到的，异步存根也实现了 Greeter 接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static class GreeterStub extends AbstractStub&lt;GreeterStub&gt;</span><br><span class="line">    implements Greeter &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="写一个服务器"><a href="#写一个服务器" class="headerlink" title="写一个服务器"></a>写一个服务器</h3><p>现在让我们写点代码！首先我们将创建一个服务应用来实现服务</p>
<h4 id="服务实现"><a href="#服务实现" class="headerlink" title="服务实现"></a>服务实现</h4><p>GreeterImpl.java 准确地实现了 Greeter 服务所需要的行为。<br>正如你所见，GreeterImpl 类通过实现 sayHello 方法，实现了从 IDL 生成的 GreeterGrpc.Greeter 接口 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public  static GreeterImpl impliment Greeter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello(HelloRequest req, StreamObserver&lt;HelloReply&gt; responseObserver) &#123;</span><br><span class="line">    HelloReply reply &#x3D; HelloReply.newBuilder().setMessage(&quot;Hello &quot; + req.getName()).build();</span><br><span class="line">    responseObserver.onNext(reply);</span><br><span class="line">    responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sayHello 有两个参数：</p>
<ul>
<li>HelloRequest，请求。</li>
<li>StreamObserver<HelloReply>： 应答观察者，一个特殊的接口，服务器用应答来调用它。</HelloReply></li>
</ul>
<p>为了返回给客户端应答并且完成调用：</p>
<ul>
<li>用我们的激动人心的消息构建并填充一个在我们接口定义的 HelloReply 应答对象。</li>
<li>将 HelloReply 返回给客户端，然后表明我们已经完成了对 RPC 的处理。</li>
</ul>
<h4 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h4><p>需要提供一个 gRPC 服务的另一个主要功能是让这个服务实在在网络上可用。<br>HelloWorldServer.java 提供了以下代码作为 Java 的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* The port on which the server should run *&#x2F;</span><br><span class="line">private int port &#x3D; 50051;</span><br><span class="line">private Server server;</span><br><span class="line">private void start() throws Exception &#123;</span><br><span class="line">    server &#x3D; ServerBuilder.forPort(port)</span><br><span class="line">        .addService(GreeterGrpc.bindService(new GreeterImpl()))</span><br><span class="line">        .build()</span><br><span class="line">        .start();</span><br><span class="line">    logger.info(&quot;Server started, listening on &quot; + port);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(new Thread() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; Use stderr here since the logger may has been reset by its JVM shutdown hook.</span><br><span class="line">        System.err.println(&quot;*** shutting down gRPC server since JVM is shutting down&quot;);</span><br><span class="line">        HelloWorldServer.this.stop();</span><br><span class="line">        System.err.println(&quot;*** server shut down&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h4><p>客户端的 gRPC 非常简单。在这一步，我们将用生成的代码写一个简单的客户程序来访问我们在上一节里创建的 Greeter 服务器。<br>首先我们看一下我们如何连接 Greeter 服务器。我们需要创建一个 gRPC 频道，指定我们要连接的主机名和服务器端口。然后我们用这个频道创建存根实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final ManagedChannel channel;</span><br><span class="line">private final GreeterGrpc.GreeterBlockingStub blockingStub;</span><br><span class="line">public HelloWorldClient(String host, int port) &#123;</span><br><span class="line">    channel &#x3D; ManagedChannelBuilder.forAddress(host, port)</span><br><span class="line">        .usePlaintext(true)</span><br><span class="line">        .build();</span><br><span class="line">    blockingStub &#x3D; GreeterGrpc.newBlockingStub(channel);</span><br><span class="line">    HelloRequest req &#x3D; HelloRequest.newBuilder().setName(name).build();</span><br><span class="line">    HelloReply reply &#x3D; blockingStub.sayHello(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子里，我们创建了一个阻塞的存根。这意味着 RPC 调用要等待服务器应答，将会返回一个应答或抛出一个异常。 gRPC Java 还可以有其他种类的存根，可以向服务器发出非阻塞的调用，这种情况下应答是异步返回的。</p>
<ul>
<li>我们创建并填充一个 HelloRequest 发送给服务。</li>
<li>我们用请求调用存根的 SayHello()，如果 RPC 成功，会得到一个填充的 HelloReply ，从其中我们可以获得 greeting。</li>
</ul>
<h1 id="gRPC-进阶"><a href="#gRPC-进阶" class="headerlink" title="gRPC 进阶"></a>gRPC 进阶</h1><h2 id="在-protobuf-中定义服务"><a href="#在-protobuf-中定义服务" class="headerlink" title="在 protobuf 中定义服务"></a>在 protobuf 中定义服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option java_multiple_files &#x3D; true;</span><br><span class="line">option java_package &#x3D; &quot;io.grpc.examples.routeguide&quot;; &#x2F;&#x2F;指定java文件中的package包名</span><br><span class="line">option java_outer_classname &#x3D; &quot;RouteGuideProto&quot;;</span><br><span class="line">option objc_class_prefix &#x3D; &quot;RTG&quot;;</span><br><span class="line"></span><br><span class="line">package routeguide;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Interface exported by the server.</span><br><span class="line">service RouteGuide &#123;&#x2F;&#x2F;service用于指定服务，定义rpc方法，指定请求和相应类型</span><br><span class="line">  &#x2F;&#x2F;一个 简单 RPC ， 客户端使用存根发送请求到服务器并等待响应返回，就像平常的函数调用一样。</span><br><span class="line">  rpc GetFeature(Point) returns (Feature) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一个 服务器端流式 RPC ， 客户端发送请求到服务器，拿到一个流去读取返回的消息序列。 客户端读取返回的流，直到里面没有任何消息。从例子中可以看出，通过在 响应 类型前插入 stream 关键字，可以指定一个服务器端的流方法。</span><br><span class="line">  rpc ListFeatures(Rectangle) returns (stream Feature) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一个 客户端流式 RPC ， 客户端写入一个消息序列并将其发送到服务器，同样也是使用流。一旦 客户端完成写入消息，它等待服务器完成读取返回它的响应。通过在 请求 类型前指定 stream 关键字来指定一个客户端的流方法。</span><br><span class="line">  rpc RecordRoute(stream Point) returns (RouteSummary) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一个 双向流式 RPC 是双方使用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务器 可以以任意喜欢的顺序读写：比如， 服务器可以在写入响应前等待接收所有的客户端消息，或者可以交替 的读取和写入消息，或者其他读写的组合。 每个流中的消息顺序被预留。你可以通过在请求和响应前加 stream 关键字去制定方法的类型。</span><br><span class="line">  rpc RouteChat(stream RouteNote) returns (stream RouteNote) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">我们的 .proto 文件也包含了所有请求的 protocol buffer 消息类型定义以及在服务方法中使用的响</span><br><span class="line">应类型——比如，下面的Point消息类型：</span><br><span class="line">&#x2F;&#x2F; Points are represented as latitude-longitude pairs in the E7 representation</span><br><span class="line">&#x2F;&#x2F; (degrees multiplied by 10**7 and rounded to the nearest integer).</span><br><span class="line">&#x2F;&#x2F; Latitudes should be in the range +&#x2F;- 90 degrees and longitude should be in</span><br><span class="line">&#x2F;&#x2F; the range +&#x2F;- 180 degrees (inclusive).</span><br><span class="line">message Point &#123;</span><br><span class="line">  int32 latitude &#x3D; 1;</span><br><span class="line">  int32 longitude &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A latitude-longitude rectangle, represented as two diagonally opposite</span><br><span class="line">&#x2F;&#x2F; points &quot;lo&quot; and &quot;hi&quot;.</span><br><span class="line">message Rectangle &#123;</span><br><span class="line">  &#x2F;&#x2F; One corner of the rectangle.</span><br><span class="line">  Point lo &#x3D; 1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The other corner of the rectangle.</span><br><span class="line">  Point hi &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A feature names something at a given point.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; If a feature could not be named, the name is empty.</span><br><span class="line">message Feature &#123;</span><br><span class="line">  &#x2F;&#x2F; The name of the feature.</span><br><span class="line">  string name &#x3D; 1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The point where the feature is detected.</span><br><span class="line">  Point location &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Not used in the RPC.  Instead, this is here for the form serialized to disk.</span><br><span class="line">message FeatureDatabase &#123;</span><br><span class="line">  repeated Feature feature &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A RouteNote is a message sent while at a given point.</span><br><span class="line">message RouteNote &#123;</span><br><span class="line">  &#x2F;&#x2F; The location from which the message is sent.</span><br><span class="line">  Point location &#x3D; 1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The message to be sent.</span><br><span class="line">  string message &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A RouteSummary is received in response to a RecordRoute rpc.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; It contains the number of individual points received, the number of</span><br><span class="line">&#x2F;&#x2F; detected features, and the total distance covered as the cumulative sum of</span><br><span class="line">&#x2F;&#x2F; the distance between each point.</span><br><span class="line">message RouteSummary &#123;</span><br><span class="line">  &#x2F;&#x2F; The number of points received.</span><br><span class="line">  int32 point_count &#x3D; 1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The number of known features passed while traversing the route.</span><br><span class="line">  int32 feature_count &#x3D; 2;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The distance covered in metres.</span><br><span class="line">  int32 distance &#x3D; 3;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The duration of the traversal in seconds.</span><br><span class="line">  int32 elapsed_time &#x3D; 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成客户端和服务端代码"><a href="#生成客户端和服务端代码" class="headerlink" title="生成客户端和服务端代码"></a>生成客户端和服务端代码</h2><p>接下来我们需要从 .proto 的服务定义中生成 gRPC 客户端和服务器端的接口。我们通过 protocol buffer 的编译器 protoc 以及一个特殊的 gRPC Java 插件来完成。为了生成 gRPC 服务，你必须使用 proto3 编译器。<br>下面的类都是从我们的服务定义中生成：</p>
<ul>
<li>包含了所有填充，序列化以及获取请求和应答的消息类型的 Feature.java，Point.java， Rectangle.java 以及其它类文件。</li>
<li>RouteGuideGrpc.java 文件包含（以及其它一些有用的代码）：<ul>
<li>RouteGuide 服务器要实现的一个接口 RouteGuideGrpc.RouteGuide，其中所有的方法都定 义在 RouteGuide 服务中。</li>
<li>客户端可以用来和 RouteGuide 服务器交互的 存根 类。 异步的存根也实现了 RouteGuide 接口。</li>
</ul>
</li>
</ul>
<h2 id="创建服务器"><a href="#创建服务器" class="headerlink" title="创建服务器"></a>创建服务器</h2><p>让 RouteGuide 服务工作有两个部分：</p>
<ul>
<li>实现我们服务定义的生成的服务接口：做我们的服务的实际的“工作”。</li>
<li>运行一个 gRPC 服务器，监听来自客户端的请求并返回服务的响应。</li>
</ul>
<h3 id="实现-RouteGuide"><a href="#实现-RouteGuide" class="headerlink" title="实现 RouteGuide"></a>实现 RouteGuide</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line">public class RouteGuideServer &#123;</span><br><span class="line">  private static final Logger logger &#x3D; Logger.getLogger(RouteGuideServer.class.getName());</span><br><span class="line"></span><br><span class="line">  private final int port;</span><br><span class="line">  private final Server server;</span><br><span class="line"></span><br><span class="line">  public RouteGuideServer(int port) throws IOException &#123;</span><br><span class="line">    this(port, RouteGuideUtil.getDefaultFeaturesFile());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Create a RouteGuide server listening on &#123;@code port&#125; using &#123;@code featureFile&#125; database. *&#x2F;</span><br><span class="line">  public RouteGuideServer(int port, URL featureFile) throws IOException &#123;</span><br><span class="line">    this(ServerBuilder.forPort(port), port, RouteGuideUtil.parseFeatures(featureFile));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Create a RouteGuide server using serverBuilder as a base and features as data. *&#x2F;</span><br><span class="line">  public RouteGuideServer(ServerBuilder&lt;?&gt; serverBuilder, int port, Collection&lt;Feature&gt; features) &#123;</span><br><span class="line">    this.port &#x3D; port;</span><br><span class="line">    server &#x3D; serverBuilder.addService(new RouteGuideService(features))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Start serving requests. *&#x2F;</span><br><span class="line">  public void start() throws IOException &#123;</span><br><span class="line">    server.start();</span><br><span class="line">    logger.info(&quot;Server started, listening on &quot; + port);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(new Thread() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; Use stderr here since the logger may have been reset by its JVM shutdown hook.</span><br><span class="line">        System.err.println(&quot;*** shutting down gRPC server since JVM is shutting down&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">          RouteGuideServer.this.stop();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(&quot;*** server shut down&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Stop serving requests and shutdown resources. *&#x2F;</span><br><span class="line">  public void stop() throws InterruptedException &#123;</span><br><span class="line">    if (server !&#x3D; null) &#123;</span><br><span class="line">      server.shutdown().awaitTermination(30, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Await termination on the main thread since the grpc library uses daemon threads.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  private void blockUntilShutdown() throws InterruptedException &#123;</span><br><span class="line">    if (server !&#x3D; null) &#123;</span><br><span class="line">      server.awaitTermination();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Main method.  This comment makes the linter happy.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    RouteGuideServer server &#x3D; new RouteGuideServer(8980);</span><br><span class="line">    server.start();</span><br><span class="line">    server.blockUntilShutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 我们的服务器有一个实现了生成的 RouteGuideGrpc.Service 接口的 RouteGuideService 类：</span><br><span class="line">   *</span><br><span class="line">   * &lt;p&gt;See route_guide.proto for details of the methods.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  private static class RouteGuideService extends RouteGuideGrpc.RouteGuideImplBase &#123;</span><br><span class="line">    private final Collection&lt;Feature&gt; features;</span><br><span class="line">    private final ConcurrentMap&lt;Point, List&lt;RouteNote&gt;&gt; routeNotes &#x3D;</span><br><span class="line">        new ConcurrentHashMap&lt;Point, List&lt;RouteNote&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    RouteGuideService(Collection&lt;Feature&gt; features) &#123;</span><br><span class="line">      this.features &#x3D; features;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 简单 RPC</span><br><span class="line">     * 1. 如在我们的服务定义中指定的那样，我们组织并填充一个 Feature 应答对象返回给客户端。在这个 例子中，我们通过一个单独的私有方法checkFeature()来实现。</span><br><span class="line">     * 2. 我们使用应答观察者的 onNext() 方法返回 Feature。</span><br><span class="line">     * 3. 我们使用应答观察者的 onCompleted() 方法来指出我们已经完成了和 RPC的交互。</span><br><span class="line">     * @param request the requested location for the feature. 请求</span><br><span class="line">     * @param responseObserver the observer that will receive the feature at the requested point.一个应答的观察者，实际上是服务器调用它应答的一个特殊接口。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void getFeature(Point request, StreamObserver&lt;Feature&gt; responseObserver) &#123;</span><br><span class="line">      responseObserver.onNext(checkFeature(request));</span><br><span class="line">      responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 服务器端流式 RPC</span><br><span class="line">     * 这次我们得到了需要返回给客户端的足够多的 Feature 对象（在这个场景下，我们根据他们是否在我们的 Rectangle 请求中，从服务的特性集合中选择他们），并且使用 onNext() 方法轮流往响应观察* 者写入。最后，和简单 RPC 的例子一样，我们使用响应观察者的 onCompleted() 方法去告诉 gRPC 写入应答已完成。</span><br><span class="line">     * @param request the bounding rectangle for the requested features.</span><br><span class="line">     * @param responseObserver the observer that will receive the features.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void listFeatures(Rectangle request, StreamObserver&lt;Feature&gt; responseObserver) &#123;</span><br><span class="line">      int left &#x3D; min(request.getLo().getLongitude(), request.getHi().getLongitude());</span><br><span class="line">      int right &#x3D; max(request.getLo().getLongitude(), request.getHi().getLongitude());</span><br><span class="line">      int top &#x3D; max(request.getLo().getLatitude(), request.getHi().getLatitude());</span><br><span class="line">      int bottom &#x3D; min(request.getLo().getLatitude(), request.getHi().getLatitude());</span><br><span class="line"></span><br><span class="line">      for (Feature feature : features) &#123;</span><br><span class="line">        if (!RouteGuideUtil.exists(feature)) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int lat &#x3D; feature.getLocation().getLatitude();</span><br><span class="line">        int lon &#x3D; feature.getLocation().getLongitude();</span><br><span class="line">        if (lon &gt;&#x3D; left &amp;&amp; lon &lt;&#x3D; right &amp;&amp; lat &gt;&#x3D; bottom &amp;&amp; lat &lt;&#x3D; top) &#123;</span><br><span class="line">          responseObserver.onNext(feature);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 客户端流式 RPC</span><br><span class="line">     * 如你所见，我们的方法和前面的方法类型相似，拿到一个 StreamObserver 应答观察者参数，但是这次它返回一个 StreamObserver 以便客户端写入它的 Point。</span><br><span class="line">     * 在这个方法体中，我们返回了一个匿名 StreamObserver 实例，其中我们：</span><br><span class="line">     * 覆写了 onNext() 方法，每次客户端写入一个 Point 到消息流时，拿到特性和其它信息。</span><br><span class="line">     * 覆写了 onCompleted() 方法（在 客户端 结束写入消息时调用），用来填充和构建我们的 RouteSummary。然后我们用 RouteSummary 调用方法自己的的响应观察者的 onNext()，之后调用它的 onCompleted() 方法，结束服务器端的调用。</span><br><span class="line">     *</span><br><span class="line">     * @param responseObserver an observer to receive the response summary.</span><br><span class="line">     * @return an observer to receive the requested route points.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public StreamObserver&lt;Point&gt; recordRoute(final StreamObserver&lt;RouteSummary&gt; responseObserver) &#123;</span><br><span class="line">      return new StreamObserver&lt;Point&gt;() &#123;</span><br><span class="line">        int pointCount;</span><br><span class="line">        int featureCount;</span><br><span class="line">        int distance;</span><br><span class="line">        Point previous;</span><br><span class="line">        final long startTime &#x3D; System.nanoTime();</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(Point point) &#123;</span><br><span class="line">          pointCount++;</span><br><span class="line">          if (RouteGuideUtil.exists(checkFeature(point))) &#123;</span><br><span class="line">            featureCount++;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; For each point after the first, add the incremental distance from the previous point to</span><br><span class="line">          &#x2F;&#x2F; the total distance value.</span><br><span class="line">          if (previous !&#x3D; null) &#123;</span><br><span class="line">            distance +&#x3D; calcDistance(previous, point);</span><br><span class="line">          &#125;</span><br><span class="line">          previous &#x3D; point;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable t) &#123;</span><br><span class="line">          logger.log(Level.WARNING, &quot;recordRoute cancelled&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line">          long seconds &#x3D; NANOSECONDS.toSeconds(System.nanoTime() - startTime);</span><br><span class="line">          responseObserver.onNext(RouteSummary.newBuilder().setPointCount(pointCount)</span><br><span class="line">              .setFeatureCount(featureCount).setDistance(distance)</span><br><span class="line">              .setElapsedTime((int) seconds).build());</span><br><span class="line">          responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 双向流式RPC(与客户端流的差别主要是在responseObserver.onNext()方法的调用位置，这个调用位置位于onNext()方法中。而客户端流是在onComplete()方法中，意味着需要把客户端流处理完成后，才能调用onNext方法处理并立即结束。)</span><br><span class="line">     * 和我们的客户端流的例子一样，我们拿到和返回一个 StreamObserver 应答观察者，除了这次我们在客户端仍然写入消息到 它们的 消息流时通过我们方法的应答观察者返回值。这里读写的语法和客户端流以及服务器流方法一样。虽然每一端都会按照它们写入的顺序拿到另一端的消息，客户端和服务器都可以任意顺序读写——流的操作是互不依赖的。</span><br><span class="line">     *</span><br><span class="line">     * @param responseObserver an observer to receive the stream of previous messages.</span><br><span class="line">     * @return an observer to handle requested message&#x2F;location pairs.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public StreamObserver&lt;RouteNote&gt; routeChat(final StreamObserver&lt;RouteNote&gt; responseObserver) &#123;</span><br><span class="line">      return new StreamObserver&lt;RouteNote&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(RouteNote note) &#123;</span><br><span class="line">          List&lt;RouteNote&gt; notes &#x3D; getOrCreateNotes(note.getLocation());</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; Respond with all previous notes at this location.</span><br><span class="line">          for (RouteNote prevNote : notes.toArray(new RouteNote[0])) &#123;</span><br><span class="line">            responseObserver.onNext(prevNote);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; Now add the new note to the list</span><br><span class="line">          notes.add(note);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable t) &#123;</span><br><span class="line">          logger.log(Level.WARNING, &quot;routeChat cancelled&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line">          responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Get the notes list for the given location. If missing, create it.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private List&lt;RouteNote&gt; getOrCreateNotes(Point location) &#123;</span><br><span class="line">      List&lt;RouteNote&gt; notes &#x3D; Collections.synchronizedList(new ArrayList&lt;RouteNote&gt;());</span><br><span class="line">      List&lt;RouteNote&gt; prevNotes &#x3D; routeNotes.putIfAbsent(location, notes);</span><br><span class="line">      return prevNotes !&#x3D; null ? prevNotes : notes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Gets the feature at the given point.</span><br><span class="line">     *</span><br><span class="line">     * @param location the location to check.</span><br><span class="line">     * @return The feature object at the point. Note that an empty name indicates no feature.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Feature checkFeature(Point location) &#123;</span><br><span class="line">      for (Feature feature : features) &#123;</span><br><span class="line">        if (feature.getLocation().getLatitude() &#x3D;&#x3D; location.getLatitude()</span><br><span class="line">            &amp;&amp; feature.getLocation().getLongitude() &#x3D;&#x3D; location.getLongitude()) &#123;</span><br><span class="line">          return feature;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; No feature was found, return an unnamed feature.</span><br><span class="line">      return Feature.newBuilder().setName(&quot;&quot;).setLocation(location).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Calculate the distance between two points using the &quot;haversine&quot; formula.</span><br><span class="line">     * The formula is based on http:&#x2F;&#x2F;mathforum.org&#x2F;library&#x2F;drmath&#x2F;view&#x2F;51879.html.</span><br><span class="line">     *</span><br><span class="line">     * @param start The starting point</span><br><span class="line">     * @param end The end point</span><br><span class="line">     * @return The distance between the points in meters</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static int calcDistance(Point start, Point end) &#123;</span><br><span class="line">      int r &#x3D; 6371000; &#x2F;&#x2F; earth radius in meters</span><br><span class="line">      double lat1 &#x3D; toRadians(RouteGuideUtil.getLatitude(start));</span><br><span class="line">      double lat2 &#x3D; toRadians(RouteGuideUtil.getLatitude(end));</span><br><span class="line">      double lon1 &#x3D; toRadians(RouteGuideUtil.getLongitude(start));</span><br><span class="line">      double lon2 &#x3D; toRadians(RouteGuideUtil.getLongitude(end));</span><br><span class="line">      double deltaLat &#x3D; lat2 - lat1;</span><br><span class="line">      double deltaLon &#x3D; lon2 - lon1;</span><br><span class="line"></span><br><span class="line">      double a &#x3D; sin(deltaLat &#x2F; 2) * sin(deltaLat &#x2F; 2)</span><br><span class="line">          + cos(lat1) * cos(lat2) * sin(deltaLon &#x2F; 2) * sin(deltaLon &#x2F; 2);</span><br><span class="line">      double c &#x3D; 2 * atan2(sqrt(a), sqrt(1 - a));</span><br><span class="line"></span><br><span class="line">      return (int) (r * c);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">  gRpcServer &#x3D; NettyServerBuilder.forPort(port)</span><br><span class="line">      .addService(RouteGuideGrpc.bindService(new RouteGuideService(features)))</span><br><span class="line">      .build().start();</span><br><span class="line">  logger.info(&quot;Server started, listening on &quot; + port);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了做到这个，我们需要：</p>
<ul>
<li>创建我们服务实现类 RouteGuideService 的一个实例并且将其传给生成的 RouteGuideGrpc 类的静态方法 bindService() 去获得服务定义。</li>
<li>使用生成器的 forPort() 方法指定地址以及期望客户端请求监听的端口。</li>
<li>通过传入将 bindService() 返回的服务定义，用生成器注册我们的服务实现到生成器的 addService() 方法。</li>
<li>调用生成器上的 build() 和 start() 方法为我们的服务创建和启动一个 RPC 服务器。</li>
</ul>
<h2 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h2><h3 id="创建存根"><a href="#创建存根" class="headerlink" title="创建存根"></a>创建存根</h3><p>为了调用服务方法，我们需要首先创建一个 存根，或者两个存根：</p>
<ul>
<li>一个 阻塞/同步 存根：这意味着 RPC 调用等待服务器响应，并且要么返回应答，要么造成异常。</li>
<li>一个 非阻塞/异步 存根可以向服务器发起非阻塞调用，应答会异步返回。你可以使用异步存根去发起特定类型的流式调用。</li>
</ul>
<p>我们首先为存根创建一个 gRPC channel，指明服务器地址和我们想连接的端口号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel &#x3D; NettyChannelBuilder.forAddress(host, port)</span><br><span class="line">       .negotiationType(NegotiationType.PLAINTEXT)</span><br><span class="line">       .build();</span><br></pre></td></tr></table></figure>

<p>如你所见，我们用一个 NettyServerBuilder 构建和启动服务器。这个服务器的生成器基于 Netty 传输框架。<br>我们使用 Netty 传输框架，所以我们用一个 NettyServerBuilder 启动服务器。<br>现在我们可以通过从 .proto 中生成的 RouteGuideGrpc 类的 newStub 和 newBlockingStub 方法，使用频道去创建我们的存根。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blockingStub &#x3D; RouteGuideGrpc.newBlockingStub(channel);</span><br><span class="line">asyncStub &#x3D; RouteGuideGrpc.newStub(channel);</span><br></pre></td></tr></table></figure>

<h3 id="调用服务方法"><a href="#调用服务方法" class="headerlink" title="调用服务方法"></a>调用服务方法</h3><h4 id="简单-RPC"><a href="#简单-RPC" class="headerlink" title="简单 RPC"></a>简单 RPC</h4><p>在阻塞存根上调用简单 RPC GetFeature 几乎是和调用一个本地方法一样直观。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point request &#x3D; Point.newBuilder().setLatitude(lat).setLongitude(lon).build();</span><br><span class="line">Feature feature &#x3D; blockingStub.getFeature(request);</span><br></pre></td></tr></table></figure>

<p>我们创建和填充了一个请求 protocol buffer 对象（在这个场景下是 Point），在我们的阻塞存根上将其传给 getFeature() 方法，拿回一个 Feature。</p>
<h4 id="服务器端流式-RPC"><a href="#服务器端流式-RPC" class="headerlink" title="服务器端流式 RPC"></a>服务器端流式 RPC</h4><p>接下来，让我们看一个对于 ListFeatures 的服务器端流式调用，这个调用会返回一个地理性的 Feature 流：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rectangle request &#x3D;</span><br><span class="line">    Rectangle.newBuilder()</span><br><span class="line">        .setLo(Point.newBuilder().setLatitude(lowLat).setLongitude(lowLon).build())</span><br><span class="line">        .setHi(Point.newBuilder().setLatitude(hiLat).setLongitude(hiLon).build()).build();</span><br><span class="line">Iterator&lt;Feature&gt; features &#x3D; blockingStub.listFeatures(request);</span><br></pre></td></tr></table></figure>

<p>如你所见，这和我们刚看过的简单 RPC 很相似，除了方法返回客户端用来读取所有返回的 Feature 的 一个 Iterator，而不是单个的 Feature。</p>
<h4 id="客户端流式-RPC"><a href="#客户端流式-RPC" class="headerlink" title="客户端流式 RPC"></a>客户端流式 RPC</h4><p>现在看看稍微复杂点的东西：我们在客户端流方法 RecordRoute 中发送了一个 Point 流给服务器并且拿到一个 RouteSummary。为了这个方法，我们需要使用异步存根。如果你已经阅读了<br>创建服务器，一些部分看起来很相近——异步流式 RPC 是在两端通过相似的方式实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public void recordRoute(List&lt;Feature&gt; features, int numPoints) throws Exception &#123;</span><br><span class="line">    info(&quot;*** RecordRoute&quot;);</span><br><span class="line">    final SettableFuture&lt;Void&gt; finishFuture &#x3D; SettableFuture.create();</span><br><span class="line">    StreamObserver&lt;RouteSummary&gt; responseObserver &#x3D; new StreamObserver&lt;RouteSummary&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onNext(RouteSummary summary) &#123;</span><br><span class="line">        info(&quot;Finished trip with &#123;0&#125; points. Passed &#123;1&#125; features. &quot;</span><br><span class="line">            + &quot;Travelled &#123;2&#125; meters. It took &#123;3&#125; seconds.&quot;, summary.getPointCount(),</span><br><span class="line">            summary.getFeatureCount(), summary.getDistance(), summary.getElapsedTime());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void onError(Throwable t) &#123;</span><br><span class="line">        finishFuture.setException(t);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void onCompleted() &#123;</span><br><span class="line">        finishFuture.set(null);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    StreamObserver&lt;Point&gt; requestObserver &#x3D; asyncStub.recordRoute(responseObserver);</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; Send numPoints points randomly selected from the features list.</span><br><span class="line">      StringBuilder numMsg &#x3D; new StringBuilder();</span><br><span class="line">      Random rand &#x3D; new Random();</span><br><span class="line">      for (int i &#x3D; 0; i &lt; numPoints; ++i) &#123;</span><br><span class="line">        int index &#x3D; rand.nextInt(features.size());</span><br><span class="line">        Point point &#x3D; features.get(index).getLocation();</span><br><span class="line">        info(&quot;Visiting point &#123;0&#125;, &#123;1&#125;&quot;, RouteGuideUtil.getLatitude(point),</span><br><span class="line">            RouteGuideUtil.getLongitude(point));</span><br><span class="line">        requestObserver.onNext(point);</span><br><span class="line">        &#x2F;&#x2F; Sleep for a bit before sending the next one.</span><br><span class="line">        Thread.sleep(rand.nextInt(1000) + 500);</span><br><span class="line">        if (finishFuture.isDone()) &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      info(numMsg.toString());</span><br><span class="line">      requestObserver.onCompleted();</span><br><span class="line"></span><br><span class="line">      finishFuture.get();</span><br><span class="line">      info(&quot;Finished RecordRoute&quot;);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      requestObserver.onError(e);</span><br><span class="line">      logger.log(Level.WARNING, &quot;RecordRoute Failed&quot;, e);</span><br><span class="line">      throw e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，为了调用这个方法我们需要创建一个 StreamObserver，它为了服务器用它的 RouteSummary 应答实现了一个特殊的接口。在 StreamObserver 中，我们：</p>
<p>覆写了 onNext() 方法，在服务器把 RouteSummary 写入到消息流时，打印出返回的信息。<br>覆写了 onCompleted() 方法（在 服务器 完成自己的调用时调用）去设置 SettableFuture，这样我们可以检查服务器是不是完成写入。<br>之后，我们将 StreamObserver 传给异步存根的 recordRoute() 方法，拿到我们自己的 StreamObserver 请求观察者将 Point 发给服务器。一旦完成点的写入，我们使用请求观察者的 onCompleted() 方法告诉 gRPC 我们已经完成了客户端的写入。一旦完成，我们就检查 SettableFuture 验证服务器是否已经完成写入。</p>
<h4 id="双向流式-RPC"><a href="#双向流式-RPC" class="headerlink" title="双向流式 RPC"></a>双向流式 RPC</h4><p>最后，让我们看看双向流式 RPC RouteChat()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void routeChat() throws Exception &#123;</span><br><span class="line">    info(&quot;*** RoutChat&quot;);</span><br><span class="line">    final SettableFuture&lt;Void&gt; finishFuture &#x3D; SettableFuture.create();</span><br><span class="line">    StreamObserver&lt;RouteNote&gt; requestObserver &#x3D;</span><br><span class="line">        asyncStub.routeChat(new StreamObserver&lt;RouteNote&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void onNext(RouteNote note) &#123;</span><br><span class="line">            info(&quot;Got message \&quot;&#123;0&#125;\&quot; at &#123;1&#125;, &#123;2&#125;&quot;, note.getMessage(), note.getLocation()</span><br><span class="line">                .getLatitude(), note.getLocation().getLongitude());</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          public void onError(Throwable t) &#123;</span><br><span class="line">            finishFuture.setException(t);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          public void onCompleted() &#123;</span><br><span class="line">            finishFuture.set(null);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      RouteNote[] requests &#x3D;</span><br><span class="line">          &#123;newNote(&quot;First message&quot;, 0, 0), newNote(&quot;Second message&quot;, 0, 1),</span><br><span class="line">              newNote(&quot;Third message&quot;, 1, 0), newNote(&quot;Fourth message&quot;, 1, 1)&#125;;</span><br><span class="line"></span><br><span class="line">      for (RouteNote request : requests) &#123;</span><br><span class="line">        info(&quot;Sending message \&quot;&#123;0&#125;\&quot; at &#123;1&#125;, &#123;2&#125;&quot;, request.getMessage(), request.getLocation()</span><br><span class="line">            .getLatitude(), request.getLocation().getLongitude());</span><br><span class="line">        requestObserver.onNext(request);</span><br><span class="line">      &#125;</span><br><span class="line">      requestObserver.onCompleted();</span><br><span class="line"></span><br><span class="line">      finishFuture.get();</span><br><span class="line">      info(&quot;Finished RouteChat&quot;);</span><br><span class="line">    &#125; catch (Exception t) &#123;</span><br><span class="line">      requestObserver.onError(t);</span><br><span class="line">      logger.log(Level.WARNING, &quot;RouteChat Failed&quot;, t);</span><br><span class="line">      throw t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>和我们的客户端流的例子一样，我们拿到和返回一个 StreamObserver 应答观察者，除了这次我们在客户端仍然写入消息到 它们的 消息流时通过我们方法的应答观察者返回值。这里读写的语法和客户端流以及服务器流方法一样。虽然每一端都会按照它们写入的顺序拿到另一端的消息，客户端和服务器都可以任意顺序读写——流的操作是互不依赖的。</p>
<h1 id="ProtoBuf-存储原理"><a href="#ProtoBuf-存储原理" class="headerlink" title="ProtoBuf 存储原理"></a>ProtoBuf 存储原理</h1><p>核心是 Google 提出了“Base 128 Varints”编码,这是一种变字节长度的编码,官方描述为:varints 是用一个或多个字节序列化整形的一种方法。</p>
<h2 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h2><p>protobuf 把 message 通过一系列 key_value 对来表示。<br>Key 的算法为：(field_number &lt;&lt; 3）| wired_type<br>这里 field_number 就是具体的索引，wired_type 的值按下表查询。</p>
<table>
<thead>
<tr>
<th>wired_type</th>
<th>.proto 类型</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Varint int32, int64, uint32, uint64, sint32, sint64, bool, enum</td>
</tr>
<tr>
<td>1</td>
<td>64-bit fixed64, sfixed64, double</td>
</tr>
<tr>
<td>2</td>
<td>Length-delimited string, bytes, embedded messages, packed repeated fields</td>
</tr>
<tr>
<td>5</td>
<td>32-bit fixed32, sfixed32, float</td>
</tr>
<tr>
<td>对于 int，bool，enum 类型，value 就是 Varint。</td>
<td></td>
</tr>
</tbody></table>
<p>而对于 string，bytes，message 等等类型，value 是长度+原始内容编码。</p>
<ul>
<li><p>举例 int 类型存储(Varint 存储原理)<br>存储一个 int32 类型的数字，通常是 4 个字节。但是 Varints 最少只需要一个字节就可以了。<br>Varints 规定小于 128 的数字都可以用一个字节来表示，比如 10， 它就会用一个字节 0000 1010 来存储。<br>对于大于 128 的数字，则用更多个字节存储。<br>以 150 举例：protobuf 的存储字节是 1001 0110 0000 0001。<br>为什么会这样标识呢？首先我们了解一个字节共 8 位，表示的数字是 255，但是 Varints 只用一个字节表示小于 128 的数字，换句话说，就是 Varints 只用了 8 位中的 7 位来表示数字，而还有一位被用来干嘛了呢？<br>Varints 在官方规定中表示，每个字节的最高位是有特殊含义，当最高位为 1 的时候，代表后续的字节也是该数字的一部分。当最高位为 0 的时候，则表示结束。<br>比如过 150，二进制表示为 1001 0110。<br>先取后七位 001 0110， 作为第一个字节的内容。<br>再取余下 1 位，前面补 0 凑齐 7 位，就是 000 0001，作为第二字节。<br>对于 intel 机器，是小端字节序，低字节位于地址低的。0010110 是低字节地址，因此排在前面，因为后面的也是数字的一部分，所以高位补 1，也就成了 10010110。 同样的，高字节 000 0001，排在后面，并且它后面没有后续字节了，所以补 0，也就成了 0000 0001。<br>因此 150 在 protobuf 中的表示方式为 1001 0110 0000 0001。</p>
</li>
<li><p>举例 string 类型存储</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message Test &#123;</span><br><span class="line">required string desc &#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如把 a 设置为 “testing”的话， 那么序列化后的就是<br>12 07 74 65 73 74 69 64 67<br>其中 12 是 key。剩下的是 value。<br>怎么算的呢？先看 12， 这里的 12，是个 16 进制数字，其二进制位表示为 0001 0010。<br>0010 就是类型 string 的对应的 Type 值，根据上表，也就是 2。<br>field_number (required string desc)是 2，也就是 0010，左移三位，就成了 0001 0000。<br>按照 key 的计算公式，和 Type 值取并后就变成了 0001 0010，即 12。<br>Value 是长度加原始内容编码。<br>07 就是长度， 代表 string 总长 7 个字节。 后面 7 个数字一次代表每个字母所对应的 16 进制表示。</p>
</li>
</ul>
<h2 id="json-与-protobuf-的互转"><a href="#json-与-protobuf-的互转" class="headerlink" title="json 与 protobuf 的互转"></a>json 与 protobuf 的互转</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.google.protobuf&#x2F;protobuf-java-util --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.protobuf&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;protobuf-java-util&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.6.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>自定义的 bean 与 proto 是可以通过 Json 相互转换的，然而它们之间的转换需要第三方 JSON 转换工具和 protobuf util 的支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;to Json</span><br><span class="line">JsonFormat.Printer printer &#x3D; JsonFormat.printer();</span><br><span class="line">String print &#x3D; &quot;&quot;;</span><br><span class="line">try &#123;</span><br><span class="line">    print &#x3D; printer.print(person);</span><br><span class="line">    System.out.println(print);</span><br><span class="line">&#125; catch (InvalidProtocolBufferException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;to Object</span><br><span class="line">JsonFormat.Parser parser &#x3D; JsonFormat.parser();</span><br><span class="line">try &#123;</span><br><span class="line">    PersonProto.Person.Builder newBuilder &#x3D; PersonProto.Person.newBuilder();</span><br><span class="line">    parser.merge(print, newBuilder);</span><br><span class="line">    System.out.println(newBuilder.build());</span><br><span class="line">&#125; catch (InvalidProtocolBufferException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加java bean 此类对性数据库的字段，同时与proto类属性名相同</span><br><span class="line">public class Person implements Serializable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Boolean sex;</span><br><span class="line">    private Date dirthday;&#x2F;&#x2F;此处注意这里是时间类型而非proto类中的long类型</span><br><span class="line">    private String address;</span><br><span class="line">    private List&lt;Car&gt; cars &#x3D; new ArrayList&lt;Car&gt;();</span><br><span class="line">    private Map&lt;String, String&gt; other &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Car implements Serializable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在上面的转换中间添加以下代码,发现同样转换成功</span><br><span class="line">Person myPerson &#x3D; JsonUtil.toObject(print, Person.class);</span><br><span class="line">System.out.println(myPerson);</span><br><span class="line">print &#x3D; JsonUtil.toJson(myPerson);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/Web%E5%9F%BA%E7%A1%80+tomcat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/27/Web%E5%9F%BA%E7%A1%80+tomcat/" class="post-title-link" itemprop="url">Web基础+Tomcat</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-27 21:00:00 / Modified: 15:07:20" itemprop="dateCreated datePublished" datetime="2020-12-27T21:00:00+08:00">2020-12-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Web-基础和-tomcat"><a href="#Web-基础和-tomcat" class="headerlink" title="Web 基础和 tomcat"></a>Web 基础和 tomcat</h1><h2 id="tomcat-学艺"><a href="#tomcat-学艺" class="headerlink" title="tomcat 学艺"></a>tomcat 学艺</h2><p>JavaEE 规范：JDBC，JNDI，EJB，RMI，JSP，Servlets，XML，JMS，Java IDL，JTS，JTA，JavaMail，JAF。<br>Tomcat 只实现了俩：Servlet 和 JSP。其他服务器比如 JBoss、Weblogic 啥的都是完全支持的。所以人们往往更愿意叫 Tomcat 为轻量级的服务器，也有叫它 Servlet/JSP 容器的。所以 java 开发时不需要额外依赖 servlet 和 JSP，但是需要额外依赖 JDBC，因为 tomcat 里只实现了 Servlet 和 JSP。</p>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>服务器的主要作用:</p>
<ul>
<li>将资源对外暴露</li>
<li>配合各种传输协议进行响应输出<br>请先了解以下三个概念:</li>
<li>IP:电子设备在网络中的唯一表示，一个 IP 对应一台实体电脑。</li>
<li>端口：应用程序在计算机中的唯一标识，一个端口只能被唯一程序占用。</li>
<li>传输协议：数据传输的规则。<br>浏览器与服务器通信流程如下：<br><img src="/images/tomcat/tomcat-web-1.png"><br>实际请求时，最终还是要换算成 IP 去访问。总得来说有两种换算的途径：1.本机的 hosts 文件 2.DNS 服务器<br>DNS 解析域名得到对应的 IP 后，Request 请求里还是会带上 host。为什么？</li>
</ul>
<p>因为：域名!=IP。</p>
<p>实际上一个 IP 可以对应多个域名。也就是说一台实体服务器（大铁柜），理论上可以有多个域名（虚拟主机）。实体服务器和网站是两个概念。IP 只是对应实体服务器，而域名对应具体的网站。</p>
<p>比如上面百度服务器，虽然看起来 115.239.210.27 这个 IP 完全等同于<a href="http://www.baidu.com，但也有可能这个IP对应的服务器上配置了两个虚拟主机：www.baidu.com和tieba.baidu.com。所以即使找到了IP对应的服务器实体，Request请求还是要带上host主机名，以确定是哪个虚拟主机。">http://www.baidu.com，但也有可能这个IP对应的服务器上配置了两个虚拟主机：www.baidu.com和tieba.baidu.com。所以即使找到了IP对应的服务器实体，Request请求还是要带上host主机名，以确定是哪个虚拟主机。</a><br><img src="/images/tomcat/tomcat-web-2.png"><br>另外，如果两个域名对应同一个 IP，那么必须设置其中一个域名为默认的，不然同一台服务器有两个虚拟主机，我该访问谁？<br>已经知道 IP，就无需 DNS 解析，可直接访问服务器。若这个 IP 对应的服务器有两个虚拟主机，而用户 Request 请求行中又没有指定 host，则会访问默认主机（因此服务器要事先指定默认主机！Tomcat 默认 localhost，localhost 这个名称是一个保留域名）<br><img src="/images/tomcat/tomcat-web-3.png"><br>最后，再用 Tomcat 举个例子。比如，现在我有一台笔记本电脑（一个实体服务器），它的本机 IP 是 192.168.112.1，我在上面装了 Tomcat。如果 Tomcat 不改动配置，则默认只有一个虚拟主机 localhost（默认主机）。接着我开发了一个 JavaWeb 程序 demo1 部署到 Tomcat，然后我同事在浏览器输入下方地址。192.168.112.1:8080/demo1/index.html。访问我的电脑。虽然没有带 host，但是 localhost 是默认的，于是访问它。<br><img src="/images/tomcat/tomcat-web-4.png"></p>
<h2 id="3-个容易混淆的概念"><a href="#3-个容易混淆的概念" class="headerlink" title="3 个容易混淆的概念"></a>3 个容易混淆的概念</h2><p>其实，Tomcat 服务器 = Web 服务器 + Servlet/JSP 容器（Web 容器）。<br>Web 服务器的作用是接收客户端的请求，给客户端作出响应。但是很明显，服务器不止静态资源呀，所以客户端发起请求后，如果是动态资源，Web 服务器不可能直接把它响应回去（比如 JSP），因为浏览器只认识静态资源。所以对于 JavaWeb 程序而言，还需要 JSP/Servlet 容器，JSP/Servlet 容器的基本功能是把动态资源转换成静态资源。我们 JavaWeb 工程师需要使用 Web 服务器和 JSP/Servlet 容器，而通常这两者会集于一身，比如 Tomcat。<br><img src="/images/tomcat/tomcat-web-5.jpg"></p>
<h2 id="我们开发的-Web-应用都是半成品"><a href="#我们开发的-Web-应用都是半成品" class="headerlink" title="我们开发的 Web 应用都是半成品"></a>我们开发的 Web 应用都是半成品</h2><p>我们开发 JavaWeb 时，你操心过如何接收 HTTP 请求和响应 HTTP 请求吗？显然没有嘛！因为服务器都已经完成了。所以，我们用 Java 开发的 Web 应用只是一个半成品，类似于一个插件，而服务器则像一个收发器：<br><img src="/images/tomcat/tomcat-web-6.png"></p>
<h2 id="什么是动态资源"><a href="#什么是动态资源" class="headerlink" title="什么是动态资源"></a>什么是动态资源</h2><p>其实对于何谓动态资源，我也没有很精准的概念。要讲清楚一个东西是什么，有时是比较难的事。不如先说它不是什么。</p>
<p>首先，动态资源不等同于动态页面。所谓动态页面，就是页面会动，而会动的页面不一定是动态资源。比如我可以用 JQuery 执行一段代码，让一个 Div 不断放大缩小，但是很显然它还是一个 HTML 页面。</p>
<p>所谓动态资源，其实最显著的特征就是它能动态地生成 HTML！比如 JSP。动态资源有个“特色”：它的数据是“可拼装”的、而且“可以随时间变化”。下面用号称可以抗住 8 个明星同时出轨的新浪服务器举个例子：<br><img src="/images/tomcat/tomcat-web-7.png"></p>
<h2 id="Tomcat-架构"><a href="#Tomcat-架构" class="headerlink" title="Tomcat 架构"></a>Tomcat 架构</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><img src="/images/tomcat/tomcat-web-8.jpg"></p>
<h3 id="Tomcat-的架构"><a href="#Tomcat-的架构" class="headerlink" title="Tomcat 的架构"></a>Tomcat 的架构</h3><p><img src="/images/tomcat/tomcat-web-9.jpg"></p>
<h3 id="server-xml-配置"><a href="#server-xml-配置" class="headerlink" title="server.xml 配置"></a>server.xml 配置</h3><p><img src="/images/tomcat/tomcat-web-10.jpg"><br><img src="/images/tomcat/tomcat-web-11.jpg"><br>简略解释一下 xml 里的配置：</p>
<ul>
<li><p>Server.xml 文件中的配置结构和 Tomcat 的架构是一一对应的。根目录是<Server>，代表服务器，<Server>下面有且仅有 1 个<Service>，代表服务。<br><Service>下有两个<Connector>，代表连接（需要的话可以再加）。</Connector></Service></Service></Server></Server></p>
</li>
<li><p>其实这个 Connector 就是我们在上面讨论百度服务器时画过的端口。大家可以看到 Tomcat 默认配置了两个端口，一个是 HTTP/1.1 协议的，一个是 AJP/1.3 协议（AJP 连接器可以通过 AJP 协议和另一个 web 服务器行交互）。前者专门处理 HTTP 请求，后者可以通其他 web 服务器连接。<br><img src="/images/tomcat/tomcat-web-12.jpeg"></p>
</li>
<li><p>当我们在浏览器输入”<a target="_blank" rel="noopener" href="http://localhost:8080/demo/index.html&quot;%E6%97%B6%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E4%BB%A5HTTP%E5%8D%8F%E8%AE%AE%E5%8F%91%E9%80%81%E7%9A%84%EF%BC%8C%E5%BD%93%E8%BF%99%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%88%B0%E4%BA%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%EF%BC%8C%E4%BC%9A%E8%A2%AB%E8%AF%86%E5%88%AB%E4%B8%BAHTTP%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BA%8E%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B0%B1%E6%89%BE%E6%9D%A5%E4%B8%93%E9%97%A8%E5%A4%84%E7%90%86HTTP%E7%9A%84Connector%EF%BC%8C%E5%AE%83%E7%9A%84%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E6%AD%A3%E6%98%AF%E4%B8%8A%E9%97%A8Server.xml%E9%85%8D%E7%BD%AE%E7%9A%848080%E3%80%82">http://localhost:8080/demo/index.html&quot;时，浏览器是以HTTP协议发送的，当这个请求到了服务器后，会被识别为HTTP类型，于是服务器就找来专门处理HTTP的Connector，它的默认端口正是上门Server.xml配置的8080。</a></p>
</li>
<li><p>与 Connector 平级的还有个<Engine>（Tomcat 引擎），也就是说<Service>有两个孩子，小儿子是<Connector>，大儿子是<Engine>。Connector 的作用说穿了就是监听端口，如果用户访问地址是“localhost:8080/xx/xx”，那就由监听 8080 端口的 Connector 负责，如果是”<a target="_blank" rel="noopener" href="https://www.baidu.com&quot;,那么就是443端口处理.其实connector也不处理实际业务,它只是个孩子.但它会负责把客人(请求)带到哥哥engine那,然后engine会处理./">https://www.baidu.com&quot;，那么就是443端口处理。其实Connector也不处理实际业务，它只是个孩子。但它会负责把客人（请求）带到哥哥Engine那，然后Engine会处理。</a></Engine></Connector></Service></Engine></p>
</li>
<li><p><Engine>下面有个 Host，代表主机。一个是默认的虚拟主机 localhost,一个是虚拟主机 xxxhost。localhost 对应的 appBase 是 webapps，所以请求到达 localhost 之后，会在 webapps 文件夹下面寻找对应子目录。</Engine></p>
</li>
</ul>
<h3 id="tomcat-中的-DefaultServlet"><a href="#tomcat-中的-DefaultServlet" class="headerlink" title="tomcat 中的 DefaultServlet"></a>tomcat 中的 DefaultServlet</h3><p>实际使用 tomcat 的时候，即使没有编写 Servlet，tomcat 依然可以处理请求返回结果，是因为 tomcat 有一个 DefaultServlet。像 Tomcat 这样的 Servlet 容器来说，任何一个请求的背后肯定有个 Servlet 在默默处理：<br><img src="/images/tomcat/tomcat-web-13.png"><br>在 tomcat/conf/web.xml 中，声明了一个 DefaultServlet。我们每个动态 web 工程都有个 web.xml，而 conf 里的这个，是它们的“老爹”。它里面的配置，如果动态 web 工程没有覆盖，就会被“继承”下来。我们会发现，conf/web.xml 里配置了一个 DefaultServlet：<br><img src="/images/tomcat/tomcat-web-14.jpg"><br>DefaultServlet 的作用：最低级匹配，当没有对应的 Servlet 处理当前请求时，才轮到它处理。要么找到并响应请求的资源，要么给出 404 页面</p>
<h3 id="JSP-剖析"><a href="#JSP-剖析" class="headerlink" title="JSP 剖析"></a>JSP 剖析</h3><p>我们都知道 JSP 是“化了浓妆”的 Servlet，但是好不容易伪装成了一个 JSP，是谁帮它卸妆的呢？另外，大家仔细想想，一般来说 JavaWeb 阶段我们访问资源有三种“形式”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localhost:8080&#x2F;demo&#x2F;AServlet：很明显，我们手动写了一个AServlet处理它</span><br><span class="line">localhost:8080&#x2F;demo&#x2F;haha.html：虽然我们没写，但是Tomcat自己准备了DefaultServlet</span><br><span class="line">localhost:8080&#x2F;demo&#x2F;index.jsp：我擦，谁来处理？</span><br></pre></td></tr></table></figure>

<p>对呀，细思恐极，这*.jsp 的资源，谁来处理？其实就是 JspServlet。它的作用简而言之就是：</p>
<p>首先，根据请求路径找到 JSP<br>然后，将它“翻译成”Servlet</p>
<p>JSP 的 Servlet 也定义在 conf/web.xml。<br><img src="/images/tomcat/tomcat-web-15.png"></p>
<h3 id="tomcat-处理请求的几种方式"><a href="#tomcat-处理请求的几种方式" class="headerlink" title="tomcat 处理请求的几种方式"></a>tomcat 处理请求的几种方式</h3><p><img src="/images/tomcat/tomcat-web-16.jpg"></p>
<h3 id="tomcat-处理-http-流程"><a href="#tomcat-处理-http-流程" class="headerlink" title="tomcat 处理 http 流程"></a>tomcat 处理 http 流程</h3><p>1、用户点击网页内容，请求被发送到本机端口 8080，被在那里监听的 Coyote HTTP/1.1 Connector 获得。<br>2、Connector 把该请求交给它所在的 Service 的 Engine 来处理，并等待 Engine 的回应。<br>3、Engine 获得请求 localhost/servlet/helloServlet，匹配所有的虚拟主机 Host。<br>4、Engine 匹配到名为 localhost 的 Host（即使匹配不到也把请求交给该 Host 处理，因为该 Host 被定义为该 Engine 的默认主机），名为 localhost 的 Host 获得求/servlet/HelloServlet，匹配它所拥有的所有的 Context。Host 匹配到路径为/servlet 的 Context（如果匹配不到就把该请求交给路径名为“ ”的 Context 去处理）。<br>5、path=“/servlet”的 Context 获得请求/HelloServlet，在它的 mapping table 中寻找出对应的 Servlet。<br>6、构造 HttpServletRequest 对象和 HttpServletResponse 对象，作为参数调用 Servlet 的 doGet（）或 doPost（）.执行业务逻辑、数据存储等程序。<br>7、Context 把执行完之后的 HttpServletResponse 对象返回给 Host。<br>8、Host 把 HttpServletResponse 对象返回给 Engine。<br>9、Engine 把 HttpServletResponse 对象返回 Connector。<br>10、Connector 把 HttpServletResponse 对象返回给客户 Browser。<br><img src="/images/tomcat/tomcat-web-17.jpg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/Servlet%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/27/Servlet%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">Servlet与SpringMVC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-27 13:01:22 / Modified: 18:37:15" itemprop="dateCreated datePublished" datetime="2020-12-27T13:01:22+08:00">2020-12-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>Java Servlet 技术简称 Servlet 技术，是 Java 开发 Web 应用的底层技术。由 Sun 公司于 1996 年发布，用来代替 CGU—-当时生成 Web 动态内容的主流技术。CGI 的问题是每一个 WEB 请求都需要重新启动一个进程来处理。创建进程需要消耗不少 CPU 周期，导致难以编写刻苦鏖战的 CGI 程序，而 Servlet 在创建后（处理第一个请求时）就一直保存在内存中，这就比 CGI 有着更好的性能。</p>
<p>Servlet 是一个 Java 程序，一个 servlet 应用有一个或多个 Servlet 程序。JSP 页面会被转换和编译成 servlet 程序。</p>
<p>Servlet 程序无法独立运行，必须运行在 Servlet 容器中。Servlet 容器将用户的请求床底给 servlet 应用，并将结果返回给用户。由于大部分 Servlet 用用都包含多个 JSP 页面，因此更准确地说是“Servlet/JSP 应用”。</p>
<p>Servlet/JSP 容器是一个可以同时处理 Servlet 和静态内容的 Web 容器。过去，由于通常认为 HTTP 服务器比 Servlet/JSP 容器更加可靠，因此人们习惯将 servlet 容器当做 HTTP 服务器的一个模块，这种模式下，HTTP 服务器用来处理静态资源，Servlet 容器则负责生成动态内容。</p>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Constructor of the object.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public HelloServlet() &#123;</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Destruction of the servlet. &lt;br&gt;</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void destroy() &#123;</span><br><span class="line">		super.destroy(); &#x2F;&#x2F; Just puts &quot;destroy&quot; string in log</span><br><span class="line">		&#x2F;&#x2F; Put your code here</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * The doGet method of the servlet. &lt;br&gt;</span><br><span class="line">	 *</span><br><span class="line">	 * This method is called when a form has its tag value method equals to get.</span><br><span class="line">	 *</span><br><span class="line">	 * @param request the request send by the client to the server</span><br><span class="line">	 * @param response the response send by the server to the client</span><br><span class="line">	 * @throws ServletException if an error occurred</span><br><span class="line">	 * @throws IOException if an error occurred</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">		response.setContentType(&quot;text&#x2F;html&quot;);</span><br><span class="line">		PrintWriter out &#x3D; response.getWriter();</span><br><span class="line">		out.println(&quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN\&quot;&gt;&quot;);</span><br><span class="line">		out.println(&quot;&lt;HTML&gt;&quot;);</span><br><span class="line">		out.println(&quot;  &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;&#x2F;TITLE&gt;&lt;&#x2F;HEAD&gt;&quot;);</span><br><span class="line">		out.println(&quot;  &lt;BODY&gt;&quot;);</span><br><span class="line">		out.print(&quot;    This is &quot;);</span><br><span class="line">		out.print(this.getClass());</span><br><span class="line">		out.println(&quot;, using the GET method&quot;);</span><br><span class="line">		out.println(&quot;  &lt;&#x2F;BODY&gt;&quot;);</span><br><span class="line">		out.println(&quot;&lt;&#x2F;HTML&gt;&quot;);</span><br><span class="line">		out.flush();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * The doPost method of the servlet. &lt;br&gt;</span><br><span class="line">	 *</span><br><span class="line">	 * This method is called when a form has its tag value method equals to post.</span><br><span class="line">	 *</span><br><span class="line">	 * @param request the request send by the client to the server</span><br><span class="line">	 * @param response the response send by the server to the client</span><br><span class="line">	 * @throws ServletException if an error occurred</span><br><span class="line">	 * @throws IOException if an error occurred</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">		response.setContentType(&quot;text&#x2F;html&quot;);</span><br><span class="line">		PrintWriter out &#x3D; response.getWriter();</span><br><span class="line">		out.println(&quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN\&quot;&gt;&quot;);</span><br><span class="line">		out.println(&quot;&lt;HTML&gt;&quot;);</span><br><span class="line">		out.println(&quot;  &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;&#x2F;TITLE&gt;&lt;&#x2F;HEAD&gt;&quot;);</span><br><span class="line">		out.println(&quot;  &lt;BODY&gt;&quot;);</span><br><span class="line">		out.print(&quot;    This is &quot;);</span><br><span class="line">		out.print(this.getClass());</span><br><span class="line">		out.println(&quot;, using the POST method&quot;);</span><br><span class="line">		out.println(&quot;  &lt;&#x2F;BODY&gt;&quot;);</span><br><span class="line">		out.println(&quot;&lt;&#x2F;HTML&gt;&quot;);</span><br><span class="line">		out.flush();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Initialization of the servlet. &lt;br&gt;</span><br><span class="line">	 *</span><br><span class="line">	 * @throws ServletException if an error occurs</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void init() throws ServletException &#123;</span><br><span class="line">		&#x2F;&#x2F; Put your code here</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看见，这个 HelloServlet 继承了 HTTPServlet 类，主要有 init()、doGet（）、doPost（）、destroy()四个方法。我们在浏览器中分别用 get 和 post 访问这个 servlet。<br><img src="/images/web/servlet-1.png"><br>我们可以看到，这就是上文我们编写的 doGet 方法中的 Html 生成的页面。</p>
<h1 id="Servlet-前世今生"><a href="#Servlet-前世今生" class="headerlink" title="Servlet 前世今生"></a>Servlet 前世今生</h1><p>一个 web 请求过程：</p>
<ul>
<li>接受请求</li>
<li>处理请求</li>
<li>相应请求<br>web 服务器负责接受请求和相应请求，如果是静态资源那么 web 服务器就够用了。如果是动态资源就要处理请求，这时候就需要 servlet 了。 servlet 专门用来处理请求，编写业务逻辑。后来三层架构出现了，servlet 就把一些任务分担到 servier 和 dao，形成了 servlet(contrller)+service+dao。servlet 本身不擅长往浏览器输出 HTML 页面，所以出现了 JSP。<br>等 Spring 家族出现后，Servlet 开始退居幕后，取而代之的是 SpringMVC。SpringMVC 的核心组件 DispatcherServlet 其实本质就是一个 Servlet。但它已经自立门户，在原来 HTTPServlet 的基础上，又封装了一条逻辑。<br>Servlet 是 J2EE 规范中的一种，主要是为了扩展 java 作为 web 服务的功能，事实上，servlet 就是一个 Java 接口。<br><img src="/images/web/servlet-2.png"></li>
</ul>
<h1 id="Servlet-与-SpringMVC"><a href="#Servlet-与-SpringMVC" class="headerlink" title="Servlet 与 SpringMVC"></a>Servlet 与 SpringMVC</h1><p>参考连接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/65658315">https://zhuanlan.zhihu.com/p/65658315</a></p>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>ServletContext 对象的作用是在整个 Web 应用的动态资源（Servlet/JSP）之间共享数据。例如在 AServlet 中向 ServletContext 对象保存一个值，然后在 BServlet 中就可以获取这个值。</p>
<h2 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h2><p>这种用来装载共享数据的对象，在 JavaWeb 中共有 4 个，而且更习惯被成为“域对象”：</p>
<ul>
<li>ServletContext 域（Servlet 间共享数据）</li>
<li>Session 域（一次会话间共享数据，也可以理解为多次请求间共享数据）</li>
<li>Request 域（同一次请求共享数据）</li>
<li>Page 域（JSP 页面内共享数据）<br>它们都可以看做是 map，都有 getAttribute()/setAttribute()方法。</li>
</ul>
<h2 id="ServletContext-的方法"><a href="#ServletContext-的方法" class="headerlink" title="ServletContext 的方法"></a>ServletContext 的方法</h2><p>所以，获取 ServletContext 的方法共 5 种（page 域这里不考虑，JSP 太少用了）：</p>
<ul>
<li>ServletConfig#getServletContext();</li>
<li>GenericServlet#getServletContext();</li>
<li>HttpSession#getServletContext();</li>
<li>HttpServletRequest#getServletContext();</li>
<li>ServletContextEvent#getServletContext();</li>
</ul>
<h2 id="Filter-过滤器"><a href="#Filter-过滤器" class="headerlink" title="Filter 过滤器"></a>Filter 过滤器</h2><p>Filter 更详细的拦截其实是这样：<br>最外层那个圈，可以理解成 ServletContext，FORWARD/INCLUDE 这些都是内部请求。如果在 web.xml 中配置 Filter 时 4 种拦截方式全配上，那么服务器内部的分发跳转都会被过滤。下图中灰色的墙就是 fliter。红色字代表各种请求方式，FORWARD 和 INCLUDE 的位置相同。<br><img src="/images/web/servlet-3.png"></p>
<h2 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h2><p>对于静态资源，Tomcat 最后会交由一个叫做 DefaultServlet 的类来处理<br>对于 Servlet ，Tomcat 最后会交由一个叫做 InvokerServlet 的类来处理<br>对于 JSP，Tomcat 最后会交由一个叫做 JspServlet 的类来处理<br><img src="/images/web/servlet-5.png"></p>
<h2 id="DispatcherServlet-与-SpringMVC"><a href="#DispatcherServlet-与-SpringMVC" class="headerlink" title="DispatcherServlet 与 SpringMVC"></a>DispatcherServlet 与 SpringMVC</h2><p>tomcat 是一个 Servlet 容器，这个容器内可以存在多个 servlet，处理不同的请求。<br>加入 springmvc，它提供了一个 Servlet，可以处理.do 结尾的请求，还有静态资源的请求和其它请求。如果，我们为 springmvc 在 web.xml 配置的映射 url 为/*则代表所有请求都要走 springmvc，tomcat 中的 DefaultServlet 和 JSPServlet 都无法得到请求。因为这个两个 servlet 是在 tomcat 的 conf/web.xml 中配置的，这个 web.xml 的配置会被各个应用自己的 web.xml 覆盖，最终 tomcat 按照应用定义的 web.xml 来做映射。<br>SpringMVC 的核心控制器叫 DispatcherServlet，映射原理和我们上面山寨版的一样，因为本质还是个 Servlet。但 SpringMVC 提供了一个标签，解决上面/无法读取静态资源的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 静态资源处理  css js imgs --&gt;</span><br><span class="line">&lt;mvc:resources location&#x3D;&quot;&#x2F;resources&#x2F;**&quot; mapping&#x3D;&quot;&#x2F;resources&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>其他的我也不说了，一张图，大家体会一下 DispatcherServlet 与 SpringMVC 到底是什么关系：<br><img src="/images/web/servlet-6.jpg"><br>DispatcherServlet 确实是一个 Servlet，但它只是入口，SpringMVC 要比想象的庞大。DispatcherServlet 只是 Springmvc 的一个入口，Springmvc 内部是十分复杂的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/Servlet%E5%AF%B9%E6%AF%94CGI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/27/Servlet%E5%AF%B9%E6%AF%94CGI/" class="post-title-link" itemprop="url">Servlet与CGI</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-27 12:01:22 / Modified: 15:32:24" itemprop="dateCreated datePublished" datetime="2020-12-27T12:01:22+08:00">2020-12-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="对比-Servlt-和-CGI"><a href="#对比-Servlt-和-CGI" class="headerlink" title="对比 Servlt 和 CGI"></a>对比 Servlt 和 CGI</h1><p>java 的 servlet 实现是自己规定了一套协议，与 CGI 和 fastcgi 协议不同。<br>Servlet 与 CGI 的区别<br>对比一：当用户浏览器发出一个 Http/CGI 的请求，或者说调用一个 CGI 程序的时候，服务器端就要新启用一个进程(而且是每次都要调用)，调用 CGI 程序越多(特别是访问量高的时候)，就要消耗系统越多的处理时间，只剩下越来越少的系统资源，对于用户来说，只能是漫长的等待服务器端的返回页面了，这对于电子商务激烈发展的今天来说，不能不说是一种技术上的遗憾。</p>
<p>而 Servlet 充分发挥了服务器端的资源并高效的利用。每次调用 Servlet 时并不是新启用一个进程，而是在一个 Web 服务器的进程中共享和分离线程，而线程最大的好处在于可以共享一个数据源，使系统资源被有效利用。</p>
<p>对比二：传统的 CGI 程序，不具备平台无关性特征，系统环境发生变化，CGI 程序就要瘫痪，而 Servlet 具备 Java 的平台无关性，在系统开发过程中保持了系统的可扩展性、高效性。</p>
<p>对比三：传统技术中，一般大都为二层的系统架构，即 Web 服务器+数据库服务器，导致网站访问量大的时候，无法克服 CGI 程序与数据库建立连接时速度慢的瓶颈，从而死机、数据库死锁现象频繁发生。而 Servlet 有连接池的概念，它可以利用多线程的优点，在系统缓存中事先建立好若干与数据库的连接，到时候若想和数据库打交道可以随时跟系统”要”一个连接即可，反应速度可想而知。</p>
<p>Java Servlet 为什么不做成 FastCGI 模式？</p>
<p>1、JVM 多线程架构健壮性非常强</p>
<p>理论上多进程确实健壮性更强，但实际上，JVM 进程远比普通 C/C++进程坚固。</p>
<p>用 C/C++写程序，随便一个空指针、内存越界、内存泄漏就可能意外终止进程，更遑论很多 C/C++程序处理严重错误的方式都是很粗暴的 exit 或者 panic。</p>
<p>而用 Java 写代码，要想不小心终止进程很难。异常机制可以保证几乎没有任何 Java 代码能够直接干掉一个线程或进程，Java 程序的线程几乎跟普通 C/C++的进程一样脆弱／坚固。</p>
<p>2、Tomcat 静态文件性能并不差<br>别的 Servlet 容器不清楚，但是得益于独立的 connector 设计，较新版本的 Tomcat 有了 NIO、APR 等技术的加持，静态文件性能不会比 apache httpd 差到哪儿去。</p>
<p>“很多网站直接用 servlet 容器当 web 服务器”，因为这样很简单，而且暂时可能没遇到或不关心性能瓶颈。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/26/Tomcat%E8%BF%B7%E4%BD%A0%E7%89%88%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/26/Tomcat%E8%BF%B7%E4%BD%A0%E7%89%88%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Tomcat迷你版实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-26 23:00:00" itemprop="dateCreated datePublished" datetime="2020-12-26T23:00:00+08:00">2020-12-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-27 14:50:35" itemprop="dateModified" datetime="2020-12-27T14:50:35+08:00">2020-12-27</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Tomcat 是非常流行的 Web Server，它还是一个满足 Servlet 规范的容器。那么想一想，Tomcat 和我们的 Web 应用是什么关系？</p>
<p>从感性上来说，我们一般需要把 Web 应用打成 WAR 包部署到 Tomcat 中，在我们的 Web 应用中，我们要指明 URL 被哪个类的哪个方法所处理「不论是原始的 Servlet 开发，还是现在流行的 Spring MVC 都必须指明」。</p>
<p>由于我们的 Web 应用是运行在 Tomcat 中，请求必定是先到达 Tomcat 的。Tomcat 对于请求实际上会进行如下的处理。</p>
<p>第一，提供 Socket 服务</p>
<p>Tomcat 的启动，必然是 Socket 服务，只不过它支持 HTTP 协议而已！</p>
<p>这里其实可以扩展思考下，Tomcat 既然是基于 Socket，那么是基于 BIO or NIO or AIO 呢？</p>
<p>第二，进行请求的分发</p>
<p>要知道一个 Tomcat 可以为多个 Web 应用提供服务，很显然，Tomcat 可以把 URL 下发到不同的 Web 应用。</p>
<p>第三，需要把请求和响应封装成 request/response</p>
<p>我们在 Web 应用这一层，可从来没有封装过 request/response 的，我们都是直接使用的，这就是因为 Tomcat 已经为你做好了！</p>
<p>话不多说，先来看一眼工程截图。<br><img src="/images/tomcat/tomcat1.png"></p>
<h1 id="一、封装请求对象"><a href="#一、封装请求对象" class="headerlink" title="一、封装请求对象"></a>一、封装请求对象</h1><p><img src="/images/tomcat/tomcat2.png"><br>这里可以清楚的看到，通过输入流，对 HTTP 协议进行解析，拿到了 HTTP 请求头的方法以及 URL。</p>
<h1 id="二、封装响应对象"><a href="#二、封装响应对象" class="headerlink" title="二、封装响应对象"></a>二、封装响应对象</h1><p><img src="/images/tomcat/tomcat3.png"><br>基于 HTTP 协议的格式进行输出写入。</p>
<h1 id="三、Servlet-请求处理基类"><a href="#三、Servlet-请求处理基类" class="headerlink" title="三、Servlet 请求处理基类"></a>三、Servlet 请求处理基类</h1><p><img src="/images/tomcat/tomcat4.png"><br>前文说 Tomcat 是满足 Servlet 规范的容器，那么自然 Tomcat 需要提供 API。这里看到了 Servlet 常见的 doGet/doPost/service 方法。</p>
<p>#　四、Servlet 实现类<br><img src="/images/tomcat/tomcat5.png"><br><img src="/images/tomcat/tomcat6.png"><br>提供这 2 个具体的 Servlet 实现，只是为了后续的测试！</p>
<h1 id="五、Servlet-配置"><a href="#五、Servlet-配置" class="headerlink" title="五、Servlet 配置"></a>五、Servlet 配置</h1><p><img src="/images/tomcat/tomcat7.png"><br><img src="/images/tomcat/tomcat8.png"><br>你应该有些感觉了吧？在 servlet 开发中，会在 web.xml 中通过<servlet>和<servlet-mapping>来进行指定哪个 URL 交给哪个 servlet 进行处理。</servlet-mapping></servlet></p>
<h1 id="六、启动类"><a href="#六、启动类" class="headerlink" title="六、启动类"></a>六、启动类</h1><p><img src="/images/tomcat/tomcat9.png"><br><img src="/images/tomcat/tomcat10.png"><br><img src="/images/tomcat/tomcat11.png"><br>这里，你能够看到 Tomcat 的处理流程，即把 URL 对应处理的 Servlet 关系形成，解析 HTTP 协议，封装请求/响应对象，利用反射实例化具体的 Servlet 进行处理即可。</p>
<h1 id="七、测试"><a href="#七、测试" class="headerlink" title="七、测试"></a>七、测试</h1><p><img src="/images/tomcat/tomcat12.png"><br>实现一个简易版的 Tomcat 就这么 7 大步搞定，大家都来动手实现一下吧，代码最好不要复制，自己动手一个个敲，这样实现之后，对 Tomcat 就没那么陌生了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
