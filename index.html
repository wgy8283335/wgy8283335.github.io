<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'default'
  };
</script>
<title>Hexo</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/01/ANTLR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/01/ANTLR/" class="post-title-link" itemprop="url">Antlr相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-01 21:00:00" itemprop="dateCreated datePublished" datetime="2021-02-01T21:00:00+08:00">2021-02-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-02-23 09:29:01" itemprop="dateModified" datetime="2021-02-23T09:29:01+08:00">2021-02-23</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="实例入门"><a href="#实例入门" class="headerlink" title="实例入门"></a>实例入门</h1><p>在安装完 antlr 之后，可以编写简单的 g4 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grammar Hello;</span><br><span class="line">r:&#39;hello&#39; ID ;</span><br><span class="line">ID:[a-z]+ ;</span><br><span class="line">WS:[\t\r\n]+ -&gt; skip;</span><br></pre></td></tr></table></figure>

<p>运行如下命令</p>
<ul>
<li><code>antlr Hello.g4</code></li>
<li><code>javac *.java</code></li>
<li><code>alias grun=‘java org.antlr.v4.runtime.misc.TestRig’</code> TestRig 是一个调试工具，使用 alias 给它起了一个别名。直接执行<code>grun</code>可以得到帮助信息。</li>
<li><code>grun Hello r -tokens</code></li>
<li><code>hello parrt</code></li>
<li><code>EOF</code></li>
</ul>
<p>得到如下结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[@0,0:4&#x3D;&#39;hello&#39;,&lt;&#39;hello&#39;&gt;,1:0]</span><br><span class="line">[@1,6:10&#x3D;&#39;parrt&#39;,&lt;ID&gt;,1:6]</span><br><span class="line">[@2,12:11&#x3D;&#39;&lt;EOF&gt;&#39;,&lt;EOF&gt;,2:0]</span><br></pre></td></tr></table></figure>

<p>解析结果：比如 parrt。@1 表明该词法符号在第 2 个位置，parrt 位于第 6 个到第 10 个位置之间，词法符号类型是 ID，位于输入文本的第 1 行，第 6 个位置处。</p>
<h1 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h1><p>Antlr 依据我们定义的语法规则，产生一个递归下降的语法分析器。下降过程就是从语法分析树的根节点开始，朝着叶节点进行解析的过程。递归下降的语法分析其实际是若干方法的结合，每个方法对应一条规则。递归下降属于自上而下的语法分析器的一种实现。<br>首先调用的规则，即语义符号的起始点，就会成为语法分析树的根节点。比如：调用上面的 r()方法，作为起始点。<br>语法分析数的构造过程：识别匹配的规则，将对应规则的方法映射到语法分析树中。<br>一般规则分为：单一分支，多分支。例如：多个规则 assign，ifstat<br>单一分支，如：<code>stat: assign;</code><br>多分支，如:<code>stat: assign|ifstat;</code></p>
<h2 id="顺序解析"><a href="#顺序解析" class="headerlink" title="顺序解析"></a>顺序解析</h2><p>单一分支，只需要顺序匹配词汇符号。</p>
<h2 id="多分支解析"><a href="#多分支解析" class="headerlink" title="多分支解析"></a>多分支解析</h2><p>多分支，需要检查下一个词法符号或者多个词法符号，来决定选择哪个备选分支。这个过程成为预测或语法分析决策。<br>如果在预测过程中，发现多个分支都匹配的话，则出现了规则的定义出现了歧义，需要解决。</p>
<h2 id="歧义"><a href="#歧义" class="headerlink" title="歧义"></a>歧义</h2><p>例如下面这个语法就存在歧义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stat: expr &#39;;&#39;</span><br><span class="line">    | ID &#39;(&#39; &#39;)&#39; &#39;;&#39;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expr: ID &#39;(&#39; &#39;)&#39;</span><br><span class="line">    | INT</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>一般情况下要确保语法分析器能够选择唯一匹配的备选分支。不过当存在多个备选分支时，ANTLR 会选取备选分支中的第一条。比如本例中就会选择<code>expr &#39;;&#39;</code><br>如下存在词法歧义,begin 是一个关键字，同时也是一个标识符。<br>词法分析器会匹配最长字符串，如果输入文本 beginner 只会匹配上例中的 ID 这条词法规则。ANTLR 词法分析器不会把它匹配为关键字 BEGIN 后跟着标识符 ner</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BEGIN : &#39;begin&#39; ;</span><br><span class="line">ID    : [a-z]+ ;</span><br></pre></td></tr></table></figure>

<h2 id="语法分析树"><a href="#语法分析树" class="headerlink" title="语法分析树"></a>语法分析树</h2><p>构建应用逻辑和语法松耦合的语言类应用程序的关键在于，令语法分析器建立一颗语法分析树，然后在遍历该树的过程中触发应用逻辑代码。<br>语法分析树的建造过程：词法分析器处理字符序列并将生成的词法符号提供给语法分析器，语法分析器随即根据这些细信息来检查语法的正确性并建造出一颗语法分析树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharStream-&gt;(Lexer)-&gt;TokenStream-&gt;(Parser)-&gt;ParseTree(RuleNode子类+TerminalNode)</span><br></pre></td></tr></table></figure>

<p><img src="/images/antlr/2-2.png"><br><img src="/images/antlr/2-3.png"></p>
<p>ANTLR 使用共享数据结构节约内存，具体办法是：语法分析树中的叶子节点仅仅是盛放词法符号流中的词法符号的容器。每个词法符号都记录了自己在字符序列中的开始位置和结束位置，而非保存子字符串的拷贝。<br>ParseTree 有两个子类：RuleNode 的子类（非叶子） 和 TerminalNode（叶子）。 RuleNode 的子类包括：StatContext 和 ExprContext.Context 对象知道自己识别的词组中，开始和结束位置处的词法符号，同时提供访问该词组全部元素的方法比如 statContext 类有 ID（）和 expr()方法。有了这些方法，我们就可以遍历并操作树中节点。实际上遍历树的机制都是由 ANTLR 生成的代码</p>
<h2 id="语法分析树的访问-监听器、访问器"><a href="#语法分析树的访问-监听器、访问器" class="headerlink" title="语法分析树的访问-监听器、访问器"></a>语法分析树的访问-监听器、访问器</h2><p>为了构建一个语言类应用程序，语法分析器需要在遇到特定的输入语句、词组或者词法符号时触发特定的行为。这样的词组-&gt;行为的集合构成了我们的语言类应用程序，或者，至少担任了语法和外围程序间接口的角色。<br>监听器和访问器的区别在于，监听器方法不负责显示调用子节点的访问方法(visit())。访问器必须显式触发对子节点的访问，树的遍历过程才能正常进行，所以访问器可以控制访问的顺序以及节点被访问的次数。</p>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>ANTLR 提供了 ParseTree-Walker 类，自动遍历树然后生成事件并调用监听器。<br>每个语法文件都会生成一个 ParseTreeLisener 的子类，里面每个规则都有对应的 enter 方法和 exit 方法()，这些方法也称为”事件方法”。这些方法的入参是 ×××Context，提供该方法所需要的所有信息。监听器的操作逻辑在这些 enter 和 exit 方法内添加。下图显示了 ParseTreeWalker 对监听器方法的完整的调用顺序。<br><img src="/images/antlr/2-5.png"></p>
<h3 id="访问器"><a href="#访问器" class="headerlink" title="访问器"></a>访问器</h3><p>有时候我们希望手动控制遍历数的过程，通过显示的方法调用来访问子节点。在命令行中加入-visitor 选项可以指示 ANTLR 为一个语法生成访问器接口，语法中的每条规则对应接口中的一个 visit 方法。ANTRL 提供了访问器接口和一个默认实现类，这样我们自己只需要覆盖接口中我们感兴趣的方法。<br><img src="/images/antlr/2-6.png"></p>
<p>调用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ParseTree tree &#x3D; ...;&#x2F;&#x2F;语法分析数</span><br><span class="line">MyVisitor v &#x3D; new MyVisitor();&#x2F;&#x2F;访问器接口的实现类</span><br><span class="line">v.visit(tree);&#x2F;&#x2F;visitor访问tree</span><br></pre></td></tr></table></figure>

<h3 id="在事件方法中共享信息"><a href="#在事件方法中共享信息" class="headerlink" title="在事件方法中共享信息"></a>在事件方法中共享信息</h3><ol>
<li><p>使用访问器遍历语法分析树,使用访问器方法来返回值。优缺点：无法传递参数，访问器方法只能返回值。</p>
</li>
<li><p>使用类成员在事件方法之间共享数据，使用栈来模拟返回值。在上下文类中维护一个栈字段，以与 java 调用栈相同的方式，模拟参数和返回值的入和出栈。优缺点：手工操作栈存在失误的可能性，不过栈比较节省空间，所有局部结果的存储在树遍历完成后都会被释放。</p>
</li>
<li><p>通过对语法分析树的节点进行标注来存储相关数据，通过规则参数和返回值为节点添加字段。在上下文中维护一个 Map 字段，用对应的值来标注节点。优缺点：树标注是我个人的首选解决方案，因为它允许我向事件方法提供任意信息来操纵语法分析树中的各个节点。通过该方案，我可以传递多个任意类型的参数值。在很多情况下，标注比存储转瞬即逝的值的栈更好。使用它，在众多方法中来回传递数据也更不容易事务。这种方案的唯一缺点是，在整个遍历过程中，局部结果都会被保留，因此具有更大的内存消耗。另一方面，某些程序恰好需要标注语法分析树的方案，例如 8.4 节。该程序需要对语法分析树进行多次遍历，将第一趟遍历得到的数据完整地存储在树中是合理的，这样，第二趟遍历就能非常容易地获取这些数据。总之，对数进行标注的方案异常灵活，同时内存占用也处于可接受的范围。</p>
<ul>
<li><strong>为规则添加返回值</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e returns [int value]</span><br><span class="line">    : e &#39;*&#39; e  # Mult</span><br><span class="line">    | e &#39;+&#39; e  # Add</span><br><span class="line">    | INT      # Int</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>ANTLR 会将所有的参数和返回值放入相关的上下文对象中，这样，value 就成为 EContext 的一个字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static class AddContext extends ParserRuleContext &#123;</span><br><span class="line">    public int value;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在对监听器方法进行实现的时候，就可以按照如下方式存储值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void exitAdd(LExprParser.AddContext ctx) &#123;</span><br><span class="line">    &#x2F;&#x2F; e(0).value 是备选分支中的第一个e子表达式的值</span><br><span class="line">    ctx.value &#x3D; ctx.e(0).value + ctx.e(1).value; &#x2F;&#x2F; e &#39;+&#39; e #Add</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 ParseTreeProperty 类来存储各个节点及对应的值</strong><br>定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static class EvaluatorWithProps extends LExprBaseListener &#123;</span><br><span class="line">    &#x2F;** 使用Map&lt;ParseTree,Inteer&gt;将节点映射到对应的整数值 **&#x2F;</span><br><span class="line">    ParseTreeProperty&lt;Integer&gt; values &#x3D; new ParseTreeProperty&lt;Integer&gt;();</span><br><span class="line">    public void setValue(ParseTree node, int value) &#123; values.put(node,value);&#125;</span><br><span class="line">    public int getValue(ParseTree node) &#123;return values.get(node);&#125;</span><br><span class="line">    public void exitAdd(LExprParser.AddContext ctx) &#123;</span><br><span class="line">        int left &#x3D; getValue(ctx.e(0));</span><br><span class="line">        int right &#x3D; getValue(ctx.e(1));</span><br><span class="line">        setValue(ctx, left+right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ParseTreeWalker walker &#x3D; new ParseTreeWalker();</span><br><span class="line">EvaluatorWithProps evalProp &#x3D; new EvaluatorWithProps();</span><br><span class="line">walker.walk(evalProp, tree);</span><br><span class="line">System.out.println(&quot;properties result &#x3D; &quot;+ evalProp.getValue(tree));</span><br></pre></td></tr></table></figure>
</li>
<li><p>总结。为获取可复用的语法，我们需要使其与用户自定义的动作分离。这意味着将所有程序自身的逻辑代码放到语法之外的某种监听器或者访问器中。监听器和访问器通过操纵语法分析树来完成工作，ANTLR 会自动生成合适的接口和默认实现类，以便对语法分析树进行遍历。但是，由于事件方法的签名是固定的，无法由程序自行决定，我们找到了三种在事件方法中共享数据的方案。</p>
</li>
</ol>
<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h3><p>文件 ArrayInit.g4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 语法文件通常以grammar关键字开头</span><br><span class="line"> *  这是一个名为ArrayInit的语法，它必须和文件名ArrayInit.g4相匹配</span><br><span class="line"> *&#x2F;</span><br><span class="line">grammar ArrayInit;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;一条名为init的规则，它匹配一对花括号中的、逗号分隔的value</span><br><span class="line">init: &#39;&#123;&#39; value (&#39;,&#39; value)* &#39;)&#39;; &#x2F;&#x2F;必须匹配至少一个value。其中*号用来修饰小括号里的内容，表示任意个。</span><br><span class="line">&#x2F;&#x2F; 一个value可以是嵌套的花括号结构，也可以是一个简单的整数，即INT词法符号</span><br><span class="line">value: init</span><br><span class="line">     | INIT</span><br><span class="line">     ;</span><br><span class="line">&#x2F;&#x2F;语法分析器的规则必须以小写字母开头，词法分析器的规则必须用大写字母开头</span><br><span class="line">INT： [0-9]+;  &#x2F;&#x2F;定义词法符号INT, 它由一个或多个数字组成</span><br><span class="line">WS: [\t\r\n]+ -&gt; skip;     &#x2F;&#x2F;定义词法规则“空白符号”，丢弃之。-&gt; skip表示跳过丢弃的意思。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ANTLR 对 g4 文件解析后，会生成如下文件:ArrayInitParser.java, ArrayInitLexer.java,ArrayInit.tokens,ArrayInitLexer.tokens,ArrayInitListener.java:ArrayBaseListener.java.<br>1 ArrayInitParser.java:对应语法 ArrayInit，每条规则对应里面一个方法。<br>2 ArrayInitLexer.java:用于识别词法规则和文法规则。它是通过 ANTLR 分析词法规则 INT 和 WS，以及语法中的字面值‘{’ ‘}‘ ‘,’生成的。<br>3 ArrrayInit.tokens: ANTLR 会给每个我们定义的词法付豪指定一个数字形式的类型，然后将他们的对应关系存储于该文件中。<br>4 ArrayInitListener.java 和 ArrayBaseListener.java: 在遍历 AST 时,遍历器能够触发一系列事件，并通知我们提供的监听器对象。ArrayInitListener 接口给出了这些回调方法的定义，ArrayBaseListener 是该接口的默认实现类，为其中的每个方法提供了一个空实现。</p>
<h3 id="ANTLR-语法基本标记"><a href="#ANTLR-语法基本标记" class="headerlink" title="ANTLR 语法基本标记"></a>ANTLR 语法基本标记</h3><ul>
<li>语法包含一系列描述语言结构的规则。这些规则既包括类似 stat 和 expr 的描述语法结构的规则，也包括描述标识符和整数之类的词汇符号的规则</li>
<li>语法分析器的规则以小写字母开头</li>
<li>词法分析器的规则以大写字母开头</li>
</ul>
<h3 id="语法规则-1"><a href="#语法规则-1" class="headerlink" title="语法规则"></a>语法规则</h3><ul>
<li>我们使用|来分隔同一个语言规则的若干备选分支，使用圆括号把一些符号组合成自规则。例如，子规则(‘*‘|’/‘)匹配一个乘法符号或者触发符号。</li>
<li>使用?表达一个或 0 个，使用*表达多个或 0 个，使用+表达至少 1 个。</li>
<li>词法符号依赖，比如(),[],{}等。成对出现的符号。符号使用’’包裹起来。</li>
<li>处理嵌套模式可以使用递归规则处理，规则的定义中包含对自身的调用。有规则直接引用自身称为直接递归，规则间接引用自身称为间接递归。</li>
<li>处理优先级，左结合。ANTLR 在解析输入的语句的时候采用左结合的特性，当处理“1+2*3”的时候，就会先处理加法。这样是有问题的，解决这个问题的办法是在定义语法的时候，乘法的语法写在加法前面，这样，ANTLR 会优先匹配乘法，然后再匹配除法。</li>
<li>#标签可以标注备选分支，为每个备选分支单独生成一个监听器方法。如果没有#进行标注，则之后语法规则名对应的一个监听器方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expr: &lt;assign&#x3D;right&gt; expr &#39;^&#39; expr #Index</span><br><span class="line">      | expr &#39;*&#39; expr #Mult</span><br><span class="line">      | expr &#39;+&#39; expr #Add</span><br><span class="line">      | INT</span><br><span class="line">      ;</span><br></pre></td></tr></table></figure>

<p>但是，向指数运算这种右结合的情况，就需要使用<code>&lt;assign=right&gt;</code>单独指定。</p>
<h4 id="左递归"><a href="#左递归" class="headerlink" title="左递归"></a>左递归</h4><ul>
<li>左递归规则含义：在某个备选分支的最左侧位置，直接或间接调用了自身。例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr: INT|ID|&#39;(&#39;expr&#39;)&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>带有优先级的左递归。在面对 1+2<em>3 这样的输入是，根据优先级原则，会按照 1+(2</em>3)来处理。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expr: expr &#39;*&#39; expr</span><br><span class="line">    | expr &#39;+&#39; expr</span><br><span class="line">    | INT</span><br><span class="line">    | ID</span><br><span class="line">    ；</span><br></pre></td></tr></table></figure>

<ul>
<li>ANTLR 通过下列四种子表达式运算模式来认定一条规则为左递归规则。<ul>
<li>二元。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr: ...</span><br><span class="line">    | expr (&#39;&lt;&#39; | &#39;&gt;&#39; | &#39;&#x3D; &#39;) expr</span><br><span class="line">    ...</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure></li>
<li>三元<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr: ...</span><br><span class="line">    | expr &#39;?&#39; expr &#39;:&#39; expr</span><br><span class="line">    ...</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure></li>
<li>一元前缀<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expr:...</span><br><span class="line">    |&#39;(&#39; type &#39;)&#39; expr</span><br><span class="line">    ...</span><br><span class="line">    |(&#39;+&#39;|&#39;-&#39;|&#39;++&#39;|&#39;--&#39;) expr</span><br><span class="line">    ...</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure></li>
<li>一元后缀<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expr:...</span><br><span class="line">    |expr ‘.’ Identifier</span><br><span class="line">    ...</span><br><span class="line">    |expr &#39;.&#39; &#39;super&#39; &#39;(&#39; exprList? &#39;)&#39;</span><br><span class="line">    ...</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="词法规则"><a href="#词法规则" class="headerlink" title="词法规则"></a>词法规则</h3><ul>
<li><p>匹配标识符<code>ID: [a-zA-Z]+;</code></p>
</li>
<li><p>匹配数字<code>ID: [0-9]+;</code></p>
</li>
<li><p>匹配字符串常量。<code>STINRG: &#39;&quot;&#39; .*? &#39;&quot;&#39;</code>。点通配符匹配任意的单个字符。因此，*.就是一个循环，它匹配零个或多个字符组成的任意字符序列。显然，它可以一直匹配到文件结束，但这没有任何意义。为解决这个问题，ANTLR 通过标准正则表达式的标记‘？’，提供了对非贪婪匹配子规则的支持。非贪婪匹配的基本含义是：“获取一些字符，直到发现匹配后续子规则的字符为止”。更准确的描述是，在保证整个父规则完成匹配的前提下，非贪婪子规则匹配数量最少的字符。不过目前这个字符串不支持字符串内包含双引号。</p>
</li>
<li><p>匹配注释并丢弃。<code>COMMENT:&#39;/*&#39; ,*? &#39;*/&#39; -&gt; skip;</code>. skip 是丢弃的含义。</p>
</li>
<li><p>匹配空白字符并丢弃。 <code>WS:[\t\n\r]+ -&gt; skip</code></p>
</li>
</ul>
<h2 id="ANTLR-解析过程的异常处理"><a href="#ANTLR-解析过程的异常处理" class="headerlink" title="ANTLR 解析过程的异常处理"></a>ANTLR 解析过程的异常处理</h2><p>ANTLR 语法分析器能够自动报告语法错误并从错误中恢复继续工作。比如前一个错误的表达式，则输出错误信息。然后继续正确地解析第二个表达式。<br>ANTLR 的错误处理机制有很高的灵活性。我们可以修改输出的错误信息，捕获识别过程中的异常，甚至改变基本的异常处理策略。</p>
<h2 id="在语法和词法文件中添加动作"><a href="#在语法和词法文件中添加动作" class="headerlink" title="在语法和词法文件中添加动作"></a>在语法和词法文件中添加动作</h2><h3 id="定制语法分析"><a href="#定制语法分析" class="headerlink" title="定制语法分析"></a>定制语法分析</h3><ul>
<li>在语法中嵌入任意动作<br>我们创建一个构造器，这样我们就能传入希望提取的列号；另外，我们需要在 row 规则的”(…)+”循环中放置一些动作。<br>下面的例子，是将输入文本中的指定列显示出来。<br>详细的内容，会在第 10 章。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">grammar Rows;</span><br><span class="line"></span><br><span class="line">@parser::members &#123; &#x2F;&#x2F; add members to generated RowsParser</span><br><span class="line">int col;</span><br><span class="line">public RowsParser(TokenStream input, int col) &#123; &#x2F;&#x2F; custom constructor</span><br><span class="line">this(input);</span><br><span class="line">this.col &#x3D; col;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file: (row NL)+ ;</span><br><span class="line"></span><br><span class="line">row</span><br><span class="line">locals [int i&#x3D;0]</span><br><span class="line">: ( STUFF</span><br><span class="line">&#123;</span><br><span class="line">$i++;</span><br><span class="line">          if ( $i &#x3D;&#x3D; col ) System.out.println(\$STUFF.text);</span><br><span class="line">&#125;</span><br><span class="line">)+</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">TAB : &#39;\t&#39; -&gt; skip ; &#x2F;&#x2F; match but don&#39;t pass to the parser</span><br><span class="line">NL : &#39;\r&#39;? &#39;\n&#39; ; &#x2F;&#x2F; match and pass to the parser</span><br><span class="line">STUFF: ~[\t\r\n]+ ; &#x2F;&#x2F; match any chars except tab, newline</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用语义判定改变语法分析过程(第 11 章)<br>下面的语法用来处理一组整数”2 9 10 3 1 2 3”。第一个数字 2 代表接下来匹配两个数组 9 和 10。紧接着数字 3 告诉我们匹配接下来的三个数字。<br>我们的目标是创建一份名为 Data 的语法，将 9 和 10 分为一组，然后 1,2,3 分为一组。<br>Data 语法的关键在于一段动作，它的值是布尔类型的，称为一个语义判定:{$i&lt;=$n&gt;}?。它的值在匹配到 n 个输入整数之前保持为 true,其中 n 是 sequence<br>语法中的参数。当语义判定的值为 false 时，对应的备选分支就从语法中“消失”了，因此，它也就从生成的语法分析器中“消失”了。在本例中，语义判定的值为 false 使得”(…)*“循环终止，从 sequence 规则返回。<br><img src="/images/antlr/4-4.png"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">grammar Data;</span><br><span class="line"></span><br><span class="line">file : group+ ;</span><br><span class="line"></span><br><span class="line">group: INT sequence[$INT.int] ;</span><br><span class="line"></span><br><span class="line">sequence[int n]</span><br><span class="line">locals [int i &#x3D; 1;]</span><br><span class="line">: ( &#123;$i&lt;&#x3D;$n&#125;? INT &#123;\$i++;&#125; )\* &#x2F;&#x2F; match n integers</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">INT : [0-9]+ ; &#x2F;&#x2F; match integers</span><br><span class="line">WS : [ \t\n\r]+ -&gt; skip ; &#x2F;&#x2F; toss out all whitespace</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="定制词法分析"><a href="#定制词法分析" class="headerlink" title="定制词法分析"></a>定制词法分析</h3><ul>
<li>孤岛语法:处理相同文件中的不同格式<br>mode INSIDE 定义模式，INSIDE 模式用于识别 XML 标签，默认模式用于识别标签之外的文本。<br>-&gt;定义了动作进入到 INSIDE 模式下<br>-&gt;定义了动作 popMode，从 INSIDE 模式下退出。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">lexer grammar XMLLexer;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Default &quot;mode&quot;: Everything OUTSIDE of a tag</span><br><span class="line">OPEN : &#39;&lt;&#39; -&gt; pushMode(INSIDE) ;</span><br><span class="line">COMMENT : &#39;&lt;!--&#39; .*? &#39;--&gt;&#39; -&gt; skip ;</span><br><span class="line">EntityRef : &#39;&amp;&#39; [a-z]+ &#39;;&#39; ;</span><br><span class="line">TEXT : ~(&#39;&lt;&#39;|&#39;&amp;&#39;)+ ; &#x2F;&#x2F; match any 16 bit char minus &lt; and &amp;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------------- Everything INSIDE of a tag ---------------------</span><br><span class="line">mode INSIDE;</span><br><span class="line"></span><br><span class="line">CLOSE : &#39;&gt;&#39; -&gt; popMode ; &#x2F;&#x2F; back to default mode</span><br><span class="line">SLASH_CLOSE : &#39;&#x2F;&gt;&#39; -&gt; popMode ;</span><br><span class="line">EQUALS : &#39;&#x3D;&#39; ;</span><br><span class="line">STRING : &#39;&quot;&#39; ._? &#39;&quot;&#39; ;</span><br><span class="line">SlashName : &#39;&#x2F;&#39; Name ;</span><br><span class="line">Name : ALPHA (ALPHA|DIGIT)_ ;</span><br><span class="line">S : [ \t\r\n] -&gt; skip ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">ALPHA : [a-zA-Z] ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">DIGIT : [0-9] ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>重写输入流<br>TokenStreamRewriter 对象可以改写输入的 TokenStream。关键之处，TokenStreamRewriter 对象实际上修改的是词法符号流的“视图”而非词法符号流本身。它认为所有对修改方法的调用都只是一个“指令”，然后将这些修改放入一个队列；在未来词法符号流被重新渲染为文本时，这些修改才会被执行。在每次我们调用 getText()的时候，rewriter 对象都会执行上述队列中的指令。</p>
<p>这样的方法在源代码插桩或者重构等场合下非常有效。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class InsertSerialIDListener extends JavaBaseListener &#123;</span><br><span class="line">TokenStreamRewriter rewriter;</span><br><span class="line">public InsertSerialIDListener(TokenStream tokens) &#123;</span><br><span class="line">rewriter &#x3D; new TokenStreamRewriter(tokens);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void enterClassBody(JavaParser.ClassBodyContext ctx) &#123;</span><br><span class="line">        String field &#x3D; &quot;\n\tpublic static final long serialVersionUID &#x3D; 1L;&quot;;</span><br><span class="line">        rewriter.insertAfter(ctx.start, field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>将词法符号送入不同通道<br>忽略却保留注释和空白字符的秘诀是将这些词法符号送入一个“隐藏通道”。语法分析器只处理一个通道，因此我们可以将希望保留的词法符号送入其他通道内。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">COMMENT</span><br><span class="line">: &#39;&#x2F;_&#39; ._? &#39;_&#x2F;&#39; -&gt; channel(HIDDEN) &#x2F;&#x2F; match anything between &#x2F;_ and \*&#x2F;</span><br><span class="line">;</span><br><span class="line">WS : [ \r\t\u000C\n]+ -&gt; channel(HIDDEN)</span><br><span class="line">;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="将生成的语法分析器与-Java-程序集成，并使用监听器遍历处理"><a href="#将生成的语法分析器与-Java-程序集成，并使用监听器遍历处理" class="headerlink" title="将生成的语法分析器与 Java 程序集成，并使用监听器遍历处理"></a>将生成的语法分析器与 Java 程序集成，并使用监听器遍历处理</h2><h3 id="例子-1-1"><a href="#例子-1-1" class="headerlink" title="例子 1"></a>例子 1</h3><p>Test.java<br>此例子的目标是将 Java 中，类似{99, 3, 451}的 short 数组翻译成”\u0063\u0003\u01c3”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.antlr.v4.runtime._;</span><br><span class="line">import org.antlr.v4.runtime.tree._;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void amin(String[] args) throws Exception&#123;</span><br><span class="line">&#x2F;&#x2F;新建一个 CharStream，从标准输入读取数据</span><br><span class="line">ANTLRInputStream input &#x3D; new ANTLRInputStream(System.in);</span><br><span class="line">&#x2F;&#x2F;新建一个词法分析器，处理输入的 CharStream</span><br><span class="line">ArrayInitLexer lexer &#x3D; new ArrayInitLexer(input);</span><br><span class="line">&#x2F;&#x2F;新建一个词法符号的缓冲区，用于存储词法分析器将生成的词法符号</span><br><span class="line">CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">&#x2F;&#x2F;新建一个语法分析器，处理词法符号缓冲区中的内容</span><br><span class="line">ArrayInitParser parser &#x3D; new ArrayInitParser(tokens);</span><br><span class="line">ParseTree tree &#x3D; parser.init(); &#x2F;&#x2F;针对 init 规则，开始语法分析。因为 init 规则是这些规则中根规则，所以适合从 init 开始分析</span><br><span class="line">&#x2F;_System.out.println(tree.toStringTree(parser));&#x2F;&#x2F;用 LISP 风格打印生成的树_&#x2F;</span><br><span class="line">&#x2F;&#x2F;新建一个通用的、能够触发回调函数的语法分析树遍历器</span><br><span class="line">ParseTreeWalker walker &#x3D; new ParseTreeWalker();</span><br><span class="line">&#x2F;&#x2F;遍历语法分析过程中生成的语法分析树，触发回调</span><br><span class="line">walker.walk(new ShortToUnicodeString(), tree);</span><br><span class="line">System.out.println();&#x2F;&#x2F;翻译完成后，打印一个\n</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ShortToUnicodeString.java<br>当遍历 AST 的时候，会对监听器里的方法进行回调。ArrayInitBaseListener 实现了 ArrayInitListener 接口的每个方法，我们只需要继承 ArrayInitBaseListener 并重写自己感兴趣的方法，就可以达到目的。ShortToUnicodeString 中的方法将翻译输入数据的一部分并将结果打印出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;将类似&#123;1,2,3&#125;的 short 数组初始化语句翻译为&quot;\u0001\u0002\u0003&quot;</span><br><span class="line">public class ShortToUnicodeString extends ArrayInitBaseListener &#123;</span><br><span class="line">&#x2F;&#x2F;将&#123;翻译为&quot;</span><br><span class="line">@Override</span><br><span class="line">public void enterInit(ArrayInitParser.InitContext ctx)&#123;</span><br><span class="line">System.out.print(&#39;&quot;&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将&#125;翻译为&quot;</span><br><span class="line">@Override</span><br><span class="line">public void exitInit(ArrayInitParser.InitContext ctx)&#123;</span><br><span class="line">System.out.print(&#39;&quot;&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将每个整数翻译为四位的十六进制形式，然后加前缀\u</span><br><span class="line">@Override</span><br><span class="line">public void enterValue(ArrrayInitParser.ValueContext ctx) &#123;</span><br><span class="line">&#x2F;&#x2F;假定不存在嵌套结构</span><br><span class="line">int value &#x3D; Integer.valueOf(ctx.INT().getText());&#x2F;&#x2F;ctx 是 value 的上下文对象，它获取 INT 词法符号对应的整数值。</span><br><span class="line">System.out.printf(&quot;\\u%04x&quot;, value);&#x2F;&#x2F;输出 16 进制数，总共占 4 为，前面的空位补 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h3><p>LibExpr.g4<br>此例子用来展示，将语法词法规则分布到多个不同文件中。<br>使用 import 功能，可以将一个大的语法文件分隔成小的，然后 import 导入连到一起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">grammar LibExpr; &#x2F;&#x2F; Rename to distinguish from original</span><br><span class="line">import CommonLexerRules; &#x2F;&#x2F; includes all rules from CommonLexerRules.g4</span><br><span class="line">&#x2F;\*_ The start rule; begin parsing here. _&#x2F;</span><br><span class="line">prog: stat+ ;</span><br><span class="line"></span><br><span class="line">stat: expr NEWLINE</span><br><span class="line">| ID &#39;&#x3D;&#39; expr NEWLINE</span><br><span class="line">| NEWLINE</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr: expr (&#39;\*&#39;|&#39;&#x2F;&#39;) expr &#x2F;&#x2F;左递归</span><br><span class="line">| expr (&#39;+&#39;|&#39;-&#39;) expr</span><br><span class="line">| INT</span><br><span class="line">| ID</span><br><span class="line">| &#39;(&#39; expr &#39;)&#39;</span><br><span class="line">;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>CommonLexerRules.g4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">lexer grammar CommonLexerRules; &#x2F;&#x2F; note &quot;lexer grammar&quot;</span><br><span class="line"></span><br><span class="line">ID : [a-zA-Z]+ ; &#x2F;&#x2F; match identifiers</span><br><span class="line">INT : [0-9]+ ; &#x2F;&#x2F; match integers</span><br><span class="line">NEWLINE:&#39;\r&#39;? &#39;\n&#39; ; &#x2F;&#x2F; return newlines to parser (end-statement signal)</span><br><span class="line">WS : [ \t]+ -&gt; skip ; &#x2F;&#x2F; toss out whitespace. &#39;-&gt; skip&#39;是丢弃操作。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ExprJoyRide.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.antlr.v4.runtime._;</span><br><span class="line">import org.antlr.v4.runtime.tree._;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">public class ExprJoyRide &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F;新建输入流</span><br><span class="line">String inputFile &#x3D; null;</span><br><span class="line">if ( args.length&gt;0 ) inputFile &#x3D; args[0];</span><br><span class="line">InputStream is &#x3D; System.in;</span><br><span class="line">if ( inputFile!&#x3D;null ) is &#x3D; new FileInputStream(inputFile);</span><br><span class="line">ANTLRInputStream input &#x3D; new ANTLRInputStream(is);</span><br><span class="line">&#x2F;&#x2F;新建词法分析器和语法分析器</span><br><span class="line">ExprLexer lexer &#x3D; new ExprLexer(input);</span><br><span class="line">CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">ExprParser parser &#x3D; new ExprParser(tokens);</span><br><span class="line">&#x2F;&#x2F;启动语法分析器开始解析</span><br><span class="line">ParseTree tree &#x3D; parser.prog();</span><br><span class="line">&#x2F;&#x2F;用文本形式将该规则方法 prog()返回的语法分析树打印出来</span><br><span class="line">System.out.println(tree.toStringTree(parser));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="例子-3-访问器"><a href="#例子-3-访问器" class="headerlink" title="例子 3 访问器"></a>例子 3 访问器</h3><p>LabeledExpr.g4<br>为每个备选分支定义一个标签，标签以#开头。这样 ANTLR 会为每个备选分支生成不同的访问器方法。这样我们就可以对每种输入都获得一个不同的事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">grammar LabeledExpr; &#x2F;&#x2F; rename to distinguish from Expr.g4</span><br><span class="line"></span><br><span class="line">prog: stat+ ;</span><br><span class="line"></span><br><span class="line">stat: expr NEWLINE # printExpr</span><br><span class="line">| ID &#39;&#x3D;&#39; expr NEWLINE # assign</span><br><span class="line">| NEWLINE # blank</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr: expr op&#x3D;(&#39;_&#39;|&#39;&#x2F;&#39;) expr # MulDiv</span><br><span class="line">| expr op&#x3D;(&#39;+&#39;|&#39;-&#39;) expr # AddSub</span><br><span class="line">| INT # int</span><br><span class="line">| ID # id</span><br><span class="line">| &#39;(&#39; expr &#39;)&#39; # parens</span><br><span class="line">;</span><br><span class="line">&#x2F;&#x2F;接下来我们为运算符词法符号定义一些名字，这样在随后的访问器中，我们就可以将这些词法符号的名字当做 JAVA 常量来引用。</span><br><span class="line">MUL : &#39;_&#39; ; &#x2F;&#x2F; assigns token name to &#39;\*&#39; used above in grammar</span><br><span class="line">DIV : &#39;&#x2F;&#39; ;</span><br><span class="line">ADD : &#39;+&#39; ;</span><br><span class="line">SUB : &#39;-&#39; ;</span><br><span class="line">ID : [a-zA-Z]+ ; &#x2F;&#x2F; match identifiers</span><br><span class="line">INT : [0-9]+ ; &#x2F;&#x2F; match integers</span><br><span class="line">NEWLINE:&#39;\r&#39;? &#39;\n&#39; ; &#x2F;&#x2F; return newlines to parser (is end-statement signal)</span><br><span class="line">WS : [ \t]+ -&gt; skip ; &#x2F;&#x2F; toss out whitespace</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Calc &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">String inputFile &#x3D; null;</span><br><span class="line">if ( args.length&gt;0 ) inputFile &#x3D; args[0];</span><br><span class="line">InputStream is &#x3D; System.in;</span><br><span class="line">if ( inputFile!&#x3D;null ) is &#x3D; new FileInputStream(inputFile);</span><br><span class="line">ANTLRInputStream input &#x3D; new ANTLRInputStream(is);</span><br><span class="line">LabeledExprLexer lexer &#x3D; new LabeledExprLexer(input);</span><br><span class="line">CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">LabeledExprParser parser &#x3D; new LabeledExprParser(tokens);</span><br><span class="line">ParseTree tree &#x3D; parser.prog(); &#x2F;&#x2F; parse</span><br><span class="line">&#x2F;&#x2F;实例化一个自定义的访问器，然后访问 tree</span><br><span class="line">EvalVisitor eval &#x3D; new EvalVisitor();</span><br><span class="line">eval.visit(tree);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用如下命令可以生成 visitor<br><code>antlr4 -no-listener -visitor LabeledExpr.g4</code><br>可以生成，LabeledExprBaseVisitor.java,LabeledExprParse.java,LabeledExprLexer.java,LabeledExprVisitor.java。<br>LabeledExprVisitor 是接口，LabeledExprBaseVisitor 是默认实现类。我们可以继承 LabeledExprBaseVisitor 然后重写里面的函数来实现自定义的逻辑。<br>EvalVisitor 内重写的方法对应备选分支的标签。里面引用的 JAVA 常量如：MUL，DIV 等。也是在语法文件中定义的词法符号名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class EvalVisitor extends LabeledExprBaseVisitor&lt;Integer&gt; &#123;</span><br><span class="line">&#x2F;\*_ &quot;memory&quot; for our calculator; variable&#x2F;value pairs go here _&#x2F;</span><br><span class="line">Map&lt;String, Integer&gt; memory &#x3D; new HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;** ID &#39;&#x3D;&#39; expr NEWLINE *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitAssign(LabeledExprParser.AssignContext ctx) &#123;</span><br><span class="line">        String id &#x3D; ctx.ID().getText();  &#x2F;&#x2F; id is left-hand side of &#39;&#x3D;&#39;</span><br><span class="line">        int value &#x3D; visit(ctx.expr());   &#x2F;&#x2F; compute value of expression on right</span><br><span class="line">        memory.put(id, value);           &#x2F;&#x2F; store it in our memory</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** expr NEWLINE *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitPrintExpr(LabeledExprParser.PrintExprContext ctx) &#123;</span><br><span class="line">        Integer value &#x3D; visit(ctx.expr()); &#x2F;&#x2F; evaluate the expr child</span><br><span class="line">        System.out.println(value);         &#x2F;&#x2F; print the result</span><br><span class="line">        return 0;                          &#x2F;&#x2F; return dummy value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** INT *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitInt(LabeledExprParser.IntContext ctx) &#123;</span><br><span class="line">        return Integer.valueOf(ctx.INT().getText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** ID *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitId(LabeledExprParser.IdContext ctx) &#123;</span><br><span class="line">        String id &#x3D; ctx.ID().getText();</span><br><span class="line">        if ( memory.containsKey(id) ) return memory.get(id);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** expr op&#x3D;(&#39;*&#39;|&#39;&#x2F;&#39;) expr *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitMulDiv(LabeledExprParser.MulDivContext ctx) &#123;</span><br><span class="line">        int left &#x3D; visit(ctx.expr(0));  &#x2F;&#x2F; get value of left subexpression</span><br><span class="line">        int right &#x3D; visit(ctx.expr(1)); &#x2F;&#x2F; get value of right subexpression</span><br><span class="line">        if ( ctx.op.getType() &#x3D;&#x3D; LabeledExprParser.MUL ) return left * right;</span><br><span class="line">        return left &#x2F; right; &#x2F;&#x2F; must be DIV</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** expr op&#x3D;(&#39;+&#39;|&#39;-&#39;) expr *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitAddSub(LabeledExprParser.AddSubContext ctx) &#123;</span><br><span class="line">        int left &#x3D; visit(ctx.expr(0));  &#x2F;&#x2F; get value of left subexpression</span><br><span class="line">        int right &#x3D; visit(ctx.expr(1)); &#x2F;&#x2F; get value of right subexpression</span><br><span class="line">        if ( ctx.op.getType() &#x3D;&#x3D; LabeledExprParser.ADD ) return left + right;</span><br><span class="line">        return left - right; &#x2F;&#x2F; must be SUB</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** &#39;(&#39; expr &#39;)&#39; *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitParens(LabeledExprParser.ParensContext ctx) &#123;</span><br><span class="line">        return visit(ctx.expr()); &#x2F;&#x2F; return child expr&#39;s value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子 4"></a>例子 4</h3><p>使用监听器来对 java 语法进行分析，根据实现类可以生成对应的接口定义，并保留注释<br>Java.g4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">classDeclaration</span><br><span class="line">: &#39;class&#39; Identifier typeParameters? (&#39;extends&#39; type)?</span><br><span class="line">(&#39;implements&#39; typeList)?</span><br><span class="line">classBody</span><br><span class="line">;</span><br><span class="line">methodDeclaration</span><br><span class="line">: type Identifier formalParameters (&#39;[&#39; &#39;]&#39;)\* methodDeclarationRest</span><br><span class="line">| &#39;void&#39; Identifier formalParameters methodDeclarationRest</span><br><span class="line">;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ExtractInterfaceListener.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ExtractInterfaceListener extends JavaBaseListener &#123;</span><br><span class="line">JavaParser parser;</span><br><span class="line">public ExtractInterfaceListener(JavaParser parser) &#123;this.parser &#x3D; parser;&#125;</span><br><span class="line">&#x2F;\*_ Listen to matches of classDeclaration _&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public void enterClassDeclaration(JavaParser.ClassDeclarationContext ctx)&#123;</span><br><span class="line">System.out.println(&quot;interface I&quot;+ctx.Identifier()+&quot; &#123;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void exitClassDeclaration(JavaParser.ClassDeclarationContext ctx) &#123;</span><br><span class="line">System.out.println(&quot;&#125;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Listen to matches of methodDeclaration *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void enterMethodDeclaration(</span><br><span class="line">        JavaParser.MethodDeclarationContext ctx</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; need parser to get tokens</span><br><span class="line">        TokenStream tokens &#x3D; parser.getTokenStream();</span><br><span class="line">        String type &#x3D; &quot;void&quot;;&#x2F;&#x2F;type为方法的返回类型</span><br><span class="line">        if ( ctx.type()!&#x3D;null ) &#123;</span><br><span class="line">            type &#x3D; tokens.getText(ctx.type());</span><br><span class="line">        &#125;</span><br><span class="line">        String args &#x3D; tokens.getText(ctx.formalParameters());&#x2F;&#x2F;args是入参</span><br><span class="line">        System.out.println(&quot;\t&quot;+type+&quot; &quot;+ctx.Identifier()+args+&quot;;&quot;);&#x2F;&#x2F;ctx.Identifier()是方法名</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ExtractInterfaceTool.java<br>将自定义的监听器集成到程序里，并遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ExtractInterfaceTool &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">String inputFile &#x3D; null;</span><br><span class="line">if ( args.length&gt;0 ) inputFile &#x3D; args[0];</span><br><span class="line">InputStream is &#x3D; System.in;</span><br><span class="line">if ( inputFile!&#x3D;null ) &#123;</span><br><span class="line">is &#x3D; new FileInputStream(inputFile);</span><br><span class="line">&#125;</span><br><span class="line">ANTLRInputStream input &#x3D; new ANTLRInputStream(is);</span><br><span class="line"></span><br><span class="line">        JavaLexer lexer &#x3D; new JavaLexer(input);</span><br><span class="line">        CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">        JavaParser parser &#x3D; new JavaParser(tokens);</span><br><span class="line">        ParseTree tree &#x3D; parser.compilationUnit(); &#x2F;&#x2F; parse。开始语法分析的过程</span><br><span class="line"></span><br><span class="line">        ParseTreeWalker walker &#x3D; new ParseTreeWalker(); &#x2F;&#x2F; create standard walker，新建一个标准的遍历器</span><br><span class="line">        ExtractInterfaceListener extractor &#x3D; new ExtractInterfaceListener(parser);</span><br><span class="line">        walker.walk(extractor, tree); &#x2F;&#x2F; initiate walk of tree with listener，使用监听器初始化对语法分析树的遍历</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="错误报告与恢复"><a href="#错误报告与恢复" class="headerlink" title="错误报告与恢复"></a>错误报告与恢复</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>ANTLR 在解析语法的时候，可以发现语法和词法的错误并给予提醒，尽管语法有错误，语法分析过程还是照常进行。除了产生良好的错误消息和利用剩余的输入进行重新同步之外，语法分析器还必须能够移动到何时的位置继续语法分析过程。</p>
<h3 id="修改和转发-ANTLR-的错误消息"><a href="#修改和转发-ANTLR-的错误消息" class="headerlink" title="修改和转发 ANTLR 的错误消息"></a>修改和转发 ANTLR 的错误消息</h3><h4 id="处理语法错误信息"><a href="#处理语法错误信息" class="headerlink" title="处理语法错误信息"></a>处理语法错误信息</h4><p>默认情况下，ANTLR 将所有的错误消息送至标准错误(standard error)，不过我们可以通过实现接口 ANTLRErrorListener 来改变这些消息的目标输出和内容。该接口有一个同时应用于词法分析器和语法分析器的 syntaxError()方法。syntaxError()方法接收各式各样的信息无论是错误的位置还是错误的内容。它还接收指向语法分析器的引用，因此我们能够通过引用来查询识别过程的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static class VerboseListener extends BaseErrorListener &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void syntaxError(Recognizer&lt;?,?&gt; recognizer,</span><br><span class="line">                            Object offendingSymbol,</span><br><span class="line">                            int line, int charPositionInLine,</span><br><span class="line">                            String msg,</span><br><span class="line">                            RecognitionException e) &#123;</span><br><span class="line">        List&lt;String&gt; stack &#x3D; ((Parser)recognizer).getRuleInvocationStack();</span><br><span class="line">        Collections.reverse(stack);</span><br><span class="line">        System.err.println(&quot;rule stack:&quot;+stack);</span><br><span class="line">        System.err.println(&quot;line&quot;+line+&quot;;&quot;+charPositionInLine+&quot;at&quot;+offendingSymbol+&quot;;&quot;+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这种方法，我们的程序就能在语法分析器调用其实规则之前，轻易地为其增加一个错误监听器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SimpleParser parser &#x3D; new SimpleParser(tokens);</span><br><span class="line">parser.removeErrorListeners();</span><br><span class="line">parser.addErrorListener(new VerboseListener());</span><br><span class="line">parser.prog;</span><br></pre></td></tr></table></figure>

<p>在我们增加自定义的错误监听器之前，我们需要移除输出目标是控制台的内置错误监听器，以防出现重复的错误消息。</p>
<h4 id="处理有歧义的语法信息"><a href="#处理有歧义的语法信息" class="headerlink" title="处理有歧义的语法信息"></a>处理有歧义的语法信息</h4><p>有时候用户输入的语法可以匹配到我们定义的多个语法分支，这是就存在歧义，默认情况下语法分析器不会通知用户，因为这不是用户的错。而是，我们定义的语法规则的问题。如果希望通知用于，则请使用 addErrorListener()方法添加一个 DiagnosticErrorListener 的实例来告知语法分析器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parser.removeErrorListeners();&#x2F;&#x2F;移除ConsoleErrorListener</span><br><span class="line">parser.addErrorListener(new DiagnosticErrorListener());</span><br></pre></td></tr></table></figure>

<p>此外，你还应当告诉语法分析器，你对所有的歧义告警都感兴趣，而不仅仅是哪些可以快速检测到的。出于效率方面的原因，ANTLR 的决策机制并不是总能发现所有的歧义信息。下面是令语法分析器报告所有歧义的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.getInterpreter().setPredictionMode(PredictionMode.LL_EXACT_AMBIG_DETECTION);</span><br></pre></td></tr></table></figure>

<p>在开发过程中使用上面提到的诊断错误监听器是个好主意，因为 ANTLR 工具不会对歧义性语法结构提出静态告警。在 ANTLR4 中，只有运行状态的语法分析器才能检测到歧义。这就像是 Java 中静态类型机制和 Python 中动态类型机制的差别。</p>
<h3 id="自动错误恢复机制"><a href="#自动错误恢复机制" class="headerlink" title="自动错误恢复机制"></a>自动错误恢复机制</h3><p>错误恢复指的是允许语法分析器在发现语法错误后还能继续的机制。语法分析器在遇到无法匹配词法符号的错误时，执行单词法符号补全和单词法符号移除。如果这些方案不奏效，语法分析器将向后查找词法符号，直到它遇到一个符合当前规则的后续部分的合理词法符号为止，接着，语法分析器将会继续语法分析过程，仿佛什么事情都没有发生过一样。<code>也就是，发生语法错误后从错误中恢复，然后继续语法解析。</code></p>
<ul>
<li>通过扫描后续词法符号来恢复。<br>当面对真正的非法输入时，当前的规则无法继续下去，此时语法分析器将会向后查找词法符号，知道它认为自己已经完成重新同步时，它就返回原先被调用的规则。我们可以成为‘同步-返回’策略。有人称为“应急模式”，不过它的表现相当好。语法分析器知道自己无法使用当前规则匹配当前输入。它会持续丢弃后续词法符号，知道发现一个可以匹配本规则中断位置之后的某条自规则的词法符号。例如，如果在赋值语句中存在一个语法错误，那么语法分析器的做法就非常合理：丢弃后续的词法符号，直到发现一个分好或者其他的语句终结符为止。这种策略较为激进，但是十分有效。我们下面将要看到，这种基本策略作为后备方案，在启用之前，ANTLR 会试图在规则内部进行恢复。<br>重新同步集合是调用栈中所有规则的后续符号集合的并集。<br>例如，如果语法分析其分析到 atom 时报错，比如输入的是“[]”，就会在 atom 的时候报错。调用栈为[group,expr,atom]那么此时的后续符号集合则是{‘^’,’]’}。然后语法分析其就从 atom 的错误中恢复了，然后继续分析，分析 expr 发现缺少^从而产生错误，然后继续从符号集合中恢复。然后匹配 group 最后匹配成功。<br>恢复过程中，ANTLR 语法分析器会避免输出层叠的错误消息，对于每个语法错误，直到成功从错误中恢复，语法分析器才输出一条错误消息。所以本次语法解析过程，实际上是产生了两处解析错误:atom 和 expr<br>注意后续符号集合的生成是动态计算的。是调用栈中所有规则的后续符号的并集。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">group : &#39;[&#39; expr &#39;]&#39; | &#39;(&#39; expr &#39;)&#39;;</span><br><span class="line">expr: atom &#39;^&#39; INT;</span><br><span class="line">atom: ID | INT;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>从不匹配的词法符号中恢复<br>在语法分析的过程中，最常见的操作之一就是“匹配词法符号”。对于语法中的每个词法符号 T，语法分析器都会调用 match(T)。如果当前的词法符号不是 T，match()方法就会通知错误监听器，并试图重新同步。为完成同步，它有三种选择：</p>
<ul>
<li>移除一个词法符号；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classDef: &#39;class&#39; ID &#39;&#123;&#39; member+ &#39;&#125;&#39; &#x2F;&#x2F;a class has one or more members</span><br><span class="line">&#123;System.out.println(&quot;class&quot;+$ID.text);&#125;</span><br></pre></td></tr></table></figure>

<p>考虑输入文本 class 9 T{int i;}，语法分析器会删除 9，然后继续进行同一条规则的语法分析过程–匹配类的定义体。</p>
<ul>
<li>补全一个词法符号；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classDef: &#39;class&#39; ID &#39;&#123;&#39; member+ &#39;&#125;&#39; &#x2F;&#x2F;a class has one or more members</span><br><span class="line">&#123;System.out.println(&quot;class&quot;+$ID.text);&#125;</span><br></pre></td></tr></table></figure>

<p>考虑输入文本 class {int i;}，语法分析器调用 match(ID),期望发现一个标识符，但实际上发现的却是{。这种情况下，语法分析器知道{是自己所期望的那个词法符号的下一个，因为在 classDef 规则中它位于 ID 之后。此时 match()方法可以假定标识符已经被发现并返回，这样，下一个 match(‘{‘)的调用就会成功。在忽略内嵌动作的前提下，这种方案表现得相当出色。但是，如果词法符号是 null，通过$ID.text 引用了缺失词法符号的打印语句就会引起一个异常。因此，错误处理器会创建一个词法符号，而非简单的假定该词法符号存在，详情参见 DefaultErrorStrategy 中的 getMissingSymbol()方法。新创建的词法符号具有语法分析器所期望的类型，以及和当前词法符号 LA（1）相同的行列位置信息。这个新创建的词法符号阻止了监听器和访问其中引用缺失词法符号时引发的异常。<br><img src="/images/antlr/9-6.png"></p>
<ul>
<li><p>从子规则的错误中恢复<br>在语法中手工插入一条空规则的引用，该规则包含特定的、能够在必要时触发错误恢复的动作。现在，ANTLR4 会在开始处和循环条件判定处自动插入同步检查，以避免集锦的恢复机制。</p>
<ul>
<li>子规则起始位置。在任意子规则的起始位置，语法分析器会尝试进行单词法符号移除。不过，和词法符号匹配不同的是，语法分析器不会尝试进行单词法符号补全。创建一个词法符号对 ANTLR 来说是很困难的，因为它必须猜测多个备选分支中的哪个会最终胜出。</li>
<li>子规则的循环条件判定位置。如果子规则是一个循环结构，即(…)*或(…)+，在遇到错误时，语法分析器会尝试进行积极的回复，使得自己留在循环内部。在成功地匹配到循环的某个备选分支之后，语法分析器会持续消费词法符号，直到发现满足下列条件之一的词法符号为止：</li>
<li>循环的另一次迭代</li>
<li>紧跟在循环之后的内容</li>
<li>当前规则的重新同步集合中的元素<br>例子：<br>考虑 Simple 语法的 classDef 规则中的 member+循环结构。如果我们手误多输入了’{‘，member+子规则会在进入 member 之前移除掉多余的那个词法符号。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; class T &#123;&#123;int i;&#125;</span><br><span class="line">&gt; EOF</span><br><span class="line">&gt; line 1:9 extraneous input &#39;&#123;&#39; expecting &#39;int&#39;</span><br><span class="line">var i</span><br><span class="line">class T</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>捕获失败的语义判定<br>语义判定指定了一些必须在运行时为真的条件，以使得语法分析器能够通过这些条件的验证。如果一个判定结果为假，语法分析器会抛出一个 FailedPredicateException 异常，该异常会被当前规则的 catch 语句捕获。语法分析器随机报告一个错误，并运行通用的同步-返回恢复机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vec4: &#39;[&#39; ints[4] &#39;]&#39;;</span><br><span class="line">ints[int max]</span><br><span class="line">locals [int i&#x3D;1]</span><br><span class="line">    : INT(&#39;,&#39; &#123;$i++;&#125; &#123;$i&lt;&#x3D;max&#125;? INT)*</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<p>下列测试给出的整数过多，于是我们看到了一个错误消息，以及错误恢复的过程，在这个过程中，多余的逗号和整数被丢弃了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; [1,2,3,4,5,6]</span><br><span class="line">&gt; EOF</span><br><span class="line">&gt; line 1:9 rule ints failed predicate: &#123;$i&lt;&#x3D;max&#125;?</span><br></pre></td></tr></table></figure>
<p>有时候我们输入的结构语法上是有效的，但是在语义上是无效的，这是，语义判定就不适用了。例如有种语言，要求变量不能被赋值 0.这意味“assignment x =0;”在语法上有效，在语义上无效。<br>较好的解决办法是手工输出一个错误，然后令语法分析器按照正确的语法继续继续进行匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assign</span><br><span class="line">    : ID &#39;&#x3D;&#39; v&#x3D;INT &#123;$v.int&gt;0&#125;? &#39;;&#39;</span><br><span class="line">    &#123;if ($v.int&#x3D;&#x3D;0) notifyListeners(&quot;values must be &gt; 0&quot;);&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>错误恢复机制的防护措施<br>ANTLR 的语法分析器具有内置的防护措施，以保证错误回复过程正常结束。如果我们在相同的语法分析位置，遇到了相同的输入情况，语法分析器会在尝试进行恢复之前强制消费一个词法符号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; class T &#123;</span><br><span class="line">&gt;    int int x;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; EOF</span><br><span class="line">&gt; line 2:6 no viable alternative at input &#39;intint&#39;</span><br><span class="line">&gt; var x</span><br><span class="line">&gt; class T</span><br></pre></td></tr></table></figure>

<p>classDef 规则调用了三次 member。其中，第一个 member 没有匹配到任何内容，第二个 member 匹配到了多余的 int。第三次匹配 member 的尝试正确地匹配到了“int x;”序列。<br><img src="/images/antlr/9-11.png"></p>
</li>
</ul>
</li>
<li><p>简单地抛出一个异常以启用基本的同步-返回机制<br>当面对真正的非法输入时，当前的规则无法继续下去，此时语法分析器将会向后查找词法符号，知道它认为自己已经完成重新同步时，它就返回原先被调用的规则。我们可以成为‘同步-返回’策略。有人称为“应急模式”，不过它的表现相当好。语法分析器知道自己无法使用当前规则匹配当前输入。它会持续丢弃后续词法符号，知道发现一个可以匹配本规则中断位置之后的某条自规则的词法符号。例如，如果在赋值语句中存在一个语法错误，那么语法分析器的做法就非常合适。</p>
</li>
</ul>
<h3 id="勘误备选分支"><a href="#勘误备选分支" class="headerlink" title="勘误备选分支"></a>勘误备选分支</h3><p>一些语法错误十分常见，以至于对它们进行特殊处理是值得的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stat: fcall &#39;;&#39;;</span><br><span class="line">fcall</span><br><span class="line">    : ID &#39;(&#39; expr &#39;)&#39;</span><br><span class="line">    | ID &#39;(&#39; expr &#39;)&#39; &#39;)&#39; &#123;notifyErrorListeners(&quot;Too many parentheses&quot;);&#125;</span><br><span class="line">    | ID &#39;(&#39; expr &#123;notifyErrorListeners(&quot;Missing closing&quot;);&#125;</span><br><span class="line">    ;</span><br><span class="line">expr: &#39;(&#39; expr &#39;)&#39;</span><br><span class="line">    | INT</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<h3 id="修改-ANTLR-的错误处理策略"><a href="#修改-ANTLR-的错误处理策略" class="headerlink" title="修改 ANTLR 的错误处理策略"></a>修改 ANTLR 的错误处理策略</h3><p>默认的错误处理机制表现出色，不过我们还是会遇到一些非典型的，需要修改默认机制的场景。首先，我们希望关闭某些默认的错误处理功能，他们会带来额外的运行负担。其次，我们可能希望语法分析器在遇到第一个语法错误时就退出。这种情况是，当处理类似 bash 的命令行输入时，从错误中回复是毫无意义的。我们不能一意孤星地执行有风险的命令，因此语法分析器可以一遇到问题就退出。探究错误处理策略，不妨看一下 ANTLRErrorStratege 接口及实现类 DefaultError-Strategy，该类完成了全部的默认错误处理工作。利用 ANTLRErrorListener 和 ANTLRErrorStrategy 接口，我们能够非常灵活地指定错误消息的输出位置、错误消息的内容以及语法分析器从错误中恢复的方法。</p>
<h2 id="在语法分析过程中执行自身的逻辑代码"><a href="#在语法分析过程中执行自身的逻辑代码" class="headerlink" title="在语法分析过程中执行自身的逻辑代码"></a>在语法分析过程中执行自身的逻辑代码</h2><p>在之前的学习中，我们的程序逻辑代码都是与语法分析树遍历器分离的，这意味着我们的代码总是在语法分析完成之后执行。在接下来的几节（属性和动作、使用语义判定修改语法分析过程、掌握词法分析的“黑魔法”）中我们可以看到，一些语言类应用程序需要在语法分析的过程中执行自身的逻辑代码。</p>
<h2 id="属性和动作"><a href="#属性和动作" class="headerlink" title="属性和动作"></a>属性和动作</h2><p>通常我们应当避免将语法和应用程序的逻辑代码纠缠在一起。不包含动作的语法更容易阅读，不会绑定到特定的目标语言和程序上。尽管如此，内嵌的动作仍然是有用的，原因有如下三个：</p>
<ul>
<li>简便: 有时，使用少量的动作，避免创建一个监听器或者访问器会使事情变得更加简单。</li>
<li>效率：在资源紧张的程序中，我们可能不想把宝贵的时间和内存浪费在简历语法分析树上。</li>
<li>待判定的语法分析过程：在某些罕见情况下，我们必须依赖从之前的输入流中获取的数据才能正常第进行语法分析过程。一些语法需要建立一个符号表，以便在未来根据情况差异化地识别输入的文本。</li>
</ul>
<p>动作就是使用目标语言编写的、放置在{}中的任意代码块。我们可以在动作中编写任意代码，只要它们是合法的目标语言语句。动作的典型用法是操纵词法符号和规则引用的属性。例如，我们可以读取一个词法符号对应的文本或者整个规则匹配的文本。通过从词法符号和规则引用中获取的数据，我们就可以打印结果或者执行任意计算。规则允许参数和返回值，因此我们可以在规则之间传递数据。</p>
<h3 id="添加动作"><a href="#添加动作" class="headerlink" title="添加动作"></a>添加动作</h3><ol>
<li><p>定义 header 和 members<br>这些动作可以位于规则内，也可以位于规则外。header 用于向自动生成的语法分析器和词法分析器中注入 package 或 import 语句。members 用于向自动生成的语法分析器和词法分析器中注入字段(成员变量)和方法(成员函数)。下面显示了注入代码片段的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;</span><br><span class="line">public class &lt;grammarName&gt;Parser extends Parser &#123;</span><br><span class="line">    &lt;members&gt;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用@header{}和@members{}来注入代码。{}内的代码，将出现在语法和词法解析器中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">grammar Expr;</span><br><span class="line">&#x2F;&#x2F;定义了语法和词法解析器所属的包，并导入了java.util包</span><br><span class="line">@header &#123;</span><br><span class="line">    package tools;</span><br><span class="line">    import java.util.*;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;新增了语法和词法解析器中的字段（成员变量）memory和方法eval()。</span><br><span class="line">@members &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; memory &#x3D; new HashMap&lt;String, Integer&gt;();</span><br><span class="line">    int eval (int left, int op, int right) &#123;</span><br><span class="line">        switch (op) &#123;</span><br><span class="line">            case MUL: return left * right;</span><br><span class="line">            case DIV: return left &#x2F; right;</span><br><span class="line">            case ADD: return left + right;</span><br><span class="line">            case SUB: return left - right;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在规则中嵌入动作<br>动作执行时机是它前面的语法元素之后。本例中，动作出现在备选分支的末尾，因此它们会在语法分析器匹配到整个语句之后被执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stat: e NEWLINE          &#123;System.out.println($e.v);&#125;</span><br><span class="line">    | ID &#39;&#x3D;&#39; e NEWLINE   &#123;memory.put($ID.text, $e.v);&#125;</span><br><span class="line">    | NEWLINE</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<ul>
<li>returns 定义了返回值 v，且类型为 int。通过$e.v 可以引用 e 规则的返回值。</li>
<li>a,b,op 都是标记，它们是对=右侧的引用。使用标记可以方便在动作中操作各种值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">e returns [int v]</span><br><span class="line">    : a&#x3D;e op&#x3D;(&#39;*&#39;|&#39;&#x2F;&#39;) b&#x3D;e &#123;$v &#x3D; eval($a.v, $op.type, $b.v);&#125;</span><br><span class="line">    | a&#x3D;e op&#x3D;(&#39;+&#39;|&#39;-&#39;) b&#x3D;e &#123;$v &#x3D; eval($a.v, $op.type, $b.v);&#125;</span><br><span class="line">    | INT                  &#123;$v &#x3D; $INT.int;&#125;</span><br><span class="line">    | ID</span><br><span class="line">        &#123;</span><br><span class="line">            String id &#x3D; $ID.text;</span><br><span class="line">            $v &#x3D; memory.containsKey(id) ? memory.get(id) : 0;</span><br><span class="line">        &#125;</span><br><span class="line">    | &#39;(&#39; e &#39;)&#39; &#123;$v &#x3D; $e.v;&#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
ANTLR 通过规则上下文对象来实现语法分析树的节点，每次规则调用都会新建并返回一个规则上下文对象。自然地，规则上下文对象非常适合放置与特定规则相关的数据实体。EContext 的第一部分如下所示:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static class EContext extends ParserRuleContext&#123;</span><br><span class="line">    public int v;        &#x2F;&#x2F;规则e的返回值</span><br><span class="line">    public EContext a;   &#x2F;&#x2F;规则引用e上的标记a</span><br><span class="line">    public Token op;     &#x2F;&#x2F;类似（‘*’|‘&#x2F;’）的运算符子规则上的标记</span><br><span class="line">    public EContext b;   &#x2F;&#x2F;规则引用e上的标记b</span><br><span class="line">    public Token INT;    &#x2F;&#x2F;第三个备选分支引用的INT</span><br><span class="line">    public Token ID;     &#x2F;&#x2F;第四个备选分支引用的ID</span><br><span class="line">    public EContext e;   &#x2F;&#x2F;e的调用过程对应的上下文对象的引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="访问词法符号和规则的属性"><a href="#访问词法符号和规则的属性" class="headerlink" title="访问词法符号和规则的属性"></a>访问词法符号和规则的属性</h3><p>此节中可以看到如何定义和引用规则的参数和返回值。<br>原始规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">grammar CSV;</span><br><span class="line"></span><br><span class="line">file : hdr row+;</span><br><span class="line">hdr : row ;</span><br><span class="line">row : field (&#39;,&#39; field)* &#39;\r&#39;? &#39;\n&#39;;</span><br><span class="line">field</span><br><span class="line">    : TEXT   # text</span><br><span class="line">    | STRING # string</span><br><span class="line">    |        # empty</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">TEXT : ~[,\n\r&quot;]+ ;</span><br><span class="line">STRING: &#39;&quot;&#39; (&#39;&quot;&quot;&#39;|~&#39;&quot;&#39;)* &#39;&quot;&#39; ;</span><br></pre></td></tr></table></figure>

<p>改造后的规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 由规则&quot;file: hdr row+ ;&quot;衍生而来 *&#x2F;</span><br><span class="line">file</span><br><span class="line">locals [int i&#x3D;0]</span><br><span class="line">    : hdr ( rows+&#x3D;row[$hdr.text.split(&quot;,&quot;)] &#123;$i++&#125; )+</span><br><span class="line">      &#123;</span><br><span class="line">          System.out.println($i+&quot;rows&quot;);</span><br><span class="line">          for (RowContext r : $rows) &#123;</span><br><span class="line">              System.out.println(&quot;row token interval:&quot;+r.getSourceInterval());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">hdr: row[null] &#123;System.out.println(&quot;header: &#39;&quot;+$text.trim()+&quot;&#39;&quot;);&#125;;</span><br><span class="line">&#x2F;* 由规则&quot;row: field (&#39;,&#39; field)* &#39;\r&#39;? &#39;\n&#39; ;&quot; 衍生而来*&#x2F;</span><br><span class="line">row[String[] columns] returns [Map&lt;String,String&gt; values]</span><br><span class="line">locals [int col&#x3D;0]</span><br><span class="line">@init&#123;</span><br><span class="line">    $values &#x3D; new HashMap&lt;String,String&gt;();</span><br><span class="line">&#125;</span><br><span class="line">@after&#123;</span><br><span class="line">    if ($values!&#x3D;null &amp;&amp; $values.size()&gt;0) &#123;</span><br><span class="line">        System.out.println(&quot;values &#x3D; &quot;+ $values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    : field</span><br><span class="line">        &#123;</span><br><span class="line">            if($columns!&#x3D;null) &#123;</span><br><span class="line">                $values.put($columns[$col++].trim(), $field.text.trim());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        (</span><br><span class="line">            &#39;,&#39; field</span><br><span class="line">            &#123;</span><br><span class="line">                if ($column!&#x3D;null)&#123;</span><br><span class="line">                    $values.put($columns[$col++].trim(), $field.text.trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )* &#39;\r&#39;? &#39;\n&#39;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>输入如下数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User,  Name,   Dept</span><br><span class="line">parrt, Terence, 101</span><br><span class="line">tombu, Tom,     020</span><br><span class="line">bke,   Kevin,   008</span><br></pre></td></tr></table></figure>

<p>输出解析结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">header: &#39;User, Name, Dept&#39;</span><br><span class="line">values &#x3D; &#123;Name&#x3D;Terence, User&#x3D;parrt, Dept&#x3D;101&#125;</span><br><span class="line">values &#x3D; &#123;Name&#x3D;Tom, User&#x3D;tombu, Dept&#x3D;020&#125;</span><br><span class="line">values &#x3D; &#123;Name&#x3D;Kevin, User&#x3D;bke, Dept&#x3D;008&#125;</span><br><span class="line">3 rows</span><br><span class="line">row token interval:6..11</span><br><span class="line">row token interval:12..17</span><br><span class="line">row token interval:18..23</span><br></pre></td></tr></table></figure>

<h3 id="关键字识别"><a href="#关键字识别" class="headerlink" title="关键字识别"></a>关键字识别</h3><p>此节中我们将看到如何使用词法符号属性，text 和 type。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">grammar Keywords;</span><br><span class="line">@lexer::header&#123;</span><br><span class="line">    import java.util.*;</span><br><span class="line">&#125;</span><br><span class="line">@lexer::members&#123;</span><br><span class="line">    Map&lt;String,Integer&gt; keywords &#x3D; new HashMap&lt;String,Integer&gt;() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            put(&quot;begin&quot;, KeywordsParser.BEGIN);</span><br><span class="line">            put(&quot;end&quot;, KeywordsParser.END);</span><br><span class="line">            put(&quot;if&quot;, KeywordsParser.IF);</span><br><span class="line">            put(&quot;then&quot;, KeywordsParser.THEN);</span><br><span class="line">            put(&quot;while&quot;, KeywordsParser.WHILE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">stat: BEGIN stat* END</span><br><span class="line">    | IF expr THEN stat</span><br><span class="line">    | WHILE expr stat</span><br><span class="line">    | ID &#39;&#x3D;&#39; expr &#39;;&#39;</span><br><span class="line">        ;</span><br><span class="line">expr: INT|CHAR;</span><br><span class="line">ID: [a-zA-Z]+&#123;</span><br><span class="line">    if(keywords.containsKey(getText()))&#123;</span><br><span class="line">        setType(keywords.get(getText()));&#x2F;&#x2F;重置词法符号类型</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">CHAR: &#39;\&#39;&#39;.&#39;\&#39;&#39;&#123;setText(String.valueOf(getText().charAt(1)))&#125;;</span><br><span class="line">tokens &#123;BEGIN, END, IF , THEN, WHILE&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用语义判定修改语法分析过程"><a href="#使用语义判定修改语法分析过程" class="headerlink" title="使用语义判定修改语法分析过程"></a>使用语义判定修改语法分析过程</h2><p>在上节中，内嵌动作仅仅是计算一些值或者打印结果。但是，某些情况下使用内嵌动作类修改语法分析过程是正确识别某些编程语言语句的唯一方案。本章我们学习一种特殊的动作{…}?,成为语义判定，它允许我们在运行时选择性地关闭部分语法。判定本身就是布尔表达式，它会减少语法分析器的在语法分析过程中可选项的数量。适当地减少可选项的数量会增强语法分析器的性能。在词法规则中使用判定，一样会拖慢词法分析器。<br>语义判定可以在两种常见情况下发挥作用。<br>第一，我们可能需要语法分析器处理同一门编程语言稍有差异的多个版本。语义判定允许我们通过命令行参数或者其他动态机制，在运行时选择所使用的方言。<br>第二，应用场景包含处理语法的歧义性。在某些编程语言中，相同的语法结构具有不同的含义，此时判定机制提供了一种方法，让我们能够在对相同输入文本的不同解释中做出选择。</p>
<ul>
<li><p>在语法规则中加入判定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">grammar Enum;</span><br><span class="line">@parser::members &#123;public static boolean java5;&#125;</span><br><span class="line"></span><br><span class="line">prog: (stat</span><br><span class="line">        | enumDecl</span><br><span class="line">        )+</span><br><span class="line">        ;</span><br><span class="line">stat: id &#39;&#x3D;&#39; expr &#39;;&#39; &#123;System.out.println($id.text+&quot;&#x3D;&quot;+$expr.text);&#125;;</span><br><span class="line">expr: id | INT;</span><br><span class="line">enumDecl: &#123;java5&#125;? &#39;enum&#39; name&#x3D;id &#39;&#123;&#39; id (&#39;,&#39; id)* &#39;&#125;&#39;</span><br><span class="line">        &#123;System.out.println(&quot;enum &quot;+$name.text);&#125;</span><br><span class="line">        ;</span><br><span class="line">ENUM: &#39;enum&#39;;</span><br><span class="line">ID: [a-zA-Z]+;</span><br></pre></td></tr></table></figure>

<p>判定可以开启和关闭任何在通过判定后能被匹配的规则。<br>下面这样写，一样是正确的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog : (&#123;java5&#125;? enumDecl| stat)+;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在词法规则中加入判定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enumDecl: &#39;enum&#39; name&#x3D;id &#39;&#123;&#39; id (&#39;,&#39; id)* &#39;&#125;&#39;</span><br><span class="line">          &#123;System.out.println(&quot;enum &quot;+$name.text);&#125;</span><br><span class="line">          ;</span><br><span class="line">ENUM: &#39;enum&#39; &#123;java5&#125;? ;&#x2F;&#x2F;必须放置在ID规则之前</span><br><span class="line">ID: [a-zA-Z]+;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，判定出现在词法规则的右侧，而非像文法规则一样的左侧。这是由于在语法分析中，语法分析器会对之后的内容进行预测，因此需要在匹配备选分支之前进行判定。而词法分析器不进行备选分支的预测。它们仅仅寻找最长的匹配文本，然后在发现整个词法符号后做出决策。当 java5 为假时，该判定关闭了 ENUM 规则。当它为真时，ENUM 和 ID 同时匹配了字符序列 e-n-u-m，此时该输入存在歧义。ANTLR 总是通过选择位置靠前的规则来解决词法歧义问题，也就是这里的 ENUM。</p>
</li>
<li><p>识别歧义文本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 前两个备选分支中使用了理想化的判定作为区分这两种情况的Demo **&#x2F;</span><br><span class="line">expr: &#123;&lt;&lt;isfunc(ID)&gt;&gt;&#125;? ID &#39;(&#39; expr &#39;)&#39; &#x2F;&#x2F;一个参数的函数调用</span><br><span class="line">    | &#123;&lt;&lt;istype(ID)&gt;&gt;&#125;? ID &#39;(&#39; expr &#39;)&#39; &#x2F;&#x2F;构造器风格的对expr的转换</span><br><span class="line">    | INT           &#x2F;&#x2F;整数常量</span><br><span class="line">    | ID            &#x2F;&#x2F;标识符</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>当我们使用这份带判定的语法再次进行测试时，输入”f(i);”被正确地解释成了函数调用表达式，而非声明。输入”T(i);”也被正确解释成了声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">decl: ID ID</span><br><span class="line">    | &#123;istype()&#125;? ID &#39;(&#39; ID &#39;)&#39;</span><br><span class="line">    ;</span><br><span class="line">expr: INT</span><br><span class="line">    | ID</span><br><span class="line">    | &#123;!istype()&#125;? ID &#39;(&#39; expr &#39;)&#39;</span><br><span class="line">    ;</span><br><span class="line">@parser::members &#123;</span><br><span class="line">    Set&lt;String&gt; types &#x3D; new HashSet&lt;String&gt;() &#123;&#123;add(&quot;T&quot;);&#125;&#125;;</span><br><span class="line">    boolean istype() &#123;return types.contains(getCurrentToken().getText());&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="掌握词法分析的“黑魔法”"><a href="#掌握词法分析的“黑魔法”" class="headerlink" title="掌握词法分析的“黑魔法”"></a>掌握词法分析的“黑魔法”</h2><h3 id="将词法符号送入不同通道"><a href="#将词法符号送入不同通道" class="headerlink" title="将词法符号送入不同通道"></a>将词法符号送入不同通道</h3><ul>
<li><p>将空格和回车送入不同通道，而正常的词法符号仍然位于默认的 0 通道。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WS ： [\t\n\r]+ -&gt; channel(1);</span><br><span class="line">SL_COMMENT : &#39;&#x2F;&#x2F;&#39; .*? &#39;\n&#39; -&gt; channel(2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问隐藏通道<br>通过继承监听器，在方法中可以调用 BufferedTokenStream.getHiddenTokensToRight()得到隐藏 channel，进而可以访问 channel 中的 Token 的 text 进行改造。</p>
</li>
</ul>
<h3 id="上下文相关的词法问题"><a href="#上下文相关的词法问题" class="headerlink" title="上下文相关的词法问题"></a>上下文相关的词法问题</h3><h3 id="字符流中的孤岛"><a href="#字符流中的孤岛" class="headerlink" title="字符流中的孤岛"></a>字符流中的孤岛</h3><h3 id="对-XML-进行语法分析和词法分析"><a href="#对-XML-进行语法分析和词法分析" class="headerlink" title="对 XML 进行语法分析和词法分析"></a>对 XML 进行语法分析和词法分析</h3><h2 id="语法参考"><a href="#语法参考" class="headerlink" title="语法参考"></a>语法参考</h2><h3 id="语法词汇表"><a href="#语法词汇表" class="headerlink" title="语法词汇表"></a>语法词汇表</h3><ol>
<li>注释<br>ANTLR 支持单行、多行注释。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grammar T;</span><br><span class="line">&#x2F;*多行</span><br><span class="line">  注释</span><br><span class="line"> *&#x2F;</span><br><span class="line">decl: ID; &#x2F;&#x2F;单行注释</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>标识符<br>词法符号名和词法规则名总是以大写字母开头。文法规则总是以小写字母开头。首字母之后的字符可以是大小写字符、数字和下划线。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ID,LPAREN,RIGHT_CURLY &#x2F;&#x2F;词法符号和词法规则名</span><br><span class="line">expr,d2,header_file &#x2F;&#x2F;文法规则名</span><br></pre></td></tr></table></figure>

<pre><code>ANTLR是支持中文等unicode的。同时也支持非unicode，需要在使用ANTLR工具中使用-encoding选项，以便正确读字符。</code></pre>
<ol start="3">
<li><p>文本常量</p>
</li>
<li><p>动作</p>
</li>
<li><p>关键字</p>
</li>
</ol>
<h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><h3 id="文法规则"><a href="#文法规则" class="headerlink" title="文法规则"></a>文法规则</h3><h3 id="动作和属性"><a href="#动作和属性" class="headerlink" title="动作和属性"></a>动作和属性</h3><h3 id="词法规则-1"><a href="#词法规则-1" class="headerlink" title="词法规则"></a>词法规则</h3><h3 id="通配符和非贪婪子规则"><a href="#通配符和非贪婪子规则" class="headerlink" title="通配符和非贪婪子规则"></a>通配符和非贪婪子规则</h3><h3 id="语义判定"><a href="#语义判定" class="headerlink" title="语义判定"></a>语义判定</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/29/JMX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/29/JMX/" class="post-title-link" itemprop="url">JMX</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-29 19:11:30" itemprop="dateCreated datePublished" datetime="2021-01-29T19:11:30+08:00">2021-01-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-01-31 02:51:15" itemprop="dateModified" datetime="2021-01-31T02:51:15+08:00">2021-01-31</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Java 程序的运行过程中，对 JVM 和系统的监测一直是 Java 开发人员在开发过程所需要的。一直以来，Java 开发人员必须通过一些底层的 JVM API，比如 JVMPI 和 JVMTI 等，才能监测 Java 程序运行过程中的 JVM 和系统的一系列情况，这种方式一直以来被人所诟病，因为这需要大量的 C 程序和 JNI 调用，开发效率十分低下。于是出现了各种不同的专门做资源管理的程序包。为了解决这个问题，Sun 公司也在其 Java SE 5 版本中，正式提出了 Java 管理扩展（Java Management Extensions，JMX）用来管理检测 Java 程序（同时 JMX 也在 J2EE 1.4 中被发布）。</p>
<p>JMX 的提出，让 JDK 中开发自检测程序成为可能，也提供了大量轻量级的检测 JVM 和运行中对象 / 线程的方式，从而提高了 Java 语言自己的管理监测能力。</p>
<h2 id="JMX-和系统管理"><a href="#JMX-和系统管理" class="headerlink" title="JMX 和系统管理"></a>JMX 和系统管理</h2><p>管理系统（Management System）<br>要了解 JMX，我们就必须对当前的 IT 管理系统有一个初步的了解。随着企业 IT 规模的不断增长，IT 资源（IT resource）数量不断增加，IT 资源的分布也越来越分散。可以想象，甚至对于一家只有几百台 PC 公司的 IT 管理人员来说，分发一个安全补丁并且保证其在每台 PC 上的安装，如果只依赖人工来完成那简直就是一场噩梦。这样，IT 管理系统就应运而生。</p>
<p>然而，CPU、网卡、存储阵列是 IT 资源；OS、MS Office、Oracle database、IBM Websphere 也是 IT 资源。IT 管理系统若要对这些 IT 资源进行管理，就必须对这些管理对象有所了解：形形色色的 IT 资源就像是说着不同语言的人：Oralce 数据库表达内存紧张的方式和 Window XP 是绝然不同的， 而 IT 管理系统就像建造通天塔的经理，必须精通所有的语言， 这几乎是一个不可能完成的任务。难道 IT 管理系统是另外一个通天塔吗？当然不是！其实我们只要给每个 IT 资源配个翻译就可以了。</p>
<h2 id="管理系统的构架"><a href="#管理系统的构架" class="headerlink" title="管理系统的构架"></a>管理系统的构架</h2><p><img src="/images/java/jmx1.jpg"><br>图 1. 管理系统构架</p>
<p>上图分析了管理系统的基本构架模式。其中 Agent / SubAgent 起到的就是翻译的作用：把 IT 资源报告的消息以管理系统能理解的方式传送出去。</p>
<p>也许读者有会问，为什么需要 Agent 和 SubAgent 两层体系呢？这里有两个现实的原因：</p>
<p>管理系统一般是一个中央控制的控制软件，而 SubAgent 直接监控一些资源，往往和这些资源分布在同一物理位置。当这些 SubAgent 把状态信息传输到管理系统或者传达管理系统的控制指令的时候，需要提供一些网络传输的功能。<br>管理系统的消息是有一定规范的，消息的翻译本身是件复杂而枯燥的事情。<br>一般来说，管理系统会将同一物理分布或者功能类似的 SubAgent 分组成一组，由一个共用的 Agent 加以管理。在这个 Agent 里封装了 1 和 2 的功能。</p>
<h2 id="JMX-和管理系统"><a href="#JMX-和管理系统" class="headerlink" title="JMX 和管理系统"></a>JMX 和管理系统</h2><p>JMX 既是 Java 管理系统的一个标准，一个规范，也是一个接口，一个框架。图 2 展示了 JMX 的基本架构。</p>
<p><img src="/images/java/jmx2.jpg"><br>图 2. JMX 构架</p>
<p>和其它的资源系统一样，JMX 是管理系统和资源之间的一个接口，它定义了管理系统和资源之间交互的标准。 javax.management.MBeanServer 实现了 Agent 的功能，以标准的方式给出了管理系统访问 JMX 框架的接口。而 javax.management.MBeans 实现了 SubAgent 的功能，以标准的方式给出了 JMX 框架访问资源的接口。而从类库的层次上看，JMX 包括了核心类库 java.lang.management 和 javax.management 包。 java.lang.management 包提供了基本的 VM 监控功能，而 javax.management 包则向用户提供了扩展功能。</p>
<h2 id="JMX-的基本框架"><a href="#JMX-的基本框架" class="headerlink" title="JMX 的基本框架"></a>JMX 的基本框架</h2><p>JMX 使用了 Java Bean 模式来传递信息。一般说来，JMX 使用有名的 MBean，其内部包含了数据信息，这些信息可能是：应用程序配置信息、模块信息、系统信息、统计信息等。另外，MBean 也可以设立可读写的属性、直接操作某些函数甚至启动 MBean 可发送的 notification 等。MBean 包括 Standard，MXBean，Dynamic，Model，Open 等几种分类，其中最简单是标准 MBean 和 MXBean，而我们使用得最多的也是这两种。MXBean 主要是 java.lang.management 使用较多，将在下一节中介绍。我们先了解其他一些重要的 MBean 的种类。</p>
<h2 id="标准-MBean"><a href="#标准-MBean" class="headerlink" title="标准 MBean"></a>标准 MBean</h2><p>标准 MBean 是最简单的一类 MBean，与动态 Bean 不同，它并不实现 javax.management 包中的特殊的接口。说它是标准 MBean， 是因为其向外部公开其接口的方法和普通的 Java Bean 相同，是通过 lexical，或者说 coding convention 进行的。下面我们就用一个例子来展现，如何实现一个标准 MBean 来监控某个服务器 ServerImpl 状态的。ServerImpl 代表了用来演示的某个 Server 的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package standardbeans;</span><br><span class="line"> public class ServerImpl &#123;</span><br><span class="line">    public final long startTime;</span><br><span class="line">    public ServerImpl() &#123;</span><br><span class="line">        startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>显示更多<br>然后，我们打算使用一个标准 MBean，ServerMonitor 来监控 ServerImpl：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package standardbeans;</span><br><span class="line"> public class ServerMonitor implements ServerMonitorMBean &#123;</span><br><span class="line">    private final ServerImpl target;</span><br><span class="line">    public ServerMonitor(ServerImpl target)&#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line">    public long getUpTime()&#123;</span><br><span class="line">        return System.currentTimeMillis() - target.startTime;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>显示更多<br>这里的 ServerMonitorBean 又是怎么回事呢？ MXBean 规定了标准 MBean 也要实现一个接口，所有向外界公开的方法都要在这个接口中声明。否则，管理系统就不能从中获得相应的信息。此外，该接口的名字也有一定的规范：即在标准 MBean 类名之后加上”MBean”后缀。若 MBean 的类名叫做 MBeansName 的话，对应的接口就要叫做 MBeansNameMBean。</p>
<p>对于管理系统来说，这些在 MBean 中公开的方法，最终会被 JMX 转化成属性（Attribute）、监听（Listener）和调用（Invoke）的概念。如果读者对 Java Bean 有一些了解的话，不难看出， public long getUpTime() 对应了 Bean 中的一个称为”upTime”的只读属性。</p>
<p>下面我们就看一个模拟管理系统的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package standardbeans;</span><br><span class="line"> import javax.management.MBeanServer;</span><br><span class="line"> import javax.management.MBeanServerFactory;</span><br><span class="line"> import javax.management.ObjectName;</span><br><span class="line"> public class Main &#123;</span><br><span class="line">    private static ObjectName objectName ;</span><br><span class="line">    private static MBeanServer mBeanServer;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        init();</span><br><span class="line">        manage();</span><br><span class="line">    &#125;</span><br><span class="line">    private static void init() throws Exception&#123;</span><br><span class="line">        ServerImpl serverImpl &#x3D; new ServerImpl();</span><br><span class="line">        ServerMonitor serverMonitor &#x3D; new ServerMonitor(serverImpl);</span><br><span class="line">        mBeanServer &#x3D; MBeanServerFactory.createMBeanServer();</span><br><span class="line">        objectName &#x3D; new ObjectName(&quot;objectName:id&#x3D;ServerMonitor1&quot;);</span><br><span class="line">        mBeanServer.registerMBean(serverMonitor,objectName);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void manage() throws Exception&#123;</span><br><span class="line">        Long upTime &#x3D; (Long) mBeanServer.getAttribute(objectName,</span><br><span class="line">        &quot;upTime&quot;);</span><br><span class="line">        System.out.println(upTime);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>显示较少<br>JMX 的核心是 MBServer。Java SE 已经提供了一个默认实现，可以通过 MBServerFactory.createMBeanServer() 获得。每个资源监控者（MBean）一般都会有名称（ObjectName）， 登记在 MBServer 内部的一个 Repository 中。注意，这个 ObjectName 对于每一个 MBServer 必须是唯一的，只能对应于一个 MBean。（读者有兴趣的话，可以试着再给 mBeanServer 注册一个同名的 objectName，看看会怎么样。） 上述例子是在 init() 方法中完成向 MBeanServer 注册工作的。</p>
<p>在管理过程中，管理系统并不与资源或者 SubAgent 直接打交道，也就是说，这里不会直接引用到 MBean。而是通过 MBeanServer 的 getAttribute 方法取得对应 MBean 的属性的。</p>
<h2 id="动态-MBean"><a href="#动态-MBean" class="headerlink" title="动态 MBean"></a>动态 MBean</h2><h2 id="虚拟机检测"><a href="#虚拟机检测" class="headerlink" title="虚拟机检测"></a>虚拟机检测</h2><p>JMX 与虚拟机检测<br>JMX 的提出，为 Java 虚拟机提供了 Java 层上的检测机制。J2SE 中，新提出的 java.lang.management 包即是 JMX 在 JDK 的一个应用，它提供了大量的有用的接口，通过 MBean 方式，提供了对 Java 虚拟机和运行时远端的监控和检测方式，来帮助用户来检测本地或者远端的虚拟机的运行情况。有了 JMX 之后，我们可以设计一个客户端，来检测远端一个正在运行的虚拟机中的线程数、线程当前的 Stack、内存管理、GC 所占用的时间、虚拟机中的对象和当前虚拟机参数等重要的参数和运行时信息。JMX 另外的一个重要功能是对配置信息的检测和再配置。比如，我们可以在远端查看和修改当前 JVM 的 verbose 参数，以达到动态管理的目的。甚至，我们可以在远端指挥 JVM 做一次 GC，这在下文中有详细介绍。</p>
<h2 id="JMX-提供的虚拟机检测-API"><a href="#JMX-提供的虚拟机检测-API" class="headerlink" title="JMX 提供的虚拟机检测 API"></a>JMX 提供的虚拟机检测 API</h2><p>检测虚拟机当前的状态总是 Java 开放人员所关心的，也正是因为如此，出现了大量的 profiler 工具来检测当前的虚拟机状态。从 Java SE 5 之后，在 JDK 中，我们有了一些 Java 的虚拟机检测 API，即 java.lang.management 包。Management 包里面包括了许多 MXBean 的接口类和 LockInfo、MemoryUsage、MonitorInfo 和 ThreadInfo 等类。从名字可以看出，该包提供了虚拟机内存分配、垃圾收集（GC）情况、操作系统层、线程调度和共享锁，甚至编译情况的检测机制。这样一来，Java 的开发人员就可以很简单地为自己做一些轻量级的系统检测，来确定当前程序的各种状态，以便随时调整。</p>
<p>要获得这些信息，我们首先通过 java.lang.management.ManagementFactory 这个工厂类来获得一系列的 MXBean。包括：</p>
<ul>
<li>ClassLoadingMXBean</li>
</ul>
<p>ClassLoadMXBean 包括一些类的装载信息，比如有多少类已经装载 / 卸载（unloaded），虚拟机类装载的 verbose 选项（即命令行中的 Java – verbose:class 选项）是否打开，还可以帮助用户打开 / 关闭该选项。</p>
<ul>
<li>CompilationMXBean</li>
</ul>
<p>CompilationMXBean 帮助用户了解当前的编译器和编译情况，该 mxbean 提供的信息不多。</p>
<ul>
<li>GarbageCollectorMXBean</li>
</ul>
<p>相对于开放人员对 GC 的关注程度来说，该 mxbean 提供的信息十分有限，仅仅提供了 GC 的次数和 GC 花费总时间的近似值。但是这个包中还提供了三个的内存管理检测类：MemoryManagerMXBean，MemoryMXBean 和 MemoryPoolMXBean。</p>
<ul>
<li>MemoryManagerMXBean</li>
</ul>
<p>这个类相对简单，提供了内存管理类和内存池（memory pool）的名字信息。</p>
<ul>
<li>MemoryMXBean</li>
</ul>
<p>这个类提供了整个虚拟机中内存的使用情况，包括 Java 堆（heap）和非 Java 堆所占用的内存，提供当前等待 finalize 的对象数量，它甚至可以做 gc（实际上是调用 System.gc）。</p>
<ul>
<li>MemoryPoolMXBean</li>
</ul>
<p>该信息提供了大量的信息。在 JVM 中，可能有几个内存池，因此有对应的内存池信息，因此，在工厂类中，getMemoryPoolMXBean() 得到是一个 MemoryPoolMXBean 的 list。每一个 MemoryPoolMXBean 都包含了该内存池的详细信息，如是否可用、当前已使用内存 / 最大使用内存值、以及设置最大内存值等等。</p>
<ul>
<li>OperatingSystemMXBean</li>
</ul>
<p>该类提供的是操作系统的简单信息，如构架名称、当前 CPU 数、最近系统负载等。</p>
<ul>
<li>RuntimeMXBean</li>
</ul>
<p>运行时信息包括当前虚拟机的名称、提供商、版本号，以及 classpath、bootclasspath 和系统参数等等。</p>
<ul>
<li>ThreadMXBean</li>
</ul>
<p>在 Java 这个多线程的系统中，对线程的监控是相当重要的。ThreadMXBean 就是起到这个作用。ThreadMXBean 可以提供的信息包括各个线程的各种状态，CPU 占用情况，以及整个系统中的线程状况。从 ThreadMXBean 可以得到某一个线程的 ThreadInfo 对象。这个对象中则包含了这个线程的所有信息。</p>
<h2 id="java-lang-management-和虚拟机的关系"><a href="#java-lang-management-和虚拟机的关系" class="headerlink" title="java.lang.management 和虚拟机的关系"></a>java.lang.management 和虚拟机的关系</h2><p>我们知道，management 和底层虚拟机的关系是非常紧密的。其实，有一些的是直接依靠虚拟机提供的公开 API 实现的，比如 JVMTI；而另外一些则不然，很大一块都是由虚拟机底层提供某些不公开的 API / Native Code 提供的。这样的设计方式，保证了 management 包可以提供足够的信息，并且使这些信息的提供又有足够的效率；也使 management 包和底层的联系非常紧密。</p>
<h2 id="锁检测"><a href="#锁检测" class="headerlink" title="锁检测"></a>锁检测</h2><p>我们知道，同步是 Java 语言很重要的一个特性。在 Java SE 中，最主要的同步机制是依靠 synchronize 关键字对某一个对象加锁实现的；在 Java SE 5 之后的版本中，concurrent 包的加入，大大强化了 Java 语言的同步能力，concurrent 提供了很多不同类型的锁机制可供扩展。因此，要更好地观测当前的虚拟机状况和不同线程的运行态，去观察虚拟机中的各种锁，以及线程与锁的关系是非常必要的。很可惜的是，在过去的 JDK 中，我们并没有非常方便的 API 以供使用。一个比较直接的检测方式是查看线程的 stack trace，更为强大全面（但是也更复杂并且效率低下）的方案是得到一个 VM 所有对象的快照并查找之，这些策略的代价都比较大，而且往往需要编写复杂的 Native 代码。</p>
<p>JDK 6 里提供了一些相当简单的 API 来提供这个服务。首先了解两个新类，LockInfo 和 MonitorInfo 这两个类承载了锁的信息。LockInfo 可以是任何的 Java 锁，包括简单 Java 锁和 java.util.concurrent 包中所使用的锁（包括 AbstractOwnableSynchronizer 和 Condition 的实现类 / 子类），而 MonitorInfo 是简单的 Java 对象所代表的锁。要检测一个线程所拥有的锁和等待的锁，首先，要得到一个线程的 ThreadInfo，然后可以简单地调用：</p>
<p>getLockedMonitors()</p>
<p>返回一个所有当前线程已经掌握的锁对象的列表。</p>
<p>getLockedSynchronizers()</p>
<p>对于使用 concurrent 包的线程，返回一个该线程所掌握的”ownable synchronizer”（即 AbstractOwnableSynchronizer 及其子类）所组成的列表。</p>
<p>getLockInfo()</p>
<p>当前线程正在等待的那个锁对象的信息就可以知道线程所有的锁信息。通过这些锁信息，我们很方便的可以知道当前虚拟机的所有线程的锁信息。由此，我们还可以推导出更多的信息。</p>
<h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>死锁检测一直以来是软件工程师所重视的，显然一个死锁的系统永远是工程师最大的梦魇。Java 程序的死锁检测也一直以来是 Java 程序员所头痛的。为了解决线程间死锁问题，一般都有预防（代码实现阶段）和死锁后恢复（运行时）两种方式。以前 Java 程序员都重视前者，因为在运行态再来检测和恢复系统是相当麻烦的，缺少许多必要的信息；但是，对于一些比较复杂的系统，采取后者或者运行时调试死锁信息也是非常重要的。由上面所说，现在我们已经可以知道每一个线程所拥有和等待的锁，因此要计算出当前系统中是否有死锁的线程也是可行的了。当然，Java 6 里面也提供了一个 API 来完成这个功能，即：</p>
<p>ThreadMXBean.findDeadlockedThreads()</p>
<p>这个函数的功能就是检测出当前系统中已经死锁的线程。当然，这个功能复杂，因此比较费时。基本上仅仅将之用于调试，以便对复杂系统线程调用的改进。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/24/BNF&EBNF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/24/BNF&EBNF/" class="post-title-link" itemprop="url">BNF&EBNF</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-01-24 08:00:00 / Modified: 11:50:43" itemprop="dateCreated datePublished" datetime="2021-01-24T08:00:00+08:00">2021-01-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="BNF"><a href="#BNF" class="headerlink" title="BNF"></a>BNF</h2><p>巴科斯范式(BNF: Backus-Naur Form 的缩写)是由 John Backus 和 Peter Naur 首先引入的用来描述计算机语言语法的符号集。现在，几乎每一位新编程语言书籍的作者都使用巴科斯范式来定义编程语言的语法规则。</p>
<p>在 BNF 中，双引号中的字(“word”)代表着这些字符本身。而 double_quote 用来代表双引号。</p>
<p>在双引号外的字（有可能有下划线）代表着语法部分。</p>
<p>&lt; &gt; : 内包含的为必选项。<br>　　[ ] : 内包含的为可选项。<br>　　{ } : 内包含的为可重复 0 至无数次的项。<br>　　| : 表示在其左右两边任选一项，相当于”OR”的意思。<br>　　::= : 是“被定义为”的意思<br>　　“…” : 术语符号<br>　　[…] : 选项，最多出现一次<br>　　{…} : 重复项，任意次数，包括 0 次<br>　　(…) : 分组<br>　　| : 并列选项，只能选一个<br>　　斜体字: 参数，在其它地方有解释</p>
<p>下面是是用 BNF 来定义的 Java 语言中的 For 语句的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FOR_STATEMENT ::&#x3D;</span><br><span class="line">      &quot;for&quot; &quot;(&quot; ( variable_declaration |</span><br><span class="line">  ( expression &quot;;&quot; ) | &quot;;&quot; )</span><br><span class="line">      [ expression ] &quot;;&quot;</span><br><span class="line">      [ expression ] &quot;;&quot;</span><br><span class="line">      &quot;)&quot; statement</span><br></pre></td></tr></table></figure>

<h2 id="EBNF"><a href="#EBNF" class="headerlink" title="EBNF"></a>EBNF</h2><p>扩展巴科斯-瑙尔范式(Extended Backus–Naur Form,EBNF)是一种用于描述计算机编程语言等正式语言的与上下文无关语法的元语法(metasyntax)符号表示法。简而言之，它是一种描述语言的语言。它是基本巴科斯范式(BNF)元语法符号表示法的一种扩展。</p>
<p>最初由尼克劳斯·维尔特开发，最常用的 EBNF 变体由标准是 ISO-14977 所定义。</p>
<p>EBNF 的基本语法形式如下，这个形式也被叫做 production：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">左式(LeftHandSide) &#x3D; 右式(RightHandSide).</span><br></pre></td></tr></table></figure>

<p>左式也被叫做 非终端符号(non-terminal symbol)，而右式则描述了其的组成。</p>
<h4 id="终端符号与非终端符号"><a href="#终端符号与非终端符号" class="headerlink" title="终端符号与非终端符号"></a>终端符号与非终端符号</h4><ul>
<li>终端符号(Terminal symbols)：形成所描述的语言的最基本符号。所描述语言的标点符号(不是 EBNF 自己的)会被左右加引号(它们也是终端符号)，而其他终端符号会用粗体(这边因不方便加粗，就不加粗了)打印。</li>
<li>非终端符号：是用于描述语法的变量，它必须被定义在一个 production 中。或说，它们必须出现在某个地方的 production 的左式中。</li>
</ul>
<h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><p><img src="/images/ss/bnf1.png"></p>
<h4 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h4><p>1 .使用了如下约定:</p>
<ul>
<li>EBNF 的每个元标识符(meta-identifier)都被写为用连字符(“-“,hyphens)连接起来的一个或多个单词；</li>
<li>以 “-symbol” 结束的元标识符是 EBNF 的终端符号。</li>
</ul>
<p>2 .用普通字符表示的 EBNF 操作符按照优先级(顶部为最高优先级)排序为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*repetition-symbol(重复符)</span><br><span class="line">-except-symbol(除去符)</span><br><span class="line">, concatenate-symbol(连接符)</span><br><span class="line">| definition-separator-symbol</span><br><span class="line">&#x3D; defining-symbol(定义符)</span><br><span class="line">; terminator-symbol(结束符)</span><br><span class="line">. terminator-symbol(结束符)</span><br></pre></td></tr></table></figure>

<p>3 .以下的括号对(bracket pairs)能够改变优先级，括号对间也有优先级(顶部为最高优先级):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#39;  first-quote-symbol            first-quote-symbol  &#39;    (* 引用 *)</span><br><span class="line">&quot;  second-quote-symbol          second-quote-symbol  &quot;    (* 引用 *)</span><br><span class="line">(* start-comment-symbol          end-comment-symbol *)    (* 注释 *)</span><br><span class="line">(  start-group-symbol              end-group-symbol  )    (* 分组 *)</span><br><span class="line">[  start-option-symbol            end-option-symbol  ]    (* 可选 *)</span><br><span class="line">&#123;  start-repeat-symbol            end-repeat-symbol  &#125;    (* 重复 *)</span><br><span class="line">?  special-sequence-symbol   special-sequence-symbol ?    (* 特殊序列 *)</span><br></pre></td></tr></table></figure>

<p>下例示范了怎么表达重复：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aa &#x3D; &quot;A&quot;;</span><br><span class="line">bb &#x3D; 3 * aa, &quot;B&quot;;</span><br><span class="line">cc &#x3D; 3 * [aa], &quot;C&quot;;</span><br><span class="line">dd &#x3D; &#123;aa&#125;, &quot;D&quot;;</span><br><span class="line">ee &#x3D; aa, &#123;aa&#125;, &quot;E&quot;;</span><br><span class="line">ff &#x3D; 3 * aa, 3 * [aa], &quot;F&quot;;</span><br><span class="line">gg &#x3D; &#123;3 * aa&#125;, &quot;D&quot;;</span><br></pre></td></tr></table></figure>

<p>这些规则定义的终端字符串如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aa: A</span><br><span class="line">bb: AAAB</span><br><span class="line">cc: C AC AAC AAAC</span><br><span class="line">dd: D AD AAD AAAD AAAAD etc.</span><br><span class="line">ee: AE AAE AAAE AAAAE AAAAAE etc.</span><br><span class="line">ff: AAAF AAAAF AAAAAF AAAAAAF</span><br><span class="line">gg: D AAAD AAAAAAD etc.</span><br></pre></td></tr></table></figure>

<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>除了标准的定义，在 FREESCALE 文档中还使用了以下约定：</p>
<ul>
<li>计数重复：任何由”{“和”}”括起来并后跟一个上标 x 的东西必须准确地重复出现 x 次。x 也可能是一个非终端字符。比如下例中，Stars 相当于四个星号：<br>Stars = {“*”}4.</li>
<li>字节数：见到任何紧跟着由一对中括号“[”和“]”括起来的数字 n 的标识符，都应该认为它是一个高位字节在前的二进制数，并且字节数为 n，如：<br>Struct=RefNo FilePos[4].</li>
<li>在一些例子中，我们会使用”&lt;”和”&gt;”括起来一些文本。这些文本是 元文本(meta–literal)，它们的位置应该被它们所描述的东西替代掉，如，对于 &lt; any char &gt;，它的位置可以插入任意字符。</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>以下提供一些示例以直观的理解 EBNF。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">digit excluding zero &#x3D; &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot; ;</span><br><span class="line">digit                &#x3D; &quot;0&quot; | digit excluding zero ;</span><br><span class="line">natural number &#x3D; digit excluding zero, &#123; digit &#125; ;</span><br><span class="line">integer &#x3D; &quot;0&quot; | [ &quot;-&quot; ], natural number ;</span><br></pre></td></tr></table></figure>

<p>digit excluding zero 可以是 1 到 9 任意一个字符，digit 则扩展为 0 到 9 任意一个字符。<br>natural number 可以是 1、2、…、10、…、12345、…，因为{}代表重复任意次，包括 0 次。<br>integer 则可以是 0 或者可能带个负号的自然数。</p>
<p>这是用 EBNF 描述的 EBNF 自身语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Production     &#x3D; NonTerminal &quot;&#x3D;&quot; Expression &quot;.&quot;.</span><br><span class="line">Expression     &#x3D; Term &#123;&quot;|&quot; Term&#125;.</span><br><span class="line">Term           &#x3D; Factor &#123;Factor&#125;.</span><br><span class="line">Factor         &#x3D; NonTerminal</span><br><span class="line">                 | Terminal</span><br><span class="line">                 | &quot;(&quot; Expression &quot;)&quot;</span><br><span class="line">                 | &quot;[&quot; Expression &quot;]&quot;</span><br><span class="line">                 | &quot;&#123;&quot; Expression &quot;&#125;&quot;.</span><br><span class="line">Terminal       &#x3D; Identifier | “&quot;“ &lt;any char&gt; “&quot;“.</span><br><span class="line">NonTerminal    &#x3D; Identifier.</span><br></pre></td></tr></table></figure>

<p>非终端符号可以是任意你喜欢的名字，而终端符号则要不然是出现在被描述的语言中的标识符，要不然就是任何被引号括起来的字符序列。<br>然后 Factor(参数)可以是终端字符、非终端字符、三种括号中任意一种括起来的表达式。<br>Term(术语)由起码一个 Factor 组合而成……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(* a simple program syntax in EBNF − Wikipedia *)</span><br><span class="line">program &#x3D; &#39;PROGRAM&#39;, white space, identifier, white space,</span><br><span class="line">           &#39;BEGIN&#39;, white space,</span><br><span class="line">           &#123; assignment, &quot;;&quot;, white space &#125;,</span><br><span class="line">           &#39;END.&#39; ;</span><br><span class="line">identifier &#x3D; alphabetic character, &#123; alphabetic character | digit &#125; ;</span><br><span class="line">number &#x3D; [ &quot;-&quot; ], digit, &#123; digit &#125; ;</span><br><span class="line">string &#x3D; &#39;&quot;&#39; , &#123; all characters - &#39;&quot;&#39; &#125;, &#39;&quot;&#39; ;</span><br><span class="line">assignment &#x3D; identifier , &quot;:&#x3D;&quot; , ( number | identifier | string ) ;</span><br><span class="line">alphabetic character &#x3D; &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; | &quot;G&quot;</span><br><span class="line">                     | &quot;H&quot; | &quot;I&quot; | &quot;J&quot; | &quot;K&quot; | &quot;L&quot; | &quot;M&quot; | &quot;N&quot;</span><br><span class="line">                     | &quot;O&quot; | &quot;P&quot; | &quot;Q&quot; | &quot;R&quot; | &quot;S&quot; | &quot;T&quot; | &quot;U&quot;</span><br><span class="line">                     | &quot;V&quot; | &quot;W&quot; | &quot;X&quot; | &quot;Y&quot; | &quot;Z&quot; ;</span><br><span class="line">digit &#x3D; &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot; ;</span><br><span class="line">white space &#x3D; ? white space characters ? ;</span><br><span class="line">all characters &#x3D; ? all visible characters ? ;</span><br></pre></td></tr></table></figure>

<p>对应的语法正确的程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PROGRAM DEMO1</span><br><span class="line">BEGIN</span><br><span class="line">  A:&#x3D;3;</span><br><span class="line">  B:&#x3D;45;</span><br><span class="line">  H:&#x3D;-100023;</span><br><span class="line">  C:&#x3D;A;</span><br><span class="line">  D123:&#x3D;B34A;</span><br><span class="line">  BABOON:&#x3D;GIRAFFE;</span><br><span class="line">  TEXT:&#x3D;&quot;Hello world!&quot;;</span><br><span class="line">END.</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/22/K8S/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/22/K8S/" class="post-title-link" itemprop="url">K8S</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-01-22 09:53:37 / Modified: 13:59:50" itemprop="dateCreated datePublished" datetime="2021-01-22T09:53:37+08:00">2021-01-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li>查看 pod：kubectl get pod -n <namespace> kubectl describe pod <pod> -n <namespace></namespace></pod></namespace></li>
<li>查看 pod 运行在哪个 node 节点：kubectl get pod -o wide -n <namespace></namespace></li>
<li>查看 pod 有哪些 label：kubectl get pod –show-labels -n <namespace></namespace></li>
<li>查看 node 有哪些 label：kubectl get nodes –show-labels</li>
<li>查看 service：kubectl get svc -n <namespace></namespace></li>
<li>进入容器的交互式 shell：kubectl exec <pod> -it - /bin/bash -n <namespace></namespace></pod></li>
<li>查看日志：kubectl logs <pod> -n <namespace></namespace></pod></li>
<li>查看后十行日志：kubectl logs <pod> –tail=10</pod></li>
<li>查看上次启动的日志：kubectl logs <pod> -p</pod></li>
<li>修改 image 版本：kubectl set image deployment nginx(deploy name) nginx(container name)=nginx:1.9.1</li>
<li>修改副本数：kubectl scale –replicas=3 deployment mysql</li>
<li>拷贝文件：kubectl cp mysql-478535978-1dnm2:/tmp/message.log message.log</li>
<li>查看 yaml 文件：cd /etc/kubernetes/apps/</li>
<li>应用 yaml 文件：kubectl apply -f xxx.yml</li>
</ul>
<h2 id="关键命令"><a href="#关键命令" class="headerlink" title="关键命令"></a>关键命令</h2><ul>
<li>驱逐 node 上所有 pod：kubectl taint node <node_name> key1=value1:NoExecute</node_name></li>
<li>驱逐 node 上 pod，不驱逐 ds：kubectl drain <node_name> –delete-local-data –force –ignore-daemonsets</node_name></li>
<li>恢复调度：kubectl uncordon <node_name></node_name></li>
<li>强制删除 namespace：kubectl delete namespace NAMESPACENAME –force –grace-period=0</li>
<li>命令行方式重启 Deployment：kubectl patch deployment my-app –patch ‘{“spec”: {“template”: {“metadata”: {“annotations”: {“version/config”: “20180411” }}}}}’</li>
<li>查看某个资源的字段意义：kubectl explain deployment.spec.template.spec.dnsPolicy</li>
<li>查看资源类型及版本：kubectl api-resources kubectl api-versions</li>
<li>创建一个测试的 deployment：kubectl run curl -it –image=pstauffer/curl 或 kubectl run curl -it –image=registry.sensetime.com/viper-test/curl</li>
<li>创建一个 nginx 的 deployment 并暴露服务：kubectl run nginx –image=nginx –expose –port=80</li>
<li>清理 docker 镜像：docker system prune -f 命令可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络，以及 dangling 镜像(即无 tag 的镜像)；docker system prune -af 命令清理得更加彻底，可以将没有容器使用 Docker 镜像都删掉。注意，这两个命令会把你暂时关闭的容器，以及暂时没有用到的 Docker 镜像都删掉。</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="deployment-yml"><a href="#deployment-yml" class="headerlink" title="deployment.yml"></a>deployment.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="service-yml"><a href="#service-yml" class="headerlink" title="service.yml"></a>service.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ingress-yml"><a href="#ingress-yml" class="headerlink" title="ingress.yml"></a>ingress.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="serviceMonitor-yml"><a href="#serviceMonitor-yml" class="headerlink" title="serviceMonitor.yml"></a>serviceMonitor.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/18/JDBC%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/18/JDBC%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">JDBC相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-18 10:00:00" itemprop="dateCreated datePublished" datetime="2021-01-18T10:00:00+08:00">2021-01-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-01-20 14:22:25" itemprop="dateModified" datetime="2021-01-20T14:22:25+08:00">2021-01-20</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="jdk8-源码解析之-sql-包：JDBC-源码解析"><a href="#jdk8-源码解析之-sql-包：JDBC-源码解析" class="headerlink" title="jdk8 源码解析之 sql 包：JDBC 源码解析"></a>jdk8 源码解析之 sql 包：JDBC 源码解析</h1><p>参考连接:<a target="_blank" rel="noopener" href="https://blog.csdn.net/mxy88888/article/details/94315198">https://blog.csdn.net/mxy88888/article/details/94315198</a></p>
<p>在开发项目时我们经常会需要与数据库进行交互，为了统一标准，在 java jdk 中提供了一组与数据库交互的 api（java.sql.*），每个厂商通过继承实现 sql 包下的接口和类完成与数据库交互的工作(例如 mysql-connector-java)。以 mysql 为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] arg) throws Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">    Connection connection&#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&quot;,&quot;root&quot;,&quot;123456&quot;);</span><br><span class="line">    PreparedStatement prepareStatement&#x3D;connection.prepareStatement(&quot;select * from student&quot;);</span><br><span class="line">    ResultSet resultSet&#x3D;prepareStatement.executeQuery();</span><br><span class="line">    while(resultSet.next())&#123;</span><br><span class="line">      System.out.println(resultSet.getString(&quot;id&quot;)+&quot;:&quot;+resultSet.getString(&quot;studname&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/jdbc2.png"></p>
<p>JDBC (Java Database Connectivity) API，即 Java 数据库编程接口，是一组标准的 Java 语言中的接口和类，使用这些接口和类，Java 客户端程序可以访问各种不同类型的数据库。比如建立数据库连接、执行 SQL 语句进行数据的存取操作。</p>
<p>JDBC 规范采用接口和实现分离的思想设计了 Java 数据库编程的框架。接口包含在 java.sql 及 javax.sql 包中，其中 java.sql 属于 JavaSE，javax.sql 属于 JavaEE。这些接口的实现类叫做数据库驱动程序，由数据库的厂商或其它的厂商或个人提供。</p>
<p>为了使客户端程序独立于特定的数据库驱动程序，JDBC 规范建议开发者使用基于接口的编程方式，即尽量使应用仅依赖 java.sql 及 javax.sql 中的接口和类。<br><img src="/images/jdbc1.png"></p>
<p>JDBC 驱动程序是各个数据库厂家根据 JDBC 的规范制作的 JDBC 实现类.</p>
<p>主要涉及到的类有：</p>
<ul>
<li>connection:接口类，mysql 封装了连接数据库的参数，辅助类，提供了 sql 语句执行，创建 statement 对象，提交，回滚等功能。</li>
<li>preparedStatement:接口类，保存 sql 执行语句，并提供查询，修改等方法。</li>
<li>Driver:驱动类，子类提供了返回 connection 对象方法的实现，以及一些辅助方法</li>
<li>DriverManager：驱动管理类，注册 Driver 对象<br>下面我们来一步步解析查询数据库的过程:</li>
</ul>
<ol>
<li><p>驱动类加载</p>
<p><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code><br>当我们看到这行代码时我们可能会有些疑惑：为什么开始要加载初始化这个驱动？那我们先看看它里面有什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Driver 类</span><br><span class="line">static &#123;</span><br><span class="line">try &#123;</span><br><span class="line">    java.sql.DriverManager.registerDriver(new Driver()); &#x2F;&#x2F;注册驱动</span><br><span class="line">&#125; catch (SQLException E) &#123;</span><br><span class="line">    throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;DriverManager 类</span><br><span class="line">private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers &#x3D; new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">public static synchronized void registerDriver(java.sql.Driver driver,</span><br><span class="line">        DriverAction da)</span><br><span class="line">    throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Register the driver if it has not already been added to our list *&#x2F;</span><br><span class="line">    if(driver !&#x3D; null) &#123;</span><br><span class="line">        registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); &#x2F;&#x2F;封装注册类并村主导</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; This is for compatibility with the original DriverManager</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(&quot;registerDriver: &quot; + driver);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到这里我们知道初始化类是为了调用 DriverManager.registerDriver 方法对 Driver 进行注册。在注册方法中将获取到的 Driver 对象封装了一遍存入 registeredDrivers 集合里，这里 registeredDrivers 是 DirverManager 里的一个 list 集合对象，CopyOnWriteArrayList 是一个线程安全 list 集合类。所以 jdbc 可以允许我们在同一项目中加载不同的驱动类去连接多个的数据库。</p>
<p>Driver 类加载完成之后接下来是<br><code>Connection connection= DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;,&quot;root&quot;,&quot;123456&quot;);</code><br>这一段是返回 connection 对象的操作，我们看一下 DriverManager 内源码，其中有一段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    loadInitialDrivers();  &#x2F;加载初始化其他驱动类</span><br><span class="line">    println(&quot;JDBC DriverManager initialized&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void loadInitialDrivers() &#123;</span><br><span class="line">    String drivers;</span><br><span class="line">    try &#123;</span><br><span class="line">        drivers &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() &#123;  &#x2F;&#x2F;跳过权限验证从系统变量中获取驱动</span><br><span class="line">            public String run() &#123;</span><br><span class="line">                return System.getProperty(&quot;jdbc.drivers&quot;); &#x2F;&#x2F;获取jdbc.drivers变量</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">        drivers &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; If the driver is packaged as a Service Provider, load it.</span><br><span class="line">    &#x2F;&#x2F; Get all the drivers through the classloader</span><br><span class="line">    &#x2F;&#x2F; exposed as a java.sql.Driver.class service.</span><br><span class="line">    &#x2F;&#x2F; ServiceLoader.load() replaces the sun.misc.Providers()</span><br><span class="line"></span><br><span class="line">    AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        public Void run() &#123;</span><br><span class="line"></span><br><span class="line">            ServiceLoader&lt;Driver&gt; loadedDrivers &#x3D; ServiceLoader.load(Driver.class);&#x2F;&#x2F;通过ServiceLoader动态加载驱动类</span><br><span class="line">            Iterator&lt;Driver&gt; driversIterator &#x3D; loadedDrivers.iterator();</span><br><span class="line"></span><br><span class="line">            &#x2F;* Load these drivers, so that they can be instantiated.</span><br><span class="line">            * It may be the case that the driver class may not be there</span><br><span class="line">            * i.e. there may be a packaged driver with the service class</span><br><span class="line">            * as implementation of java.sql.Driver but the actual class</span><br><span class="line">            * may be missing. In that case a java.util.ServiceConfigurationError</span><br><span class="line">            * will be thrown at runtime by the VM trying to locate</span><br><span class="line">            * and load the service.</span><br><span class="line">            *</span><br><span class="line">            * Adding a try catch block to catch those runtime errors</span><br><span class="line">            * if driver not available in classpath but it&#39;s</span><br><span class="line">            * packaged as service and that service is there in classpath.</span><br><span class="line">            *&#x2F;</span><br><span class="line">            try&#123;</span><br><span class="line">                while(driversIterator.hasNext()) &#123;</span><br><span class="line">                    driversIterator.next(); &#x2F;&#x2F;遍历并初始化对象</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch(Throwable t) &#123;</span><br><span class="line">            &#x2F;&#x2F; Do nothing</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    println(&quot;DriverManager.initialize: jdbc.drivers &#x3D; &quot; + drivers);</span><br><span class="line"></span><br><span class="line">    if (drivers &#x3D;&#x3D; null || drivers.equals(&quot;&quot;)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] driversList &#x3D; drivers.split(&quot;:&quot;); &#x2F;&#x2F;从系统变量中获取的完全限定名</span><br><span class="line">    println(&quot;number of Drivers:&quot; + driversList.length);</span><br><span class="line">    for (String aDriver : driversList) &#123;  &#x2F;&#x2F;遍历驱动名并初始化</span><br><span class="line">        try &#123;</span><br><span class="line">            println(&quot;DriverManager.Initialize: loading &quot; + aDriver);</span><br><span class="line">            Class.forName(aDriver, true,</span><br><span class="line">                    ClassLoader.getSystemClassLoader());</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            println(&quot;DriverManager.Initialize: load failed: &quot; + ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 DriverMnager 中有一段静态代码块，我们第一次调用时会执行里面的 loadInitialDrivers 方法完成第二次驱动的加载，这里加载驱动的方式有两种。一种是通过获取系统的环境变量 jdbc.drivers 得到驱动类的完全限定名并通过反射进行初始化注册，另一个是通过 serviceLoader（参考 Java 的 SPI）动态获取驱动类对象完成注册，两种方式都在 AccessController.doPrivileged 内执行，是为了跳过<code>虚拟机权限验证</code>。</p>
</li>
<li><p>返回 connection 对象<br>再次定位到这行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection connection&#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&quot;,&quot;root&quot;,&quot;123456&quot;);</span><br></pre></td></tr></table></figure>

<p>查看 getConnection 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">@CallerSensitive</span><br><span class="line">public static Connection getConnection(String url,</span><br><span class="line">    String user, String password) throws SQLException &#123;</span><br><span class="line">    java.util.Properties info &#x3D; new java.util.Properties();</span><br><span class="line"></span><br><span class="line">    if (user !&#x3D; null) &#123;</span><br><span class="line">        info.put(&quot;user&quot;, user);</span><br><span class="line">    &#125;</span><br><span class="line">    if (password !&#x3D; null) &#123;</span><br><span class="line">        info.put(&quot;password&quot;, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Connection getConnection(</span><br><span class="line">    String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    * When callerCl is null, we should check the application&#39;s</span><br><span class="line">    * (which is invoking this class indirectly)</span><br><span class="line">    * classloader, so that the JDBC driver class outside rt.jar</span><br><span class="line">    * can be loaded from here.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    ClassLoader callerCL &#x3D; caller !&#x3D; null ? caller.getClassLoader() : null; &#x2F;&#x2F;获取当前线程的类加载器</span><br><span class="line">    synchronized(DriverManager.class) &#123;</span><br><span class="line">        &#x2F;&#x2F; synchronize loading of the correct classloader.</span><br><span class="line">        if (callerCL &#x3D;&#x3D; null) &#123;</span><br><span class="line">            callerCL &#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(url &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new SQLException(&quot;The url cannot be null&quot;, &quot;08001&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(&quot;DriverManager.getConnection(\&quot;&quot; + url + &quot;\&quot;)&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Walk through the loaded registeredDrivers attempting to make a connection.</span><br><span class="line">    &#x2F;&#x2F; Remember the first exception that gets raised so we can reraise it.</span><br><span class="line">    SQLException reason &#x3D; null;</span><br><span class="line"></span><br><span class="line">    for(DriverInfo aDriver : registeredDrivers) &#123;  &#x2F;&#x2F;遍历注册信息</span><br><span class="line">        &#x2F;&#x2F; If the caller does not have permission to load the driver then</span><br><span class="line">        &#x2F;&#x2F; skip it.</span><br><span class="line">        if(isDriverAllowed(aDriver.driver, callerCL)) &#123;  &#x2F;&#x2F;判断该驱动是否是callerCL加载器加载的</span><br><span class="line">            try &#123;</span><br><span class="line">                println(&quot;    trying &quot; + aDriver.driver.getClass().getName());</span><br><span class="line">                Connection con &#x3D; aDriver.driver.connect(url, info);  &#x2F;&#x2F;通过驱动器返回connection对象</span><br><span class="line">                if (con !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Success!</span><br><span class="line">                    println(&quot;getConnection returning &quot; + aDriver.driver.getClass().getName());</span><br><span class="line">                    return (con);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException ex) &#123;</span><br><span class="line">                if (reason &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    reason &#x3D; ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println(&quot;    skipping: &quot; + aDriver.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; if we got here nobody could connect.</span><br><span class="line">    if (reason !&#x3D; null)    &#123;</span><br><span class="line">        println(&quot;getConnection failed: &quot; + reason);</span><br><span class="line">        throw reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(&quot;getConnection: no suitable driver found for &quot;+ url);</span><br><span class="line">    throw new SQLException(&quot;No suitable driver found for &quot;+ url, &quot;08001&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上通过备注我们知道，这个是一个获取 connection 对象的过程，先是遍历 registerDrivers 集合获取每个驱动器，然后进行验证，成功后返回该驱动器。到这里 jdbc 的源码解析就结束了，因为 sql 包中很多都是接口需要子类进行实现，所以接下来要说的都是 mysql 继承接口中的实现，我也不细说大概点一下。</p>
</li>
<li><p>获取 PreparedStatement 对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement prepareStatement&#x3D;connection.prepareStatement(&quot;select * from student&quot;);</span><br></pre></td></tr></table></figure>

<p>这里我们通过 connection 得到了 preparedstatement，preparedstatement 继承自 statement，里面保存了 sql 语句对象，并提供了查询 sql 的方法。</p>
</li>
<li><p>获取 ResultSet 对象<br><code>ResultSet resultSet=prepareStatement.executeQuery();</code></p>
<p>在这里 statement 对象调用了 executeQuery 方法，里面将会执行发送 sql 以及获取数据的操作，在 mysql 中是通过 Socket 对象进行操作的。方法返回 ResultSet，存储了查询的结果。获取 resultSet 对象后通过 next 方法移动游标定位信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(resultSet.next())&#123;</span><br><span class="line">System.out.println(resultSet.getString(&quot;id&quot;)+&quot;:&quot;+resultSet.getString(&quot;studname&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上就是 jdbc 源码的讲解。</p>
</li>
</ol>
<h1 id="java-sql-里面有什么？"><a href="#java-sql-里面有什么？" class="headerlink" title="java.sql 里面有什么？"></a>java.sql 里面有什么？</h1><p>java.sql 包中包含用于以下方面的 API：</p>
<ul>
<li>通过 DriverManager 实用程序建立与数据库的连接 bai</li>
<li>DriverManager 类：建立与驱动程序的连接</li>
<li>SQLPermission 类：代码在 Security Manager（比如 applet）中运行时提供权限，试图通过 DriverManager 设置一个记录流</li>
<li>Driver 接口：提供用来注册和连接基于 JDBC 技术（“JDBC 驱动程序”）的驱动程序的 API，通常仅由 DriverManager 类使用</li>
<li>DriverPropertyInfo 类：提供 JDBC 驱动程序的属性，不是供一般用户使用的向数据库发送 SQL 语句</li>
<li>Statement：用于发送基本 SQL 语句</li>
<li>PreparedStatement：用于发送准备好的语句或基本 SQL 语句（派生自 Statement）</li>
<li>CallableStatement：用于调用数据库存储过程（派生自 PreparedStatement）</li>
<li>Connection 接口：提供创建语句以及管理连接及其属性的方法</li>
<li>Savepoint：在事务中提供保存点</li>
<li>获取和更新查询的结果</li>
<li>ResultSet 接口</li>
<li>SQL 类型到 Java 编程语言中的类和接口的标准映射关系<ul>
<li>Array 接口：SQL ARRAY 的映射关系</li>
<li>Blob 接口：SQL BLOB 的映射关系</li>
<li>Clob 接口：SQL CLOB 的映射关系</li>
<li>Date 类：SQL DATE 的映射关系</li>
<li>…..</li>
</ul>
</li>
<li>元数据<ul>
<li>DatabaseMetaData 接口：提供有关数据库的信息</li>
<li>ResultSetMetaData 接口：提供有关 ResultSet 对象的列的信息</li>
<li>ParameterMetaData 接口：提供有关 PreparedStatement 命令的参数的信息</li>
</ul>
</li>
<li>异常<ul>
<li>SQLException：由大多数方法在访问数据出问题时抛出，以及因为其他原因由其他一些方法抛出</li>
<li>SQLWarning：为了指示一个警告而抛出</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/17/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/17/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD/" class="post-title-link" itemprop="url">Web服务器高并发和高性能</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-01-17 21:00:00 / Modified: 11:15:40" itemprop="dateCreated datePublished" datetime="2021-01-17T21:00:00+08:00">2021-01-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>从根上理解高性能、高并发<br>链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/imstudy/p/14179129.html">https://www.cnblogs.com/imstudy/p/14179129.html</a></p>
<p>高性能网络编程<br>链接： <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/214330310">https://zhuanlan.zhihu.com/p/214330310</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/17/ORM%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/17/ORM%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">ORM相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-01-17 15:00:00 / Modified: 16:09:41" itemprop="dateCreated datePublished" datetime="2021-01-17T15:00:00+08:00">2021-01-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="ORM-相关"><a href="#ORM-相关" class="headerlink" title="ORM 相关"></a>ORM 相关</h2><p>Object·/Relation Mapping 对象/关系数据库映射，他完成的是面向对象的编程语言到关系型数据库的映射，所以你可以理解为 ORM 其实就是应用程序和数据库的桥梁。</p>
<h2 id="JPA-规范"><a href="#JPA-规范" class="headerlink" title="JPA 规范"></a>JPA 规范</h2><p>JPA 规范本质上就是一种 ORM 规范。Hibernate 实现了这套规范。<br><img src="/images/orm1.png"></p>
<h2 id="JPQL-比较-SQL"><a href="#JPQL-比较-SQL" class="headerlink" title="JPQL 比较 SQL"></a>JPQL 比较 SQL</h2><p>jpql 与 SQL 的区别就是 SQL 是面向对象关系数据库，他操作的是数据表和数据列，而 jpql 操作的对象是实体对象和实体属性。<br>下面是 JPQL 的基本格式，根据基本格式我们执行 jpql 语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select 实体别名.属性名， 实体别名.属性名 from 实体名 as 实体别名 where 实体别名.实体属性 op 比较值；</span><br><span class="line">select p.name from book as p ；</span><br></pre></td></tr></table></figure>

<h2 id="Mybatis-对比-Hibernate"><a href="#Mybatis-对比-Hibernate" class="headerlink" title="Mybatis 对比 Hibernate"></a>Mybatis 对比 Hibernate</h2><h4 id="国人用-Mybatis-的原因："><a href="#国人用-Mybatis-的原因：" class="headerlink" title="国人用 Mybatis 的原因："></a>国人用 Mybatis 的原因：</h4><ol>
<li>大厂带节奏 国内做互联网的 Java 程序很多都是拷贝阿里的，阿里一开始用例 iBatis（日本韩国是怎么回事呢）。大量的老系统都是基于 iBatis/MyBatis 的，市场上对 MyBatis 熟悉的人才更多，招聘和培训更容易，有的青年程序员以为“MyBatis 早已统一全球了”就是一个很好的证明。</li>
</ol>
<ol start="2">
<li>简单，学习成本低 小公司需要大量入门级的程序员，像大神甚至一个都请不起，请问大神们那些牛 b 框架哪个更快让菜鸟们上手，降低公司学习成本。注意这个成本会一直跟随公司，想必大神们创业直接前后端分离了，毕竟钱嘛多的是。</li>
</ol>
<ol start="3">
<li>对于复杂性需求的灵活性高 国内绝大部分项目都是面向表结构编程的，把 java 对象仅当成数据容器，查询和模型变更都设计在一张表上，所谓业务逻辑就是一堆增删改查的 sql 集合，当然用 mybatis 方便。在逻辑不复杂，或者你判断软件生命周期不会超过一年的时候，直接用表结构编程是最方便快捷的。国内普遍都是分布式，流量和性能决定了需要经常进行优化，而是用 Mybatis 对复杂需求的优化很方便。</li>
</ol>
<ol start="4">
<li>政治环境 国内好多项目都是应付领导的某些奇葩需求。需要面向领导编程。一大半时间其实都是在解决领导的需求。国内项目需要大量报表统计（看看帆软卖的这么好就知道了），需要提供给领导作为决策。看到这里，各位领导不要骂我 ，真的不是黑领导的。</li>
</ol>
<ol start="5">
<li>Hibernate 学习成本高 虽然，实际上 SpringDataJPA 是非常简单的，但是，但是，JPA/Hibernate 后期调试跟踪问题很麻烦，改起来也麻烦。别忘了，牛逼如你的人全公司甚至一个都没。还有什么缓存什么 Criteria 什么 Lazy，虽然这些你学了也不见得能用上，但一个框架，你不学还是不行的。而且，JPA 对于增删改很方便，复杂查询却是软肋，有同学会说，JPA 也能写 SQL 语句啊，我想说的是，既然都用 orm 了，你再写 sql，那不就失去了 oop 的内涵了吗？不优雅好吧。</li>
</ol>
<h4 id="老外喜欢-JPA-的原因"><a href="#老外喜欢-JPA-的原因" class="headerlink" title="老外喜欢 JPA 的原因:"></a>老外喜欢 JPA 的原因:</h4><ol>
<li><p>很多老外对 Mybatis 的认知还停留在 iBatis 阶段 实际上在 Mybatis 的应用场景里面，开发者要的就是自动封装，把 sql 查询结果转化为指定的 java 对象。这个在 iBatis 阶段，需要开发者自己定义大量的 xml 配置，去指定数据库表字段与 Java 实体类之间的关系。并且，对于每一条 sql，都需要在 xml 中写相应的语句，虽然有代码生成器，带开发量还是不小的。但 Mybatis 发展到今天，已经非常完美地做好了自动封装数据对象这件事，支持的插件也比较丰富。对于常见的增删改查，也不需要自己写一行代码，这已经无限接近于 Hibernate 的能力了。</p>
</li>
<li><p>喜欢 OOP、DDD，认为写 SQL 不优雅 用 jpa 的核心是让我们关注对象建模，而不是关心底层数据库映射。只有你在考虑数据和行为在一起的充血模型、贴身职责，聚合根状态变迁，值对象不变性的情况下，你才会发现 jpa 给你提供了很多便利，根本不需要关注底层存储模型。在复杂的逻辑、超长的软件生命周期。使用 DDD 的设计方法是目前看比较合理的选择，维护的成本比较低。<br>DDD 全称是（Domain-Driven Design)这是 2004 年就出来的理论，复杂逻辑的应对之道。DDD 大会在欧洲等地办了一届又一届，CQRS、Event Sourcing 等探索层出不穷，这也是为什么国外比较流行 JPA 原因。<br>不过，国内主要是随着这两年随着微服务火爆也有人谈起来 DDD 了。<br>但其实 DDD 也不是银弹，需要大拿能把控全局，国内缺的就是这种大拿，搬砖的太多。</p>
</li>
<li><p>有些老外在技术选型时，不会考虑除 Spring 这种知名框架外的其他技术 无他，唯手熟尔。国外一个项目，做了几年十几年都是很正常的。我以前接触过一个巴基斯坦的电商项目，做了十几年，也跑的好好的，这就是证据。使用技术也是有惯性的。</p>
</li>
<li><p>数据体量和种类没有达到 个人感觉，也咨询了国际友人。老外的项目，在数据体量和种类上完全达不到国内的水平。所以，他们对于性能上的渴求度没有那么高。追求的是稳定，可维护性好。国内一个双 11，如果用 hibernate，那只能死掉了。</p>
</li>
</ol>
<h4 id="Mybatis-优势"><a href="#Mybatis-优势" class="headerlink" title="Mybatis 优势"></a>Mybatis 优势</h4><ul>
<li>MyBatis 可以进行更为细致的 SQL 优化，可以减少查询字段。</li>
<li>MyBatis 容易掌握，而 Hibernate 门槛较高。</li>
</ul>
<h4 id="Hibernate-优势"><a href="#Hibernate-优势" class="headerlink" title="Hibernate 优势"></a>Hibernate 优势</h4><ul>
<li>Hibernate 的 DAO 层开发比 MyBatis 简单，不需要写 sql，Mybatis 需要维护 SQL 和结果映射。</li>
<li>Hibernate 对对象的维护和缓存要比 MyBatis 好，对增删改查的对象的维护要方便。</li>
<li>Hibernate 数据库移植性很好，MyBatis 的数据库移植性不好，不同的数据库需要写不同 SQL。</li>
<li>Hibernate 有更好的二级缓存机制，可以使用第三方缓存。MyBatis 本身提供的缓存机制不佳。<br>hibernate 让你不用写 sql 了，这不单可以让你的应用更好移植其它数据库，更主要的是让程序员更专注业务逻辑、数据关系、对象关系等。<br>参考连接:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34298019">https://zhuanlan.zhihu.com/p/34298019</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/17/Redis%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/17/Redis%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">Redis相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-01-17 14:00:00 / Modified: 14:10:12" itemprop="dateCreated datePublished" datetime="2021-01-17T14:00:00+08:00">2021-01-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Redis-中使用-lua"><a href="#Redis-中使用-lua" class="headerlink" title="Redis 中使用 lua"></a>Redis 中使用 lua</h2><p>一、简介</p>
<ol>
<li><p>Redis 中为什么引入 Lua 脚本？</p>
<p>Redis 是高性能的 key-value 内存数据库，在部分场景下，是对关系数据库的良好补充。<br>Redis 提供了非常丰富的指令集，官网上提供了 200 多个命令。但是某些特定领域，需要扩充若干指令原子性执行时，仅使用原生命令便无法完成。<br>Redis 为这样的用户场景提供了 lua 脚本支持，用户可以向服务器发送 lua 脚本来执行自定义动作，获取脚本的响应数据。<br>Redis 服务器会单线程原子性执行 lua 脚本，保证 lua 脚本在处理的过程中不会被任意其它请求打断。</p>
</li>
<li><p>Redis 意识到上述问题后</p>
<p>在 2.6 版本推出了 lua 脚本功能，允许开发者使用 Lua 语言编写脚本传到 Redis 中执行。使用脚本的好处如下:减少网络开销。可以将多个请求通过脚本的形式一次发送，减少网络时延。<br>原子操作。Redis 会将整个脚本作为一个整体执行，中间不会被其他请求插入。因此在脚本运行过程中无需担心会出现竞态条件，无需使用事务。<br>复用。客户端发送的脚本会永久存在 redis 中，这样其他客户端可以复用这一脚本，而不需要使用代码完成相同的逻辑。</p>
</li>
<li><p>什么是 Lua？</p>
<p>Lua 是一种轻量小巧的脚本语言，用标准 C 语言编写并以源代码形式开放。<br>其设计目的就是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。因为广泛的应用于：游戏开发、独立应用脚本、Web 应用脚本、扩展和数据库插件等。<br>比如：Lua 脚本用在很多游戏上，主要是 Lua 脚本可以嵌入到其他程序中运行，游戏升级的时候，可以直接升级脚本，而不用重新安装游戏。</p>
</li>
</ol>
<p>二、Redis 中 Lua 的常用命令</p>
<p>命令不多，就下面这几个：</p>
<ul>
<li><p>EVAL</p>
</li>
<li><p>EVALSHA</p>
</li>
<li><p>SCRIPT LOAD - SCRIPT EXISTS</p>
</li>
<li><p>SCRIPT FLUSH</p>
</li>
<li><p>SCRIPT KILL</p>
<p>2.1 EVAL 命令<br>命令格式：EVAL script numkeys key [key …] arg [arg …]</p>
</li>
<li><p>script 参数是一段 Lua5.1 脚本程序。脚本不必(也不应该[^1])定义为一个 Lua 函数</p>
</li>
<li><p>numkeys 指定后续参数有几个 key，即：key [key …]中 key 的个数。如没有 key，则为 0</p>
</li>
<li><p>key [key …] 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)。在 Lua 脚本中通过 KEYS[1], KEYS[2]获取。</p>
</li>
<li><p>arg [arg …] 附加参数。在 Lua 脚本中通过 ARGV[1],ARGV[2]获取。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 例1：numkeys&#x3D;1，keys数组只有1个元素key1，arg数组无元素</span><br><span class="line">127.0.0.1:6379&gt; EVAL &quot;return KEYS[1]&quot; 1 key1</span><br><span class="line">&quot;key1&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 例2：numkeys&#x3D;0，keys数组无元素，arg数组元素中有1个元素value1</span><br><span class="line">127.0.0.1:6379&gt; EVAL &quot;return ARGV[1]&quot; 0 value1</span><br><span class="line">&quot;value1&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 例3：numkeys&#x3D;2，keys数组有两个元素key1和key2，arg数组元素中有两个元素first和second</span><br><span class="line">&#x2F;&#x2F;      其实&#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;表示的是Lua语法中“使用默认索引”的table表，</span><br><span class="line">&#x2F;&#x2F;      相当于java中的map中存放四条数据。Key分别为：1、2、3、4，而对应的value才是：KEYS[1]、KEYS[2]、ARGV[1]、ARGV[2]</span><br><span class="line">&#x2F;&#x2F;      举此例子仅为说明eval命令中参数的如何使用。项目中编写Lua脚本最好遵从key、arg的规范。</span><br><span class="line">127.0.0.1:6379&gt; eval &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 2 key1 key2 first second</span><br><span class="line">1) &quot;key1&quot;</span><br><span class="line">2) &quot;key2&quot;</span><br><span class="line">3) &quot;first&quot;</span><br><span class="line">4) &quot;second&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 例4：使用了redis为lua内置的redis.call函数</span><br><span class="line">&#x2F;&#x2F;      脚本内容为：先执行SET命令，在执行EXPIRE命令</span><br><span class="line">&#x2F;&#x2F;      numkeys&#x3D;1，keys数组有一个元素userAge（代表redis的key）</span><br><span class="line">&#x2F;&#x2F;      arg数组元素中有两个元素：10（代表userAge对应的value）和60（代表redis的存活时间）</span><br><span class="line">127.0.0.1:6379&gt; EVAL &quot;redis.call(&#39;SET&#39;, KEYS[1], ARGV[1]);redis.call(&#39;EXPIRE&#39;, KEYS[1], ARGV[2]); return 1;&quot; 1 userAge 10 60</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get userAge</span><br><span class="line">&quot;10&quot;</span><br><span class="line">127.0.0.1:6379&gt; ttl userAge</span><br><span class="line">(integer) 44</span><br></pre></td></tr></table></figure>

<p>通过上面的例 4，我们可以发现，脚本中使用 redis.call()去调用 redis 的命令。<br>在 Lua 脚本中，可以使用两个不同函数来执行 Redis 命令，它们分别是： redis.call() 和 redis.pcall()<br>这两个函数的唯一区别在于它们使用不同的方式处理执行命令所产生的错误，差别如下：<br>当 redis.call() 在执行命令的过程中发生错误时，脚本会停止执行，并返回一个脚本错误，错误的输出信息会说明错误造成的原因：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush foo a</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; eval &quot;return redis.call(&#39;get&#39;, &#39;foo&#39;)&quot; 0</span><br><span class="line">(error) ERR Error running script (call to f_282297a0228f48cd3fc6a55de6316f31422f5d17): ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure>

<p>和 redis.call() 不同， redis.pcall() 出错时并不引发(raise)错误，而是返回一个带 err 域的 Lua 表(table)，用于表示错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EVAL &quot;return redis.pcall(&#39;get&#39;, &#39;foo&#39;)&quot; 0</span><br><span class="line">(error) ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure>

<p>2.2 SCRIPT LOAD 命令 和 EVALSHA 命令</p>
<p>SCRIPT LOAD 命令格式：SCRIPT LOAD script<br>EVALSHA 命令格式：EVALSHA sha1 numkeys key [key …] arg [arg …]</p>
<p>这两个命令放在一起讲的原因是：EVALSHA 命令中的 sha1 参数，就是 SCRIPT LOAD 命令执行的结果。</p>
<p>SCRIPT LOAD 将脚本 script 添加到 Redis 服务器的脚本缓存中，并不立即执行这个脚本，而是会立即对输入的脚本进行求值。并返回给定脚本的 SHA1 校验和。如果给定的脚本已经在缓存里面了，那么不执行任何操作。</p>
<p>在脚本被加入到缓存之后，在任何客户端通过 EVALSHA 命令，可以使用脚本的 SHA1 校验和来调用这个脚本。脚本可以在缓存中保留无限长的时间，直到执行 SCRIPT FLUSH 为止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">## SCRIPT LOAD加载脚本，并得到sha1值</span><br><span class="line">127.0.0.1:6379&gt; SCRIPT LOAD &quot;redis.call(&#39;SET&#39;, KEYS[1], ARGV[1]);redis.call(&#39;EXPIRE&#39;, KEYS[1], ARGV[2]); return 1;&quot;</span><br><span class="line">&quot;6aeea4b3e96171ef835a78178fceadf1a5dbe345&quot;</span><br><span class="line"></span><br><span class="line">## EVALSHA使用sha1值，并拼装和EVAL类似的numkeys和key数组、arg数组，调用脚本。</span><br><span class="line">127.0.0.1:6379&gt; EVALSHA 6aeea4b3e96171ef835a78178fceadf1a5dbe345 1 userAge 10 60</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get userAge</span><br><span class="line">&quot;10&quot;</span><br><span class="line">127.0.0.1:6379&gt; ttl userAge</span><br><span class="line">(integer) 43</span><br></pre></td></tr></table></figure>

<p>2.3 SCRIPT EXISTS 命令<br>命令格式：SCRIPT EXISTS sha1 [sha1 …]<br>作用：给定一个或多个脚本的 SHA1 校验和，返回一个包含 0 和 1 的列表，表示校验和所指定的脚本是否已经被保存在缓存当中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SCRIPT EXISTS 6aeea4b3e96171ef835a78178fceadf1a5dbe345</span><br><span class="line">1) (integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SCRIPT EXISTS 6aeea4b3e96171ef835a78178fceadf1a5dbe346</span><br><span class="line">1) (integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SCRIPT EXISTS 6aeea4b3e96171ef835a78178fceadf1a5dbe345 6aeea4b3e96171ef835a78178fceadf1a5dbe366</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 0</span><br></pre></td></tr></table></figure>

<p>2.4 SCRIPT FLUSH 命令</p>
<p>命令格式：SCRIPT FLUSH<br>作用：清除 Redis 服务端所有 Lua 脚本缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SCRIPT EXISTS 6aeea4b3e96171ef835a78178fceadf1a5dbe345</span><br><span class="line">1) (integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SCRIPT FLUSH</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SCRIPT EXISTS 6aeea4b3e96171ef835a78178fceadf1a5dbe345</span><br><span class="line">1) (integer) 0</span><br></pre></td></tr></table></figure>

<p>2.5 SCRIPT KILL 命令<br>命令格式：SCRIPT FLUSH<br>作用：杀死当前正在运行的 Lua 脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。 这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限 loop 的脚本，诸如此类。</p>
<p>假如当前正在运行的脚本已经执行过写操作，那么即使执行 SCRIPT KILL，也无法将它杀死，因为这是违反 Lua 脚本的原子性执行原则的。在这种情况下，唯一可行的办法是使用 SHUTDOWN NOSAVE 命令，通过停止整个 Redis 进程来停止脚本的运行，并防止不完整(half-written)的信息被写入数据库中。</p>
<p>三、Redis 执行 Lua 脚本文件</p>
<p>在第二章中介绍的命令，是在 redis 客户端中使用命令进行操作。该章节介绍的是直接执行 Lua 的脚本文件。<br>3.1 编写 Lua 脚本文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">local key &#x3D; KEYS[1]</span><br><span class="line">local val &#x3D; redis.call(&quot;GET&quot;, key);</span><br><span class="line"></span><br><span class="line">if val &#x3D;&#x3D; ARGV[1]</span><br><span class="line">then</span><br><span class="line">        redis.call(&#39;SET&#39;, KEYS[1], ARGV[2])</span><br><span class="line">        return 1</span><br><span class="line">else</span><br><span class="line">        return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>3.2 执行 lua 脚本文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行命令： redis-cli -a 密码 --eval Lua脚本路径 key [key …] ,  arg [arg …]</span><br><span class="line">如：redis-cli -a 123456 --eval .&#x2F;Redis_CompareAndSet.lua userName , zhangsan lisi</span><br></pre></td></tr></table></figure>

<p>此处敲黑板，注意啦！！！<br>“–eval”而不是命令模式中的”eval”，一定要有前端的两个-<br>脚本路径后紧跟 key [key …]，相比命令行模式，少了 numkeys 这个 key 数量值<br>key [key …] 和 arg [arg …] 之间的“ , ”，英文逗号前后必须有空格，否则死活都报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">## Redis客户端执行</span><br><span class="line">127.0.0.1:6379&gt; set userName zhangsan</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get userName</span><br><span class="line">&quot;zhangsan&quot;</span><br><span class="line"></span><br><span class="line">## linux服务器执行</span><br><span class="line">## 第一次执行：compareAndSet成功，返回1</span><br><span class="line">## 第二次执行：compareAndSet失败，返回0</span><br><span class="line">[root@vm01 learn_lua]# redis-cli -a 123456 --eval Redis_CompareAndSet.lua userName , zhangsan lisi</span><br><span class="line">(integer) 1</span><br><span class="line">[root@vm01 learn_lua]# redis-cli -a 123456 --eval Redis_CompareAndSet.lua userName , zhangsan lisi</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p>四、实例：使用 Lua 控制 IP 访问频率</p>
<p>需求：实现一个访问频率控制，某个 IP 在短时间内频繁访问页面，需要记录并检测出来，就可以通过 Lua 脚本高效的实现。<br>小声说明：本实例针对固定窗口的访问频率，而动态的非滑动窗口。即：如果规定一分钟内访问 10 次，记为超限。在本实例中前一分钟的最后一秒访问 9 次，下一分钟的第 1 秒又访问 9 次，不计为超限。<br>脚本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">local visitNum &#x3D; redis.call(&#39;incr&#39;, KEYS[1])</span><br><span class="line"></span><br><span class="line">if visitNum &#x3D;&#x3D; 1 then</span><br><span class="line">        redis.call(&#39;expire&#39;, KEYS[1], ARGV[1])</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if visitNum &gt; tonumber(ARGV[2]) then</span><br><span class="line">        return 0</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return 1;</span><br></pre></td></tr></table></figure>

<p>演示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">## LimitIP:127.0.0.1为key， 10 3表示：同一IP在10秒内最多访问三次</span><br><span class="line">## 前三次返回1，代表未被限制；第四、五次返回0，代表127.0.0.1这个ip已被拦截</span><br><span class="line">[root@vm01 learn_lua]# redis-cli -a 123456 --eval Redis_LimitIpVisit.lua LimitIP:127.0.0.1 , 10 3</span><br><span class="line"> (integer) 1</span><br><span class="line">[root@vm01 learn_lua]# redis-cli -a 123456 --eval Redis_LimitIpVisit.lua LimitIP:127.0.0.1 , 10 3</span><br><span class="line"> (integer) 1</span><br><span class="line">[root@vm01 learn_lua]# redis-cli -a 123456 --eval Redis_LimitIpVisit.lua LimitIP:127.0.0.1 , 10 3</span><br><span class="line"> (integer) 1</span><br><span class="line">[root@vm01 learn_lua]# redis-cli -a 123456 --eval Redis_LimitIpVisit.lua LimitIP:127.0.0.1 , 10 3</span><br><span class="line"> (integer) 0</span><br><span class="line">[root@vm01 learn_lua]# redis-cli -a 123456 --eval Redis_LimitIpVisit.lua LimitIP:127.0.0.1 , 10 3</span><br><span class="line"> (integer) 0</span><br></pre></td></tr></table></figure>

<p>五、总结<br>通过上面一系列的介绍，对 Lua 脚本、Lua 基础语法有了一定了解，同时也学会在 Redis 中如何去使用 Lua 脚本去实现 Redis 命令无法实现的场景<br>回头再思考文章开头提到的 Redis 使用 Lua 脚本的几个优点：减少网络开销、原子性、复用</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/17/JVM%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/17/JVM%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">JVM相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-17 13:00:00" itemprop="dateCreated datePublished" datetime="2021-01-17T13:00:00+08:00">2021-01-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-01-20 14:19:33" itemprop="dateModified" datetime="2021-01-20T14:19:33+08:00">2021-01-20</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="MAT-分析"><a href="#MAT-分析" class="headerlink" title="MAT 分析"></a>MAT 分析</h2><p>链接： <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56110317">https://zhuanlan.zhihu.com/p/56110317</a><br>链接： <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/57347496">https://zhuanlan.zhihu.com/p/57347496</a><br>链接： <a target="_blank" rel="noopener" href="https://www.eclipse.org/mat">https://www.eclipse.org/mat</a></p>
<h2 id="JAVA-性能调优"><a href="#JAVA-性能调优" class="headerlink" title="JAVA 性能调优"></a>JAVA 性能调优</h2><h2 id="jvm-之-AccessController-doPrivileged"><a href="#jvm-之-AccessController-doPrivileged" class="headerlink" title="jvm 之 AccessController.doPrivileged"></a>jvm 之 AccessController.doPrivileged</h2><p>AccessController.doPrivileged 意思是这个是特别的,不用做权限检查.</p>
<p>在什么地方会用到呢:加入 1.jar 中有类可以读取一个文件,现在我们要使用 1.jar 去做这个事情.但是我们的类本生是没有权限去读取那个文件的,一般情况下就是眼睁睁的看着了.</p>
<p>但是 jiava 提供了 doPrivileged.在 1.jar 中如果读取文件的方法是通过 doPrivileged 来实现的.就不会有后面的检查了,现在我们就可以使用 1.jar 去读取那个文件了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package huangyunbin.client;</span><br><span class="line"></span><br><span class="line">import java.io.FilePermission;</span><br><span class="line">import java.security.AccessController;</span><br><span class="line">import java.security.Permission;</span><br><span class="line">import java.security.PrivilegedAction;</span><br><span class="line"></span><br><span class="line">public class Client</span><br><span class="line">&#123;</span><br><span class="line">    public   void  doCheck() &#123;</span><br><span class="line">                AccessController.doPrivileged( new  PrivilegedAction()  &#123;</span><br><span class="line">            public  Object run()  &#123;</span><br><span class="line">                check();</span><br><span class="line">                return   null ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private   void  check()  &#123;</span><br><span class="line">        Permission perm  &#x3D;   new FilePermission( &quot;&#x2F;1.txt&quot; ,  &quot;read&quot; );</span><br><span class="line">        AccessController.checkPermission(perm);</span><br><span class="line">        System.out.println( &quot; TestService has permission &quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把这个类打包成 client.jar 放到/home/h/client/下，我们建立个 my.policy 文件,文件内容是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant codeBase  &quot;file:&#x2F;home&#x2F;h&#x2F;client&#x2F;*&quot;   &#123;</span><br><span class="line">     permission java.io.FilePermission  &quot;&#x2F;1.txt&quot;,&quot;read&quot;;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>配置文件的意思是 /home/h/client/下面的 jar 包或 class 类 可以读取/1.txt.</p>
<p>现在我们再创建一个项目:创建一个类来调用前面的 Client</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class server</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Client c &#x3D;new    Client();</span><br><span class="line">        c.doCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这个 server 类.注意这里要用上之前的 my.policy 文件<br>在 vm 参数中写上这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Djava.security.manager</span><br><span class="line">-Djava.security.policy&#x3D;&#x2F;home&#x2F;h&#x2F;my.policy</span><br></pre></td></tr></table></figure>

<p>运行,结果是<br>TestService has permission</p>
<p>在配置文件 my.policy 中我们没有允许 server 去读取/1.txt,但是现在却可以正常访问.这个就是 AccessController.doPrivileged 的作用.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/17/Docker%E5%AF%B9%E6%AF%94%E8%99%9A%E6%8B%9F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/17/Docker%E5%AF%B9%E6%AF%94%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="post-title-link" itemprop="url">Docker对比虚拟机</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-01-17 11:00:00 / Modified: 12:19:35" itemprop="dateCreated datePublished" datetime="2021-01-17T11:00:00+08:00">2021-01-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>首先，大家需要明确一点，Docker 容器不是虚拟机。2014 年，当我第一次接触 Docker 的时候，我把它比做一种轻量级的虚拟机。这样做无可厚非，因为 Docker 最初的成功秘诀，正是它比虚拟机更节省内存，启动更快。Docker 不停地给大家宣传，”虚拟机需要数分钟启动，而 Docker 容器只需要 50 毫秒”。然而，Docker 容器并非虚拟机，我们不妨来比较一下它们。</p>
<h2 id="理解虚拟机"><a href="#理解虚拟机" class="headerlink" title="理解虚拟机"></a>理解虚拟机</h2><p>使用虚拟机运行多个相互隔离的应用时，如下图:<br><img src="/images/docker/docker1.png"></p>
<p>从下到上理解上图:</p>
<ul>
<li>基础设施(Infrastructure)。它可以是你的个人电脑，数据中心的服务器，或者是云主机。</li>
<li>虚拟机管理系统(Hypervisor)。利用 Hypervisor，可以在主操作系统之上运行多个不同的从操作系统。类型 1 的 Hypervisor 有支持 MacOS 的 HyperKit，支持 Windows 的 Hyper-V、Xen 以及 KVM。类型 2 的 Hypervisor 有 VirtualBox 和 VMWare workstation。</li>
<li>客户机操作系统(Guest Operating System)。假设你需要运行 3 个相互隔离的应用，则需要使用 Hypervisor 启动 3 个客户机操作系统，也就是 3 个虚拟机。这些虚拟机都非常大，也许有 700MB，这就意味着它们将占用 2.1GB 的磁盘空间。更糟糕的是，它们还会消耗很多 CPU 和内存。</li>
<li>各种依赖。每一个客户机操作系统都需要安装许多依赖。如果你的应用需要连接 PostgreSQL 的话，则需要安装 libpq-dev；如果你使用 Ruby 的话，应该需要安装 gems；如果使用其他编程语言，比如 Python 或者 Node.js，都会需要安装对应的依赖库。</li>
<li>应用。安装依赖之后，就可以在各个客户机操作系统分别运行应用了，这样各个应用就是相互隔离的。理解 Docker 容器使用 Docker 容器运行多个相互隔离的应用时，如下图:</li>
</ul>
<h2 id="理解-Docker-容器"><a href="#理解-Docker-容器" class="headerlink" title="理解 Docker 容器"></a>理解 Docker 容器</h2><p>使用 Docker 容器运行多个相互隔离的应用时，如下图:<br><img src="/images/docker/docker2.png"><br>不难发现，相比于虚拟机，Docker 要简洁很多。因为我们不需要运行一个臃肿的客户机操作系统了。<br>从下到上理解上图:</p>
<ul>
<li>基础设施(Infrastructure)。</li>
<li>主操作系统(Host Operating System)。所有主流的 Linux 发行版都可以运行 Docker。对于 MacOS 和 Windows，也有一些办法”运行”Docker。</li>
<li>Docker 守护进程(Docker Daemon)。Docker 守护进程取代了 Hypervisor，它是运行在操作系统之上的后台进程，负责管理 Docker 容器。</li>
<li>各种依赖。对于 Docker，应用的所有依赖都打包在 Docker 镜像中，Docker 容器是基于 Docker 镜像创建的。</li>
<li>应用。应用的源代码与它的依赖都打包在 Docker 镜像中，不同的应用需要不同的 Docker 镜像。不同的应用运行在不同的 Docker 容器中，它们是相互隔离的。</li>
</ul>
<p>对比虚拟机与 Docker</p>
<p>Docker 守护进程可以直接与主操作系统进行通信，为各个 Docker 容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。虚拟机启动需要数分钟，而 Docker 容器可以在数毫秒内启动。由于没有臃肿的从操作系统，Docker 可以节省大量的磁盘空间以及其他系统资源。</p>
<p>说了这么多 Docker 的优势，大家也没有必要完全否定虚拟机技术，因为两者有不同的使用场景。虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 Docker 通常用于隔离不同的应用，例如前端，后端以及数据库。</p>
<h2 id="服务器虚拟化-vs-Docker"><a href="#服务器虚拟化-vs-Docker" class="headerlink" title="服务器虚拟化 vs Docker"></a>服务器虚拟化 vs Docker</h2><ul>
<li>服务器好比运输码头：拥有场地和各种设备（服务器硬件资源）</li>
<li>服务器虚拟化好比作码头上的仓库：拥有独立的空间堆放各种货物或集装箱(仓库之间完全独立，独立的应用系统和操作系统）</li>
<li>Docker 比作集装箱：各种货物的打包(将各种应用程序和他们所依赖的运行环境打包成标准的容器,容器之间隔离)</li>
</ul>
<p>Docker 有着小巧、迁移部署快速、运行高效等特点，但隔离性比服务器虚拟化差：不同的集装箱属于不同的运单（Docker 上运行不同的应用实例），相互独立（隔离）。但由同一个库管人员管理（主机操作系统内核），因此通过库管人员可以看到所有集装箱的相关信息（因为共享操作系统内核，因此相关信息会共享）。</p>
<p>服务器虚拟化就好比在码头上（物理主机及虚拟化层），建立了多个独立的“小码头”—仓库（虚拟机）。其拥有完全独立（隔离）的空间，属于不同的客户（虚拟机所有者）。每个仓库有各自的库管人员（当前虚拟机的操作系统内核），无法管理其它仓库。不存在信息共享的情况.</p>
<p>因此，我们需要根据不同的应用场景和需求采用不同的方式使用 Docker 技术或使用服务器虚拟化技术。例如一个典型的 Docker 应用场景是当主机上的 Docker 实例属于单一用户的情况下，在保证安全的同时可以充分发挥 Docker 的技术优势。对于隔离要求较高的环境如混合用户环境，就可以使用服务器虚拟化技术。正则科技提供了丰富的 Docker 应用实例，满足您的各种应用需求，并且支持在已经安装了自在（Isvara）服务器虚拟化软件的主机上同时使用服务器虚拟化技术和 Docker 技术提供不同技术场景<br><img src="/images/docker/docker3.png"></p>
<h2 id="Docker-基本命令"><a href="#Docker-基本命令" class="headerlink" title="Docker 基本命令"></a>Docker 基本命令</h2><p>参考：<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a></p>
<h2 id="K8S-的-kubectl-命令"><a href="#K8S-的-kubectl-命令" class="headerlink" title="K8S 的 kubectl 命令"></a>K8S 的 kubectl 命令</h2><p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/85810571">https://zhuanlan.zhihu.com/p/85810571</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
