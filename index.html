<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'default'
  };
</script>
<title>Hexo</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/26/Tomcat%E8%BF%B7%E4%BD%A0%E7%89%88%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/26/Tomcat%E8%BF%B7%E4%BD%A0%E7%89%88%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Tomcat迷你版实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-26 23:00:00 / Modified: 23:08:01" itemprop="dateCreated datePublished" datetime="2020-12-26T23:00:00+08:00">2020-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Tomcat 是非常流行的 Web Server，它还是一个满足 Servlet 规范的容器。那么想一想，Tomcat 和我们的 Web 应用是什么关系？</p>
<p>从感性上来说，我们一般需要把 Web 应用打成 WAR 包部署到 Tomcat 中，在我们的 Web 应用中，我们要指明 URL 被哪个类的哪个方法所处理「不论是原始的 Servlet 开发，还是现在流行的 Spring MVC 都必须指明」。</p>
<p>由于我们的 Web 应用是运行在 Tomcat 中，请求必定是先到达 Tomcat 的。Tomcat 对于请求实际上会进行如下的处理。</p>
<p>第一，提供 Socket 服务</p>
<p>Tomcat 的启动，必然是 Socket 服务，只不过它支持 HTTP 协议而已！</p>
<p>这里其实可以扩展思考下，Tomcat 既然是基于 Socket，那么是基于 BIO or NIO or AIO 呢？</p>
<p>第二，进行请求的分发</p>
<p>要知道一个 Tomcat 可以为多个 Web 应用提供服务，很显然，Tomcat 可以把 URL 下发到不同的 Web 应用。</p>
<p>第三，需要把请求和响应封装成 request/response</p>
<p>我们在 Web 应用这一层，可从来没有封装过 request/response 的，我们都是直接使用的，这就是因为 Tomcat 已经为你做好了！</p>
<p>话不多说，先来看一眼工程截图。<br><img src="/images/tomcat1.png"></p>
<h1 id="一、封装请求对象"><a href="#一、封装请求对象" class="headerlink" title="一、封装请求对象"></a>一、封装请求对象</h1><p><img src="/images/tomcat2.png"><br>这里可以清楚的看到，通过输入流，对 HTTP 协议进行解析，拿到了 HTTP 请求头的方法以及 URL。</p>
<h1 id="二、封装响应对象"><a href="#二、封装响应对象" class="headerlink" title="二、封装响应对象"></a>二、封装响应对象</h1><p><img src="/images/tomcat3.png"><br>基于 HTTP 协议的格式进行输出写入。</p>
<h1 id="三、Servlet-请求处理基类"><a href="#三、Servlet-请求处理基类" class="headerlink" title="三、Servlet 请求处理基类"></a>三、Servlet 请求处理基类</h1><p><img src="/images/tomcat4.png"><br>前文说 Tomcat 是满足 Servlet 规范的容器，那么自然 Tomcat 需要提供 API。这里看到了 Servlet 常见的 doGet/doPost/service 方法。</p>
<p>#　四、Servlet 实现类<br><img src="/images/tomcat5.png"><br><img src="/images/tomcat6.png"><br>提供这 2 个具体的 Servlet 实现，只是为了后续的测试！</p>
<h1 id="五、Servlet-配置"><a href="#五、Servlet-配置" class="headerlink" title="五、Servlet 配置"></a>五、Servlet 配置</h1><p><img src="/images/tomcat7.png"><br><img src="/images/tomcat8.png"><br>你应该有些感觉了吧？在 servlet 开发中，会在 web.xml 中通过<servlet>和<servlet-mapping>来进行指定哪个 URL 交给哪个 servlet 进行处理。</servlet-mapping></servlet></p>
<h1 id="六、启动类"><a href="#六、启动类" class="headerlink" title="六、启动类"></a>六、启动类</h1><p><img src="/images/tomcat9.png"><br><img src="/images/tomcat10.png"><br><img src="/images/tomcat11.png"><br>这里，你能够看到 Tomcat 的处理流程，即把 URL 对应处理的 Servlet 关系形成，解析 HTTP 协议，封装请求/响应对象，利用反射实例化具体的 Servlet 进行处理即可。</p>
<h1 id="七、测试"><a href="#七、测试" class="headerlink" title="七、测试"></a>七、测试</h1><p><img src="/images/tomcat12.png"><br>实现一个简易版的 Tomcat 就这么 7 大步搞定，大家都来动手实现一下吧，代码最好不要复制，自己动手一个个敲，这样实现之后，对 Tomcat 就没那么陌生了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/26/WEB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/26/WEB/" class="post-title-link" itemprop="url">Web技术历史变化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-26 21:00:00 / Modified: 15:42:07" itemprop="dateCreated datePublished" datetime="2020-12-26T21:00:00+08:00">2020-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、简单明快的早期时代"><a href="#一、简单明快的早期时代" class="headerlink" title="一、简单明快的早期时代"></a>一、简单明快的早期时代</h1><p><img src="/images/web/1.png"><br>可称之为 Web 1.0 时代，非常适合创业型小项目，不分前后端，经常 3-5 人搞定所有开发。页面由 JSP、PHP 等工程师在服务端生成，浏览器负责展现。基本上是服务端给什么浏览器就展现什么，展现的控制在 Web Server 层。</p>
<p>这种模式的好处是：简单明快，本地起一个 Tomcat 或 Apache 就能开发，调试什么的都还好，只要业务不太复杂。</p>
<p>然而业务总会变复杂，这是好事情，否则很可能就意味着创业失败了。业务的复杂会让 Service 越来越多，参与开发的人员也很可能从几个人快速扩招到几十人。在这种情况下，会遇到一些典型问题：</p>
<p>1、Service 越来越多，调用关系变复杂，前端搭建本地环境不再是一件简单的事。考虑团队协作，往往会考虑搭建集中式的开发服务器来解决。这种解决方案对编译型的后端开发来说也许还好，但对前端开发来说并不友好。天哪，我只是想调整下按钮样式，却要本地开发、代码上传、验证生效等好几个步骤。也许习惯了也还好，但开发服务器总是不那么稳定，出问题时往往需要依赖后端开发搞定。看似仅仅是前端开发难以本地化，但这对研发效率的影响其实蛮大。</p>
<p>2、JSP 等代码的可维护性越来越差。JSP 非常强大，可以内嵌 Java 代码。这种强大使得前后端的职责不清晰，JSP 变成了一个灰色地带。经常为了赶项目，为了各种紧急需求，会在 JSP 里揉杂大量业务代码。积攒到一定阶段时，往往会带来大量维护成本。</p>
<p>这个时期，为了提高可维护性，可以通过下面的方式实现前端的组件化：</p>
<p><img src="/images/web/1.1.png"><br>理论上，如果大家都能按照最佳实践去书写代码，那么无论是 JSP 还是 PHP，可维护性都不会差。但可维护性更多是工程含义，有时候需要通过限制带来自由，需要某种约定，使得即便是新手也不会写出太糟糕的代码。</p>
<p>如何让前后端分工更合理高效，如何提高代码的可维护性，在 Web 开发中很重要。下面我们继续来看，技术架构的演变如何解决这两个问题。</p>
<h1 id="二、后端为主的-MVC-时代"><a href="#二、后端为主的-MVC-时代" class="headerlink" title="二、后端为主的 MVC 时代"></a>二、后端为主的 MVC 时代</h1><p>为了降低复杂度，以后端为出发点，有了 Web Server 层的架构升级，比如 Structs、Spring MVC 等，这是后端的 MVC 时代。</p>
<p><img src="/images/web/2.png"><br>代码可维护性得到明显好转，MVC 是个非常好的协作模式，从架构层面让开发者懂得什么代码应该写在什么地方。为了让 View 层更简单干脆，还可以选择 Velocity、Freemaker 等模板，使得模板里写不了 Java 代码。看起来是功能变弱了，但正是这种限制使得前后端分工更清晰。然而依旧并不是那么清晰，这个阶段的典型问题是：</p>
<p>1、前端开发重度依赖开发环境。这种架构下，前后端协作有两种模式：一种是前端写 demo，写好后，让后端去套模板。淘宝早期包括现在依旧有大量业务线是这种模式。好处很明显，demo 可以本地开发，很高效。不足是还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大。另一种协作模式是前端负责浏览器端的所有开发和服务器端的 View 层模板开发，支付宝是这种模式。好处是 UI 相关的代码都是前端去写就好，后端不用太关注，不足就是前端开发重度绑定后端环境，环境成为影响前端开发效率的重要因素。</p>
<p>2、前后端职责依旧纠缠不清。Velocity 模板还是蛮强大的，变量、逻辑、宏等特性，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写出不少业务代码。还有一个很大的灰色地带是 Controller，页面路由等功能本应该是前端最关注的，但却是由后端来实现。Controller 本身与 Model 往往也会纠缠不清，看了让人咬牙的代码经常会出现在 Controller 层。这些问题不能全归结于程序员的素养，否则 JSP 就够了。</p>
<p>经常会有人吐槽 Java，但 Java 在工程化开发方面真的做了大量思考和架构尝试。Java 蛮符合马云的一句话：让平凡人做非凡事。</p>
<h1 id="三、Ajax-带来的-SPA-时代"><a href="#三、Ajax-带来的-SPA-时代" class="headerlink" title="三、Ajax 带来的 SPA 时代"></a>三、Ajax 带来的 SPA 时代</h1><p>历史滚滚往前，2004 年 Gmail 像风一样的女子来到人间，很快 2005 年 Ajax 正式提出，加上 CDN 开始大量用于静态资源存储，于是出现了 JavaScript 王者归来的 SPA （Single Page Application 单页面应用）时代。</p>
<p><img src="/images/web/3.png"><br>这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口。看起来是如此美妙，但回过头来看看的话，这与 JSP 时代区别不大。复杂度从服务端的 JSP 里移到了浏览器的 JavaScript，浏览器端变得很复杂。类似 Spring MVC，这个时代开始出现浏览器端的分层架构：</p>
<p><img src="/images/web/3.1.png"><br>对于 SPA 应用，有几个很重要的挑战：</p>
<p>1、前后端接口的约定。如果后端的接口一塌糊涂，如果后端的业务模型不够稳定，那么前端开发会很痛苦。这一块在业界有 API Blueprint 等方案来约定和沉淀接口，在阿里，不少团队也有类似尝试，通过接口规则、接口平台等方式来做。有了和后端一起沉淀的接口规则，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发。相信这一块会越做越好。</p>
<p>2、前端开发的复杂度控制。SPA 应用大多以功能交互型为主，JavaScript 代码过十万行很正常。大量 JS 代码的组织，与 View 层的绑定等，都不是容易的事情。典型的解决方案是业界的 Backbone，但 Backbone 做的事还很有限，依旧存在大量空白区域需要挑战。</p>
<p>SPA 让前端看到了一丝绿色，但依旧是在荒漠中行走。</p>
<h1 id="四、前端为主的-MV-时代"><a href="#四、前端为主的-MV-时代" class="headerlink" title="四、前端为主的 MV* 时代"></a>四、前端为主的 MV* 时代</h1><p>为了降低前端开发复杂度，除了 Backbone，还有大量框架涌现，比如 EmberJS、KnockoutJS、AngularJS 等等。这些框架总的原则是先按类型分层，比如 Templates、Controllers、Models，然后再在层内做切分，如下图：</p>
<p><img src="/images/web/4.png"><br>好处很明显：</p>
<p>1、前后端职责很清晰。前端工作在浏览器端，后端工作在服务端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 RESTful 等接口。</p>
<p>2、前端开发的复杂度可控。前端代码很重，但合理的分层，让前端代码能各司其职。这一块蛮有意思的，简单如模板特性的选择，就有很多很多讲究。并非越强大越好，限制什么，留下哪些自由，代码应该如何组织，所有这一切设计，得花一本的厚度去说明。</p>
<p>3、部署相对独立，产品体验可以快速改进。</p>
<p>但依旧有不足之处：</p>
<p>代码不能复用。比如后端依旧需要对数据做各种校验，校验逻辑无法复用浏览器端的代码。如果可以复用，那么后端的数据校验可以相对简单化。<br>全异步，对 SEO 不利。往往还需要服务端做同步渲染的降级方案。<br>性能并非最佳，特别是移动互联网环境下。<br>SPA 不能满足所有需求，依旧存在大量多页面应用。URL Design 需要后端配合，前端无法完全掌控。<br>五、Node 带来的全栈时代<br>前端为主的 MV* 模式解决了很多很多问题，但如上所述，依旧存在不少不足之处。随着 Node.js 的兴起，JavaScript 开始有能力运行在服务端。这意味着可以有一种新的研发模式：</p>
<p><img src="/images/web/5.png"><br>在这种研发模式下，前后端的职责很清晰。对前端来说，两个 UI 层各司其职：</p>
<p>1、Front-end UI layer 处理浏览器层的展现逻辑。通过 CSS 渲染样式，通过 JavaScript 添加交互功能，HTML 的生成也可以放在这层，具体看应用场景。</p>
<p>2、Back-end UI layer 处理路由、模板、数据获取、cookie 等。通过路由，前端终于可以自主把控 URL Design，这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以摆脱对展现的强关注，转而可以专心于业务逻辑层的开发。</p>
<p>通过 Node，Web Server 层也是 JavaScript 代码，这意味着部分代码可前后复用，需要 SEO 的场景可以在服务端同步渲染，由于异步请求太多导致的性能问题也可以通过服务端来缓解。前一种模式的不足，通过这种模式几乎都能完美解决掉。</p>
<p>与 JSP 模式相比，全栈模式看起来是一种回归，也的确是一种向原始开发模式的回归，不过是一种螺旋上升式的回归。</p>
<h1 id="基于-Node-的全栈模式，依旧面临很多挑战："><a href="#基于-Node-的全栈模式，依旧面临很多挑战：" class="headerlink" title="基于 Node 的全栈模式，依旧面临很多挑战："></a>基于 Node 的全栈模式，依旧面临很多挑战：</h1><p>需要前端对服务端编程有更进一步的认识。比如 network/tcp、PE 等知识的掌握。<br>Node 层与 Java 层的高效通信。Node 模式下，都在服务器端，RESTful HTTP 通信未必高效，通过 SOAP 等方式通信更高效。一切需要在验证中前行。<br>对部署、运维层面的熟练了解，需要更多知识点和实操经验。<br>大量历史遗留问题如何过渡。这可能是最大最大的阻力。<br>六、小结<br>回顾历史总是让人感慨，展望未来则让人兴奋。上面讲到的研发模式，除了最后一种还在探索期，其他各种在各大公司都已有大量实践。几点小结：</p>
<p>模式没有好坏高下之分，只有合不合适。<br>Ajax 给前端开发带来了一次质的飞跃，Node 很可能是第二次。<br>SoC（关注度分离） 是一条伟大的原则。上面种种模式，都是让前后端的职责更清晰，分工更合理高效。<br>还有个原则，让合适的人做合适的事。比如 Web Server 层的 UI Layer 开发，前端是更合适的人选。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/26/Play%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/26/Play%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">Play框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-26 21:00:00 / Modified: 22:09:50" itemprop="dateCreated datePublished" datetime="2020-12-26T21:00:00+08:00">2020-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Play 框架架构<br>当请求从浏览器发到服务端时，会有 Routes 来处理，如我们请求 /use/1 的 URL 时。这个请求将在 Routes 找到对应的函数来处理，在 Django 中处理请求的函数叫做 URL Dispatcher。</p>
<p><img src="/images/web/play01.png"><br>这里的路由规则分为了两个部分:请求动态数据或静态资源。<br>浏览器一般先请求获得 html 页面，然后 html 内容如果有 ajax 则会再发送请求过来，请求动态数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Routes</span><br><span class="line"># This file defines all application routes (Higher priority routes first)</span><br><span class="line"># ~~~~</span><br><span class="line"></span><br><span class="line"># Home page</span><br><span class="line">GET         &#x2F;                    controllers.ApplicationController.index</span><br><span class="line">POST        &#x2F;user                controllers.ApplicationController.addUser</span><br><span class="line">GET         &#x2F;delete&#x2F;:id          controllers.ApplicationController.deleteUser(id : Long)</span><br><span class="line">GET         &#x2F;user&#x2F;:id            controllers.ApplicationController.getUser(id : Long)</span><br><span class="line">GET         &#x2F;api&#x2F;user&#x2F;:id        controllers.ApiController.getUser(id : Long)</span><br><span class="line">POST        &#x2F;api&#x2F;user            controllers.ApiController.createUser</span><br><span class="line"></span><br><span class="line"># Map static resources from the &#x2F;public folder to the &#x2F;assets URL path</span><br><span class="line">GET         &#x2F;assets&#x2F;*file        controllers.Assets.versioned(path&#x3D;&quot;&#x2F;public&quot;, file: Asset)</span><br></pre></td></tr></table></figure>

<p>随后在我们的 ApiController 中会有一个对应的 getUser 的方法来处理，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ApiController extends Controller &#123;</span><br><span class="line">  def getUser(id: Long) &#x3D; Action.async &#123; implicit request &#x3D;&gt;</span><br><span class="line">    UserService.getUser(id).map &#123;</span><br><span class="line">      case None &#x3D;&gt; NotFound(Json.obj(&quot;error&quot; -&gt; &quot;Not Found&quot;))</span><br><span class="line">      case Some(user) &#x3D;&gt; Ok(Json.toJson(user))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后还是相应的 UserService 去取相应的用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import models.&#123;User, Users&#125;</span><br><span class="line">import scala.concurrent.Future</span><br><span class="line"></span><br><span class="line">object UserService &#123;</span><br><span class="line"></span><br><span class="line">  def addUser(user: User): Future[String] &#x3D; &#123;</span><br><span class="line">    Users.add(user)</span><br><span class="line">  &#125;</span><br><span class="line">  def getUser(id: Long): Future[Option[User]] &#x3D; &#123;</span><br><span class="line">    Users.get(id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后便会执行到 model 层:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">object Users &#123;</span><br><span class="line"></span><br><span class="line">  val dbConfig &#x3D; DatabaseConfigProvider.get[JdbcProfile](Play.current)</span><br><span class="line"></span><br><span class="line">  val users &#x3D; TableQuery[UserTableDef]</span><br><span class="line"></span><br><span class="line">  def add(user: User): Future[String] &#x3D; &#123;</span><br><span class="line">    dbConfig.db.run(users +&#x3D; user).map(res &#x3D;&gt; user.toString()).recover &#123;</span><br><span class="line">      case ex: Exception &#x3D;&gt; ex.getCause.getMessage</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  def get(id: Long): Future[Option[User]] &#x3D; &#123;</span><br><span class="line">    dbConfig.db.run(users.filter(_.id &#x3D;&#x3D;&#x3D; id).result.headOption)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就取到了这个用户。如果只是从这个过程上来说，我觉得和一般的 MVC 框架并没有太大的区别。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/26/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/26/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">函数式编程与面向对象编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-26 21:00:00 / Modified: 22:51:32" itemprop="dateCreated datePublished" datetime="2020-12-26T21:00:00+08:00">2020-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="编程的本质"><a href="#编程的本质" class="headerlink" title="编程的本质"></a>编程的本质</h1><p>当写过许许多多程序后，接触了那么多编程模式、设计模式、框架、语言、算法、数据结构以后，就会发现编程的本质万变不离其宗就是，操纵一坨数据。当然操纵的方式有许多，存储的方式也五花八门，但是本质不变，就是访问数据（读取以及改变）。</p>
<p>下面谈一谈我对两种编程方式的理解，就是面向对象编程，以及函数式编程。我用 JavaScript 这种神奇的语言来解释，因为 JavaScript 既可以面向对象编程，也可以函数式编程。</p>
<h1 id="数据存放方式"><a href="#数据存放方式" class="headerlink" title="数据存放方式"></a>数据存放方式</h1><p>1、对于 OO（面向对象，下同），数据存放在对象的属性（成员变量）里面，以及静态成员（全局变量）</p>
<p>2、对于函数式，数据存放在闭包（各级作用域）里面，作用域包括全局作用域。</p>
<h1 id="数据访问方式"><a href="#数据访问方式" class="headerlink" title="数据访问方式"></a>数据访问方式</h1><p>数据存放方式决定了访问的方式。</p>
<p>1、对于 OO 来说，访问数据（全局变量除外）需要先获取对象的引用，然后再进行操作（直接访问——公共属性，或者调用成员函数/方法访问——私有属性）</p>
<p>2、对于函数式，访问数据是直接访问（通过函数入参或者作用域链查找）</p>
<p>下面上一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;OO</span><br><span class="line">class Foo &#123;</span><br><span class="line">constructor()&#123;</span><br><span class="line">this.bar &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let foo &#x3D; new Foo()</span><br><span class="line">foo.bar ++</span><br></pre></td></tr></table></figure>

<p>//函数式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let bar &#x3D; 0</span><br><span class="line">function foo()&#123;</span><br><span class="line">bar ++</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>这是随便写了一些没有用代码，只是为了展示两种风格的编程方式。</p>
<p>从中我们可以看出一些东西，OO 是通过持有，以及传递对象的方式去让别的对象来操作数据，而对象也会是其他对象的成员，层层嵌套。当你想要访问某一个数据的时候，就需要顺着对象的引用链条去找，一步步去操作。</p>
<p>函数式传递的则是函数，调用函数即操作数据，传递函数的时候其实隐含着传递了函数创建的时候所附带的作用域，这个在表面上看不出来，在底层是有的。</p>
<p>OO 所谓的对象，本质上就是函数式中的作用域。</p>
<p>为了理解这句话，我们来看高阶函数的本质</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo(x)&#123;</span><br><span class="line">let bar &#x3D; x</span><br><span class="line">return function()&#123;</span><br><span class="line">return bar</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let Bar &#x3D; foo(1)</span><br><span class="line">console.log(Bar())&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>

<p>当调用 foo(1)的时候返回一个函数，这个函数可以访问 foo 函数内部的 bar 变量，这就是高阶函数。如果翻译成 OO 思想大家就知道怎么回事了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">constructor(x)&#123;</span><br><span class="line">this.bar &#x3D; x</span><br><span class="line">&#125;</span><br><span class="line">Bar()&#123;</span><br><span class="line">return this.bar</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let foo &#x3D; new Foo(1)</span><br><span class="line">console.log(foo.Bar())</span><br></pre></td></tr></table></figure>

<p>看上去是不是差不多。其实在 C#中对 lambda 表达式的编译就是这个原理。会内部创建一些类。</p>
<p>当然高阶函数的写法肯定不会这么啰嗦，会写的比较优雅。(这就是本质区别）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let foo &#x3D; bar&#x3D;&gt;()&#x3D;&gt;bar</span><br><span class="line">let Bar &#x3D; foo(1)</span><br><span class="line">console.log(Bar())&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>

<p>所以 OO 编程，是面向作用域编程，而函数式编程，是面向功能编程。</p>
<p>函数式编程有一个巨大的优势，就是作用域链，也就是说函数可以访问的变量范围要远远大于 OO，灵活性就成几何级数上升。换句话也可以说 OO 的约束性更强。</p>
<h1 id="FP-适合数据处理，OOP-适合外包业务领域"><a href="#FP-适合数据处理，OOP-适合外包业务领域" class="headerlink" title="FP 适合数据处理，OOP 适合外包业务领域"></a>FP 适合数据处理，OOP 适合外包业务领域</h1><p>函数式编程（FP）和面向对象编程（OOP）直接相比是一种常见的误解。这种比较应该是 FP 和 OOP 支持者之间互相怼的产物。</p>
<p>事实上，FP 和 OOP 是两种不同的看待事物的方式。FP 强调“everything is lambda”，并且强调在逻辑处理中不变性的重要性。不变到什么地步呢？原教旨主义的 FP 就连普通的循环都不可以写（因为循环都有个变化的 idx 或者条件之类的变量），必须用递归实现。这样做的结果就是把一切“状态”都消除。任何“状态”都是由确定的输入经过确定的一组函数处理得到的最终结果。 FP 适合的领域是处理数据。</p>
<p>OOP 强调“everything is object”，以及 object 之间的消息传递。通过消息传递改变每个 Object 的内部状态。OOP 之父 Alan Kay 表示”OOP is all about messaging”。利用 OOP 建模，都会通过某种消息机制来模拟一些场景的处理。比如交易=下单 Object，支付 Object，积分 Object 等之间进行交互当然，实际的 OOP 的程序运行时为了效率一般会用方法调用，而不是真的传递一个物理消息。OOP 适合的领域是企业 ERP，外包业务等。</p>
<p>如果你看懂了上面两个概念，就会发现他们说的事情压根就不在一个频道里。因此各自的好处也不能证明另一方有缺点。</p>
<p>现在经常看到文章表达 FP 如何如何优于 OOP，大概原因有这么两点：第一点是，OOP 早期不切实际的吹牛皮，吹爆了。很多人谈起 OOP，都会有“用了 OOP，代码耦合就小了，就容易维护了，扩展就方便了，代码就更容易复用了等等“的第一印象。但实际上这并不一定发生。软件设计并非因为 OOP 就直接自动变好了。因此很多程序员在趟坑多年后可能会感觉“我擦，学了这么多年，全是假的“。更进一步的，像 Java 这样的“纯 OOP”语言迫使程序员并不需要 OOP 的情况下也得照着 OOP 的方式去写代码，结果啰嗦又臃肿。所以很多人越来越讨厌 OOP 其实是可以理解的。（比如这篇 Goodbye, Objected Oriented Programming)。现在的 Java 程序大量使用反射、lambda 等技术，已经不是早期那个单纯 OOP 语言了。第二点是现代程序开始往并发发展。而 FP 的不可变，没有副作用等特性恰好让并发编程变得不容易出错。并且配合多种并发模型（如 CSP、Map Reduce、Fork &amp; Join、Promise 等），可以解决很多高并发的问题，显得高、大、上、酷。</p>
<p>但是，我非常赞同《人月神话》的著名论断——没有银弹。不论 OOP 还是 FP，用好了都可以发挥作用，用不好一样吃瘪。</p>
<p>举几个例子，一个业务领域建模，其实模拟的就是现实当中的不同角色的人/机构的工作方式。因为如果是人/机构互相协作，就是通过消息来协作的。比如博士生想发文章，先得自己写，写了老板审阅，完事发给期刊编辑，编辑找同行评议，完事发表，发表的结果会收录到某个文献索引数据库。这个过程就是多个独立的“对象”在相互协作的结果。因此 OOP 在这个层面上对这个流程进行抽象是很合适的。当然你也可以说，这时我用 FP 的各种动作函数的组织来描述这个过程，也是可以的。但是如果比较一下，这个场景用 FP 和 OOP 建模，哪个更容易理解呢？</p>
<p>再比如，对一组数据做加工，先查询，然后聚合，聚合后排序，再 join，再排序，再聚合，再转换（map）得到最终的结果。这个过程，用 FP 的函数就很自然，因为这一看就是 result = func1(func2(func3…funcN(x))))这时用 OOP 呢？给每一个步骤建一个 class？然后把排序、聚合等操作放在 class 里？抽象个基类？或者弄个 XXXUtils 的静态方法集合类？当然都可以做，但是很明显这不是个好的设计。再再比如，一个业务流程，就是一组步骤：第一步如何如何，第二部如何如何……。这时用 FP 和 OOP 都不能很好的表达问题（可能 FP 接近点）。这其实是典型的“指令式编程“。如果业务逻辑如此，那么就照着一步一步做就是最好的，而不是抽取函数和不变状态；或者定义一些根本无意义的 class。</p>
<p>说了这么多，其实希望表达的意思是：到底用哪种编程模式，要看问题本身适合哪个。哪个用起来自然，和问题本身特质搭配，那就用哪个。用对了，事半功倍；用错了，就各种纠结拧巴。你希望你一个东西模拟为 Object，前提是这个东西本身容易抽象成一个 Object；你希望你一个数据可以抽象为一组函数执行的组合，前提是这样理解更自然，更舒服。此外，同一个问题可以拆解为不同的层次，不同的层次可以使用各自适合的方式。比如高层的可以 OOP，具体到某个执行逻辑里可以用 FP 或者指令编程。</p>
<h1 id="对比面向过程，面向对象，函数式编程"><a href="#对比面向过程，面向对象，函数式编程" class="headerlink" title="对比面向过程，面向对象，函数式编程"></a>对比面向过程，面向对象，函数式编程</h1><p>函数式编程、面向对象编程和面向过程编程都是思维方式，具体语言的语法不构成限制。这三者可以当作是一条光谱上不同的颜色，一头是命令式风格，一头是声明式风格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">               ↓&lt;过程式&gt;           ↓&lt;面向对象&gt;       ↓&lt;函数式&gt;</span><br><span class="line">[命令式风格] o----------------------------------------------------&gt; [声明式风格]</span><br></pre></td></tr></table></figure>

<p>箭头从左到右抽象程度逐渐上升。过程式风格有函数的概念，和纯粹的指令相比可以用简短的函数替代一段指令；面向对象风格包装了一层 class 这样的概念，允许打包的一组数据自己持有一些信息，使用者调用方法前不需要知道所有的事情；函数式风格允许把“处理过程”本身当作参数，传入的处理过程的参数就代表具体操作时遇到的实体。<br>函数式编程就是用函数的组合来解决问题，面向对象是建很多对象来互相交互解决问题，面向过程就是下一步下一步下一步。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>输入十个整数，输出大于平均值的数，然后输出排序后的十个数面向过程/<em>C</em>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int input[10];</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">int tmp;</span><br><span class="line">double average;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;input[i]);</span><br><span class="line">  sum +&#x3D; input[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">average &#x3D; sum &#x2F; 10.0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">  if (input[i] &gt; average)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, input[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;_Bubble Sort_&#x2F;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">  for (int j &#x3D; 0; j &lt; 9 - i; j++)</span><br><span class="line">  &#123;</span><br><span class="line">    if (input[j] &gt; input[j + 1])</span><br><span class="line">    &#123;</span><br><span class="line">      tmp &#x3D; input[j];</span><br><span class="line">      input[j] &#x3D; input[j + 1];</span><br><span class="line">      input[j + 1] &#x3D; tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%d\n&quot;, input[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面向对象//C++</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class solve</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    solve() noexcept;</span><br><span class="line">    void sort();</span><br><span class="line">    void show();&#x2F;&#x2F;输出大于均值的数</span><br><span class="line">    void print();&#x2F;&#x2F;打印数组</span><br><span class="line">  private:</span><br><span class="line">    int input[10];</span><br><span class="line">    int sum;</span><br><span class="line">    double average;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;具体实现省略</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  auto test &#x3D; new solve();</span><br><span class="line">  test-&gt;show();</span><br><span class="line">  test-&gt;sort();</span><br><span class="line">  test-&gt;print();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数式编程#Python</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array &#x3D; [int(input()) for i in range(10)]</span><br><span class="line">average &#x3D; sum(array) &#x2F; 10;</span><br><span class="line">print(list(filter(lambda x: x &gt; average, array)))</span><br><span class="line">print(sorted(array))</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/21/ANTLR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/21/ANTLR/" class="post-title-link" itemprop="url">Antlr相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-21 21:00:00" itemprop="dateCreated datePublished" datetime="2020-12-21T21:00:00+08:00">2020-12-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-26 15:24:21" itemprop="dateModified" datetime="2020-12-26T15:24:21+08:00">2020-12-26</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="实例入门"><a href="#实例入门" class="headerlink" title="实例入门"></a>实例入门</h1><p>在安装完 antlr 之后，可以编写简单的 g4 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grammar Hello;</span><br><span class="line">r:&#39;hello&#39; ID ;</span><br><span class="line">ID:[a-z]+ ;</span><br><span class="line">WS:[\t\r\n]+ -&gt; skip;</span><br></pre></td></tr></table></figure>

<p>运行如下命令</p>
<ul>
<li><code>antlr Hello.g4</code></li>
<li><code>javac *.java</code></li>
<li><code>alias grun=‘java org.antlr.v4.runtime.misc.TestRig’</code> TestRig 是一个调试工具，使用 alias 给它起了一个别名。直接执行<code>grun</code>可以得到帮助信息。</li>
<li><code>grun Hello r -tokens</code></li>
<li><code>hello parrt</code></li>
<li><code>EOF</code></li>
</ul>
<p>得到如下结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[@0,0:4&#x3D;&#39;hello&#39;,&lt;&#39;hello&#39;&gt;,1:0]</span><br><span class="line">[@1,6:10&#x3D;&#39;parrt&#39;,&lt;ID&gt;,1:6]</span><br><span class="line">[@2,12:11&#x3D;&#39;&lt;EOF&gt;&#39;,&lt;EOF&gt;,2:0]</span><br></pre></td></tr></table></figure>

<p>解析结果：比如 parrt。@1 表明该词法符号在第 2 个位置，parrt 位于第 6 个到第 10 个位置之间，词法符号类型是 ID，位于输入文本的第 1 行，第 6 个位置处。</p>
<h1 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h1><p>Antlr 依据我们定义的语法规则，产生一个递归下降的语法分析器。下降过程就是从语法分析树的根节点开始，朝着叶节点进行解析的过程。递归下降的语法分析其实际是若干方法的结合，每个方法对应一条规则。递归下降属于自上而下的语法分析器的一种实现。<br>首先调用的规则，即语义符号的起始点，就会成为语法分析树的根节点。比如：调用上面的 r()方法，作为起始点。<br>语法分析数的构造过程：识别匹配的规则，将对应规则的方法映射到语法分析树中。<br>一般规则分为：单一分支，多分支。例如：多个规则 assign，ifstat<br>单一分支，如：<code>stat: assign;</code><br>多分支，如:<code>stat: assign|ifstat;</code></p>
<h2 id="顺序解析"><a href="#顺序解析" class="headerlink" title="顺序解析"></a>顺序解析</h2><p>单一分支，只需要顺序匹配词汇符号。</p>
<h2 id="多分支解析"><a href="#多分支解析" class="headerlink" title="多分支解析"></a>多分支解析</h2><p>多分支，需要检查下一个词法符号或者多个词法符号，来决定选择哪个备选分支。这个过程成为预测或语法分析决策。<br>如果在预测过程中，发现多个分支都匹配的话，则出现了规则的定义出现了歧义，需要解决。</p>
<h2 id="歧义"><a href="#歧义" class="headerlink" title="歧义"></a>歧义</h2><p>例如下面这个语法就存在歧义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stat: expr &#39;;&#39;</span><br><span class="line">    | ID &#39;(&#39; &#39;)&#39; &#39;;&#39;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expr: ID &#39;(&#39; &#39;)&#39;</span><br><span class="line">    | INT</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>一般情况下要确保语法分析器能够选择唯一匹配的备选分支。不过当存在多个备选分支时，ANTLR 会选取备选分支中的第一条。比如本例中就会选择<code>expr &#39;;&#39;</code><br>如下存在词法歧义,begin 是一个关键字，同时也是一个标识符。<br>词法分析器会匹配最长字符串，如果输入文本 beginner 只会匹配上例中的 ID 这条词法规则。ANTLR 词法分析器不会把它匹配为关键字 BEGIN 后跟着标识符 ner</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BEGIN : &#39;begin&#39; ;</span><br><span class="line">ID    : [a-z]+ ;</span><br></pre></td></tr></table></figure>

<h2 id="语法分析树"><a href="#语法分析树" class="headerlink" title="语法分析树"></a>语法分析树</h2><p>语法分析树的建造过程：词法分析器处理字符序列并将生成的词法符号提供给语法分析器，语法分析器随即根据这些细信息来检查语法的正确性并建造出一颗语法分析树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharStream-&gt;(Lexer)-&gt;TokenStream-&gt;(Parser)-&gt;ParseTree(RuleNode子类+TerminalNode)</span><br></pre></td></tr></table></figure>

<p><img src="/images/antlr/2-2.png"><br><img src="/images/antlr/2-3.png"></p>
<p>ANTLR 使用共享数据结构节约内存，具体办法是：语法分析树中的叶子节点仅仅是盛放词法符号流中的词法符号的容器。每个词法符号都记录了自己在字符序列中的开始位置和结束位置，而非保存子字符串的拷贝。<br>ParseTree 有两个子类：RuleNode 的子类（非叶子） 和 TerminalNode（叶子）。 RuleNode 的子类包括：StatContext 和 ExprContext.Context 对象知道自己识别的词组中，开始和结束位置处的词法符号，同时提供访问该词组全部元素的方法比如 statContext 类有 ID（）和 expr()方法。有了这些方法，我们就可以遍历并操作树中节点。实际上遍历树的机制都是由 ANTLR 生成的代码</p>
<h2 id="语法分析树的访问-监听器、访问器"><a href="#语法分析树的访问-监听器、访问器" class="headerlink" title="语法分析树的访问-监听器、访问器"></a>语法分析树的访问-监听器、访问器</h2><p>为了构建一个语言类应用程序，语法分析器需要在遇到特定的输入语句、词组或者词法符号时触发特定的行为。这样的词组-&gt;行为的集合构成了我们的语言类应用程序，或者，至少担任了语法和外围程序间接口的角色。<br>监听器和访问器的区别在于，监听器方法不负责显示调用子节点的访问方法(visit())。访问器必须显式触发对子节点的访问，树的遍历过程才能正常进行，所以访问器可以控制访问的顺序以及节点被访问的次数。</p>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>ANTLR 提供了 ParseTree-Walker 类，自动遍历树然后生成事件并调用监听器。<br>每个语法文件都会生成一个 ParseTreeLisener 的子类，里面每个规则都有对应的 enter 方法和 exit 方法()，这些方法也称为”事件方法”。这些方法的入参是 ×××Context，提供该方法所需要的所有信息。监听器的操作逻辑在这些 enter 和 exit 方法内添加。下图显示了 ParseTreeWalker 对监听器方法的完整的调用顺序。<br><img src="/images/antlr/2-5.png"></p>
<h3 id="访问器"><a href="#访问器" class="headerlink" title="访问器"></a>访问器</h3><p>有时候我们希望手动控制遍历数的过程，通过显示的方法调用来访问子节点。在命令行中加入-visitor 选项可以指示 ANTLR 为一个语法生成访问器接口，语法中的每条规则对应接口中的一个 visit 方法。ANTRL 提供了访问器接口和一个默认实现类，这样我们自己只需要覆盖接口中我们感兴趣的方法。<br><img src="/images/antlr/2-6.png"></p>
<p>调用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ParseTree tree &#x3D; ...;&#x2F;&#x2F;语法分析数</span><br><span class="line">MyVisitor v &#x3D; new MyVisitor();&#x2F;&#x2F;访问器接口的实现类</span><br><span class="line">v.visit(tree);&#x2F;&#x2F;visitor访问tree</span><br></pre></td></tr></table></figure>

<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h3><p>文件 ArrayInit.g4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 语法文件通常以grammar关键字开头</span><br><span class="line"> *  这是一个名为ArrayInit的语法，它必须和文件名ArrayInit.g4相匹配</span><br><span class="line"> *&#x2F;</span><br><span class="line">grammar ArrayInit;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;一条名为init的规则，它匹配一对花括号中的、逗号分隔的value</span><br><span class="line">init: &#39;&#123;&#39; value (&#39;,&#39; value)* &#39;)&#39;; &#x2F;&#x2F;必须匹配至少一个value。其中*号用来修饰小括号里的内容，表示任意个。</span><br><span class="line">&#x2F;&#x2F; 一个value可以是嵌套的花括号结构，也可以是一个简单的整数，即INT词法符号</span><br><span class="line">value: init</span><br><span class="line">     | INIT</span><br><span class="line">     ;</span><br><span class="line">&#x2F;&#x2F;语法分析器的规则必须以小写字母开头，词法分析器的规则必须用大写字母开头</span><br><span class="line">INT： [0-9]+;  &#x2F;&#x2F;定义词法符号INT, 它由一个或多个数字组成</span><br><span class="line">WS: [\t\r\n]+ -&gt; skip;     &#x2F;&#x2F;定义词法规则“空白符号”，丢弃之。-&gt; skip表示跳过丢弃的意思。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ANTLR 对 g4 文件解析后，会生成如下文件:ArrayInitParser.java, ArrayInitLexer.java,ArrayInit.tokens,ArrayInitLexer.tokens,ArrayInitListener.java:ArrayBaseListener.java.<br>1 ArrayInitParser.java:对应语法 ArrayInit，每条规则对应里面一个方法。<br>2 ArrayInitLexer.java:用于识别词法规则和文法规则。它是通过 ANTLR 分析词法规则 INT 和 WS，以及语法中的字面值‘{’ ‘}‘ ‘,’生成的。<br>3 ArrrayInit.tokens: ANTLR 会给每个我们定义的词法付豪指定一个数字形式的类型，然后将他们的对应关系存储于该文件中。<br>4 ArrayInitListener.java 和 ArrayBaseListener.java: 在遍历 AST 时,遍历器能够触发一系列事件，并通知我们提供的监听器对象。ArrayInitListener 接口给出了这些回调方法的定义，ArrayBaseListener 是该接口的默认实现类，为其中的每个方法提供了一个空实现。</p>
<h3 id="ANTLR-语法基本标记"><a href="#ANTLR-语法基本标记" class="headerlink" title="ANTLR 语法基本标记"></a>ANTLR 语法基本标记</h3><ul>
<li>语法包含一系列描述语言结构的规则。这些规则既包括类似 stat 和 expr 的描述语法结构的规则，也包括描述标识符和整数之类的词汇符号的规则</li>
<li>语法分析器的规则以小写字母开头</li>
<li>词法分析器的规则以大写字母开头</li>
<li>我们使用|来分隔同一个语言规则的若干备选分支，使用圆括号把一些符号组合成自规则。例如，子规则(‘*‘|’/‘)匹配一个乘法符号或者触发符号。</li>
</ul>
<h3 id="左递归规则"><a href="#左递归规则" class="headerlink" title="左递归规则"></a>左递归规则</h3><p>含义：在某个备选分支的其实位置调用了自身。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr: INT|ID|&#39;(&#39;expr&#39;)&#39;</span><br></pre></td></tr></table></figure>

<h2 id="ANTLR-解析过程的异常处理"><a href="#ANTLR-解析过程的异常处理" class="headerlink" title="ANTLR 解析过程的异常处理"></a>ANTLR 解析过程的异常处理</h2><p>ANTLR 语法分析器能够自动报告语法错误并从错误中恢复继续工作。比如前一个错误的表达式，则输出错误信息。然后继续正确地解析第二个表达式。<br>ANTLR 的错误处理机制有很高的灵活性。我们可以修改输出的错误信息，捕获识别过程中的异常，甚至改变基本的异常处理策略。</p>
<h2 id="在语法和词法文件中添加动作"><a href="#在语法和词法文件中添加动作" class="headerlink" title="在语法和词法文件中添加动作"></a>在语法和词法文件中添加动作</h2><h3 id="定制语法分析"><a href="#定制语法分析" class="headerlink" title="定制语法分析"></a>定制语法分析</h3><ul>
<li>在语法中嵌入任意动作<br>我们创建一个构造器，这样我们就能传入希望提取的列号；另外，我们需要在 row 规则的”(…)+”循环中放置一些动作。<br>下面的例子，是将输入文本中的指定列显示出来。<br>详细的内容，会在第 10 章。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">grammar Rows;</span><br><span class="line"></span><br><span class="line">@parser::members &#123; &#x2F;&#x2F; add members to generated RowsParser</span><br><span class="line">    int col;</span><br><span class="line">    public RowsParser(TokenStream input, int col) &#123; &#x2F;&#x2F; custom constructor</span><br><span class="line">        this(input);</span><br><span class="line">        this.col &#x3D; col;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file: (row NL)+ ;</span><br><span class="line"></span><br><span class="line">row</span><br><span class="line">locals [int i&#x3D;0]</span><br><span class="line">    : (   STUFF</span><br><span class="line">          &#123;</span><br><span class="line">          $i++;</span><br><span class="line">          if ( $i &#x3D;&#x3D; col ) System.out.println($STUFF.text);</span><br><span class="line">          &#125;</span><br><span class="line">      )+</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">TAB  :  &#39;\t&#39; -&gt; skip ;   &#x2F;&#x2F; match but don&#39;t pass to the parser</span><br><span class="line">NL   :  &#39;\r&#39;? &#39;\n&#39; ;     &#x2F;&#x2F; match and pass to the parser</span><br><span class="line">STUFF:  ~[\t\r\n]+ ;     &#x2F;&#x2F; match any chars except tab, newline</span><br></pre></td></tr></table></figure>

<ul>
<li>使用语义判定改变语法分析过程(第 11 章)<br>下面的语法用来处理一组整数”2 9 10 3 1 2 3”。第一个数字 2 代表接下来匹配两个数组 9 和 10。紧接着数字 3 告诉我们匹配接下来的三个数字。<br>我们的目标是创建一份名为 Data 的语法，将 9 和 10 分为一组，然后 1,2,3 分为一组。<br>Data 语法的关键在于一段动作，它的值是布尔类型的，称为一个语义判定:{$i&lt;=$n&gt;}?。它的值在匹配到 n 个输入整数之前保持为 true,其中 n 是 sequence<br>语法中的参数。当语义判定的值为 false 时，对应的备选分支就从语法中“消失”了，因此，它也就从生成的语法分析器中“消失”了。在本例中，语义判定的值为 false 使得”(…)*“循环终止，从 sequence 规则返回。<br><img src="/images/antlr/4-4.png"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">grammar Data;</span><br><span class="line"></span><br><span class="line">file : group+ ;</span><br><span class="line"></span><br><span class="line">group: INT sequence[$INT.int] ;</span><br><span class="line"></span><br><span class="line">sequence[int n]</span><br><span class="line">locals [int i &#x3D; 1;]</span><br><span class="line">     : ( &#123;$i&lt;&#x3D;$n&#125;? INT &#123;$i++;&#125; )* &#x2F;&#x2F; match n integers</span><br><span class="line">     ;</span><br><span class="line"></span><br><span class="line">INT :   [0-9]+ ;             &#x2F;&#x2F; match integers</span><br><span class="line">WS  :   [ \t\n\r]+ -&gt; skip ; &#x2F;&#x2F; toss out all whitespace</span><br></pre></td></tr></table></figure>

<h3 id="定制词法分析"><a href="#定制词法分析" class="headerlink" title="定制词法分析"></a>定制词法分析</h3><ul>
<li>孤岛语法:处理想吐文件中的不同格式<br>mode INSIDE 定义模式，INSIDE 模式用于识别 XML 标签，默认模式用于识别标签之外的文本。<br>-&gt;定义了动作进入到 INSIDE 模式下<br>-&gt;定义了动作 popMode，从 INSIDE 模式下退出。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">lexer grammar XMLLexer;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Default &quot;mode&quot;: Everything OUTSIDE of a tag</span><br><span class="line">OPEN        :   &#39;&lt;&#39;                 -&gt; pushMode(INSIDE) ;</span><br><span class="line">COMMENT     :   &#39;&lt;!--&#39; .*? &#39;--&gt;&#39;    -&gt; skip ;</span><br><span class="line">EntityRef   :   &#39;&amp;&#39; [a-z]+ &#39;;&#39; ;</span><br><span class="line">TEXT        :   ~(&#39;&lt;&#39;|&#39;&amp;&#39;)+ ;           &#x2F;&#x2F; match any 16 bit char minus &lt; and &amp;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------------- Everything INSIDE of a tag ---------------------</span><br><span class="line">mode INSIDE;</span><br><span class="line"></span><br><span class="line">CLOSE       :   &#39;&gt;&#39;                 -&gt; popMode ; &#x2F;&#x2F; back to default mode</span><br><span class="line">SLASH_CLOSE :   &#39;&#x2F;&gt;&#39;                -&gt; popMode ;</span><br><span class="line">EQUALS      :   &#39;&#x3D;&#39; ;</span><br><span class="line">STRING      :   &#39;&quot;&#39; .*? &#39;&quot;&#39; ;</span><br><span class="line">SlashName   :   &#39;&#x2F;&#39; Name ;</span><br><span class="line">Name        :   ALPHA (ALPHA|DIGIT)* ;</span><br><span class="line">S           :   [ \t\r\n]           -&gt; skip ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">ALPHA       :   [a-zA-Z] ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">DIGIT       :   [0-9] ;</span><br></pre></td></tr></table></figure>

<ul>
<li>重写输入流<br>TokenStreamRewriter 对象可以改写输入的 TokenStream。关键之处，TokenStreamRewriter 对象实际上修改的是词法符号流的“视图”而非词法符号<br>流本身。它认为所有对修改方法的调用都只是一个“指令”，然后将这些修改放入一个队列；在未来词法符号流被重新渲染为文本时，这些修改才会被执行。<br>在每次我们调用 getText()的时候，rewriter 对象都会执行上述队列中的指令。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class InsertSerialIDListener extends JavaBaseListener &#123;</span><br><span class="line">    TokenStreamRewriter rewriter;</span><br><span class="line">    public InsertSerialIDListener(TokenStream tokens) &#123;</span><br><span class="line">        rewriter &#x3D; new TokenStreamRewriter(tokens);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void enterClassBody(JavaParser.ClassBodyContext ctx) &#123;</span><br><span class="line">        String field &#x3D; &quot;\n\tpublic static final long serialVersionUID &#x3D; 1L;&quot;;</span><br><span class="line">        rewriter.insertAfter(ctx.start, field);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将词法符号送入不同通道<br>忽略却保留注释和空白字符的秘诀是将这些词法符号送入一个“隐藏通道”。语法分析器只处理一个通道，因此我们可以将希望保留的词法符号送入其他通道内。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COMMENT</span><br><span class="line">    :   &#39;&#x2F;*&#39; .*? &#39;*&#x2F;&#39;    -&gt; channel(HIDDEN) &#x2F;&#x2F; match anything between &#x2F;* and *&#x2F;</span><br><span class="line">    ;</span><br><span class="line">WS  :   [ \r\t\u000C\n]+ -&gt; channel(HIDDEN)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<h2 id="将生成的语法分析器与-Java-程序集成，并使用监听器遍历处理"><a href="#将生成的语法分析器与-Java-程序集成，并使用监听器遍历处理" class="headerlink" title="将生成的语法分析器与 Java 程序集成，并使用监听器遍历处理"></a>将生成的语法分析器与 Java 程序集成，并使用监听器遍历处理</h2><h3 id="例子-1-1"><a href="#例子-1-1" class="headerlink" title="例子 1"></a>例子 1</h3><p>Test.java<br>此例子的目标是将 Java 中，类似{99, 3, 451}的 short 数组翻译成”\u0063\u0003\u01c3”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import org.antlr.v4.runtime.*;</span><br><span class="line">import org.antlr.v4.runtime.tree.*;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">    public static void amin(String[] args) throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;新建一个CharStream，从标准输入读取数据</span><br><span class="line">        ANTLRInputStream input &#x3D; new ANTLRInputStream(System.in);</span><br><span class="line">        &#x2F;&#x2F;新建一个词法分析器，处理输入的CharStream</span><br><span class="line">        ArrayInitLexer lexer - new ArrayInitLexer(input);</span><br><span class="line">        &#x2F;&#x2F;新建一个词法符号的缓冲区，用于存储词法分析器将生成的词法符号</span><br><span class="line">        CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">        &#x2F;&#x2F;新建一个语法分析器，处理词法符号缓冲区中的内容</span><br><span class="line">        ArrayInitParser parser &#x3D; new ArrayInitParser(tokens);</span><br><span class="line">        ParseTree tree &#x3D; parser.init(); &#x2F;&#x2F;针对init规则，开始语法分析。因为init规则是这些规则中根规则，所以适合从init开始分析</span><br><span class="line">        &#x2F;*System.out.println(tree.toStringTree(parser));&#x2F;&#x2F;用LISP风格打印生成的树*&#x2F;</span><br><span class="line">        &#x2F;&#x2F;新建一个通用的、能够触发回调函数的语法分析树遍历器</span><br><span class="line">        ParseTreeWalker walker &#x3D; new ParseTreeWalker();</span><br><span class="line">        &#x2F;&#x2F;遍历语法分析过程中生成的语法分析树，触发回调</span><br><span class="line">        walker.walk(new ShortToUnicodeString(), tree);</span><br><span class="line">        System.out.println();&#x2F;&#x2F;翻译完成后，打印一个\n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ShortToUnicodeString.java<br>当遍历 AST 的时候，会对监听器里的方法进行回调。ArrayInitBaseListener 实现了 ArrayInitListener 接口的每个方法，我们只需要继承 ArrayInitBaseListener 并重写自己感兴趣的方法，就可以达到目的。ShortToUnicodeString 中的方法将翻译输入数据的一部分并将结果打印出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将类似&#123;1,2,3&#125;的short数组初始化语句翻译为&quot;\u0001\u0002\u0003&quot;</span><br><span class="line">public class ShortToUnicodeString extends ArrayInitBaseListener &#123;</span><br><span class="line">    &#x2F;&#x2F;将&#123;翻译为&quot;</span><br><span class="line">    @Override</span><br><span class="line">    public void enterInit(ArrayInitParser.InitContext ctx)&#123;</span><br><span class="line">        System.out.print(&#39;&quot;&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;将&#125;翻译为&quot;</span><br><span class="line">    @Override</span><br><span class="line">    public void exitInit(ArrayInitParser.InitContext ctx)&#123;</span><br><span class="line">        System.out.print(&#39;&quot;&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;将每个整数翻译为四位的十六进制形式，然后加前缀\u</span><br><span class="line">    @Override</span><br><span class="line">    public void enterValue(ArrrayInitParser.ValueContext ctx) &#123;</span><br><span class="line">        &#x2F;&#x2F;假定不存在嵌套结构</span><br><span class="line">        int value &#x3D; Integer.valueOf(ctx.INT().getText());&#x2F;&#x2F;ctx是value的上下文对象，它获取INT词法符号对应的整数值。</span><br><span class="line">        System.out.printf(&quot;\\u%04x&quot;, value);&#x2F;&#x2F;输出16进制数，总共占4为，前面的空位补0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h3><p>LibExpr.g4<br>此例子用来展示，将语法词法规则分布到多个不同文件中。<br>使用 import 功能，可以将一个大的语法文件分隔成小的，然后 import 导入连到一起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">grammar LibExpr;         &#x2F;&#x2F; Rename to distinguish from original</span><br><span class="line">import CommonLexerRules; &#x2F;&#x2F; includes all rules from CommonLexerRules.g4</span><br><span class="line">&#x2F;** The start rule; begin parsing here. *&#x2F;</span><br><span class="line">prog:   stat+ ;</span><br><span class="line"></span><br><span class="line">stat:   expr NEWLINE</span><br><span class="line">    |   ID &#39;&#x3D;&#39; expr NEWLINE</span><br><span class="line">    |   NEWLINE</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expr:   expr (&#39;*&#39;|&#39;&#x2F;&#39;) expr &#x2F;&#x2F;左递归</span><br><span class="line">    |   expr (&#39;+&#39;|&#39;-&#39;) expr</span><br><span class="line">    |   INT</span><br><span class="line">    |   ID</span><br><span class="line">    |   &#39;(&#39; expr &#39;)&#39;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>CommonLexerRules.g4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lexer grammar CommonLexerRules; &#x2F;&#x2F; note &quot;lexer grammar&quot;</span><br><span class="line"></span><br><span class="line">ID  :   [a-zA-Z]+ ;      &#x2F;&#x2F; match identifiers</span><br><span class="line">INT :   [0-9]+ ;         &#x2F;&#x2F; match integers</span><br><span class="line">NEWLINE:&#39;\r&#39;? &#39;\n&#39; ;     &#x2F;&#x2F; return newlines to parser (end-statement signal)</span><br><span class="line">WS  :   [ \t]+ -&gt; skip ; &#x2F;&#x2F; toss out whitespace. &#39;-&gt; skip&#39;是丢弃操作。</span><br></pre></td></tr></table></figure>

<p>ExprJoyRide.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import org.antlr.v4.runtime.*;</span><br><span class="line">import org.antlr.v4.runtime.tree.*;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">public class ExprJoyRide &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;新建输入流</span><br><span class="line">        String inputFile &#x3D; null;</span><br><span class="line">        if ( args.length&gt;0 ) inputFile &#x3D; args[0];</span><br><span class="line">        InputStream is &#x3D; System.in;</span><br><span class="line">        if ( inputFile!&#x3D;null ) is &#x3D; new FileInputStream(inputFile);</span><br><span class="line">        ANTLRInputStream input &#x3D; new ANTLRInputStream(is);</span><br><span class="line">        &#x2F;&#x2F;新建词法分析器和语法分析器</span><br><span class="line">        ExprLexer lexer &#x3D; new ExprLexer(input);</span><br><span class="line">        CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">        ExprParser parser &#x3D; new ExprParser(tokens);</span><br><span class="line">        &#x2F;&#x2F;启动语法分析器开始解析</span><br><span class="line">        ParseTree tree &#x3D; parser.prog();</span><br><span class="line">        &#x2F;&#x2F;用文本形式将该规则方法prog()返回的语法分析树打印出来</span><br><span class="line">        System.out.println(tree.toStringTree(parser));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例子-3-访问器"><a href="#例子-3-访问器" class="headerlink" title="例子 3 访问器"></a>例子 3 访问器</h3><p>LabeledExpr.g4<br>为每个备选分支定义一个标签，标签以#开头。这样 ANTLR 会为每个备选分支生成不同的访问器方法。这样我们就可以对每种输入都获得一个不同的事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">grammar LabeledExpr; &#x2F;&#x2F; rename to distinguish from Expr.g4</span><br><span class="line"></span><br><span class="line">prog:   stat+ ;</span><br><span class="line"></span><br><span class="line">stat:   expr NEWLINE                # printExpr</span><br><span class="line">    |   ID &#39;&#x3D;&#39; expr NEWLINE         # assign</span><br><span class="line">    |   NEWLINE                     # blank</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expr:   expr op&#x3D;(&#39;*&#39;|&#39;&#x2F;&#39;) expr      # MulDiv</span><br><span class="line">    |   expr op&#x3D;(&#39;+&#39;|&#39;-&#39;) expr      # AddSub</span><br><span class="line">    |   INT                         # int</span><br><span class="line">    |   ID                          # id</span><br><span class="line">    |   &#39;(&#39; expr &#39;)&#39;                # parens</span><br><span class="line">    ;</span><br><span class="line">&#x2F;&#x2F;接下来我们为运算符词法付豪定义一些名字，这样在随后的访问器中，我们就可以将这些词法符号的名字当做JAVA常量来引用。</span><br><span class="line">MUL :   &#39;*&#39; ; &#x2F;&#x2F; assigns token name to &#39;*&#39; used above in grammar</span><br><span class="line">DIV :   &#39;&#x2F;&#39; ;</span><br><span class="line">ADD :   &#39;+&#39; ;</span><br><span class="line">SUB :   &#39;-&#39; ;</span><br><span class="line">ID  :   [a-zA-Z]+ ;      &#x2F;&#x2F; match identifiers</span><br><span class="line">INT :   [0-9]+ ;         &#x2F;&#x2F; match integers</span><br><span class="line">NEWLINE:&#39;\r&#39;? &#39;\n&#39; ;     &#x2F;&#x2F; return newlines to parser (is end-statement signal)</span><br><span class="line">WS  :   [ \t]+ -&gt; skip ; &#x2F;&#x2F; toss out whitespace</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Calc &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        String inputFile &#x3D; null;</span><br><span class="line">        if ( args.length&gt;0 ) inputFile &#x3D; args[0];</span><br><span class="line">        InputStream is &#x3D; System.in;</span><br><span class="line">        if ( inputFile!&#x3D;null ) is &#x3D; new FileInputStream(inputFile);</span><br><span class="line">        ANTLRInputStream input &#x3D; new ANTLRInputStream(is);</span><br><span class="line">        LabeledExprLexer lexer &#x3D; new LabeledExprLexer(input);</span><br><span class="line">        CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">        LabeledExprParser parser &#x3D; new LabeledExprParser(tokens);</span><br><span class="line">        ParseTree tree &#x3D; parser.prog(); &#x2F;&#x2F; parse</span><br><span class="line">        &#x2F;&#x2F;实例化一个自定义的访问器，然后访问tree</span><br><span class="line">        EvalVisitor eval &#x3D; new EvalVisitor();</span><br><span class="line">        eval.visit(tree);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用如下命令可以生成 visitor<br><code>antlr4 -no-listener -visitor LabeledExpr.g4</code><br>可以生成，LabeledExprBaseVisitor.java,LabeledExprParse.java,LabeledExprLexer.java,LabeledExprVisitor.java。<br>LabeledExprVisitor 是接口，LabeledExprBaseVisitor 是默认实现类。我们可以继承 LabeledExprBaseVisitor 然后重写里面的函数来实现自定义的逻辑。<br>EvalVisitor 内重写的方法对应备选分支的标签。里面引用的 JAVA 常量如：MUL，DIV 等。也是在语法文件中定义的词法符号名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class EvalVisitor extends LabeledExprBaseVisitor&lt;Integer&gt; &#123;</span><br><span class="line">    &#x2F;** &quot;memory&quot; for our calculator; variable&#x2F;value pairs go here *&#x2F;</span><br><span class="line">    Map&lt;String, Integer&gt; memory &#x3D; new HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;** ID &#39;&#x3D;&#39; expr NEWLINE *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitAssign(LabeledExprParser.AssignContext ctx) &#123;</span><br><span class="line">        String id &#x3D; ctx.ID().getText();  &#x2F;&#x2F; id is left-hand side of &#39;&#x3D;&#39;</span><br><span class="line">        int value &#x3D; visit(ctx.expr());   &#x2F;&#x2F; compute value of expression on right</span><br><span class="line">        memory.put(id, value);           &#x2F;&#x2F; store it in our memory</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** expr NEWLINE *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitPrintExpr(LabeledExprParser.PrintExprContext ctx) &#123;</span><br><span class="line">        Integer value &#x3D; visit(ctx.expr()); &#x2F;&#x2F; evaluate the expr child</span><br><span class="line">        System.out.println(value);         &#x2F;&#x2F; print the result</span><br><span class="line">        return 0;                          &#x2F;&#x2F; return dummy value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** INT *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitInt(LabeledExprParser.IntContext ctx) &#123;</span><br><span class="line">        return Integer.valueOf(ctx.INT().getText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** ID *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitId(LabeledExprParser.IdContext ctx) &#123;</span><br><span class="line">        String id &#x3D; ctx.ID().getText();</span><br><span class="line">        if ( memory.containsKey(id) ) return memory.get(id);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** expr op&#x3D;(&#39;*&#39;|&#39;&#x2F;&#39;) expr *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitMulDiv(LabeledExprParser.MulDivContext ctx) &#123;</span><br><span class="line">        int left &#x3D; visit(ctx.expr(0));  &#x2F;&#x2F; get value of left subexpression</span><br><span class="line">        int right &#x3D; visit(ctx.expr(1)); &#x2F;&#x2F; get value of right subexpression</span><br><span class="line">        if ( ctx.op.getType() &#x3D;&#x3D; LabeledExprParser.MUL ) return left * right;</span><br><span class="line">        return left &#x2F; right; &#x2F;&#x2F; must be DIV</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** expr op&#x3D;(&#39;+&#39;|&#39;-&#39;) expr *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitAddSub(LabeledExprParser.AddSubContext ctx) &#123;</span><br><span class="line">        int left &#x3D; visit(ctx.expr(0));  &#x2F;&#x2F; get value of left subexpression</span><br><span class="line">        int right &#x3D; visit(ctx.expr(1)); &#x2F;&#x2F; get value of right subexpression</span><br><span class="line">        if ( ctx.op.getType() &#x3D;&#x3D; LabeledExprParser.ADD ) return left + right;</span><br><span class="line">        return left - right; &#x2F;&#x2F; must be SUB</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** &#39;(&#39; expr &#39;)&#39; *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitParens(LabeledExprParser.ParensContext ctx) &#123;</span><br><span class="line">        return visit(ctx.expr()); &#x2F;&#x2F; return child expr&#39;s value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子 4"></a>例子 4</h3><p>使用监听器来对 java 语法进行分析，根据实现类可以生成对应的接口定义，并保留注释<br>Java.g4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">classDeclaration</span><br><span class="line">    :   &#39;class&#39; Identifier typeParameters? (&#39;extends&#39; type)?</span><br><span class="line">        (&#39;implements&#39; typeList)?</span><br><span class="line">        classBody</span><br><span class="line">    ;</span><br><span class="line">methodDeclaration</span><br><span class="line">    :   type Identifier formalParameters (&#39;[&#39; &#39;]&#39;)* methodDeclarationRest</span><br><span class="line">    |   &#39;void&#39; Identifier formalParameters methodDeclarationRest</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>ExtractInterfaceListener.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ExtractInterfaceListener extends JavaBaseListener &#123;</span><br><span class="line">    JavaParser parser;</span><br><span class="line">    public ExtractInterfaceListener(JavaParser parser) &#123;this.parser &#x3D; parser;&#125;</span><br><span class="line">    &#x2F;** Listen to matches of classDeclaration *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void enterClassDeclaration(JavaParser.ClassDeclarationContext ctx)&#123;</span><br><span class="line">        System.out.println(&quot;interface I&quot;+ctx.Identifier()+&quot; &#123;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void exitClassDeclaration(JavaParser.ClassDeclarationContext ctx) &#123;</span><br><span class="line">        System.out.println(&quot;&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Listen to matches of methodDeclaration *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void enterMethodDeclaration(</span><br><span class="line">        JavaParser.MethodDeclarationContext ctx</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; need parser to get tokens</span><br><span class="line">        TokenStream tokens &#x3D; parser.getTokenStream();</span><br><span class="line">        String type &#x3D; &quot;void&quot;;&#x2F;&#x2F;type为方法的返回类型</span><br><span class="line">        if ( ctx.type()!&#x3D;null ) &#123;</span><br><span class="line">            type &#x3D; tokens.getText(ctx.type());</span><br><span class="line">        &#125;</span><br><span class="line">        String args &#x3D; tokens.getText(ctx.formalParameters());&#x2F;&#x2F;args是入参</span><br><span class="line">        System.out.println(&quot;\t&quot;+type+&quot; &quot;+ctx.Identifier()+args+&quot;;&quot;);&#x2F;&#x2F;ctx.Identifier()是方法名</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ExtractInterfaceTool.java<br>将自定义的监听器集成到程序里，并遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ExtractInterfaceTool &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        String inputFile &#x3D; null;</span><br><span class="line">        if ( args.length&gt;0 ) inputFile &#x3D; args[0];</span><br><span class="line">        InputStream is &#x3D; System.in;</span><br><span class="line">        if ( inputFile!&#x3D;null ) &#123;</span><br><span class="line">            is &#x3D; new FileInputStream(inputFile);</span><br><span class="line">        &#125;</span><br><span class="line">        ANTLRInputStream input &#x3D; new ANTLRInputStream(is);</span><br><span class="line"></span><br><span class="line">        JavaLexer lexer &#x3D; new JavaLexer(input);</span><br><span class="line">        CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">        JavaParser parser &#x3D; new JavaParser(tokens);</span><br><span class="line">        ParseTree tree &#x3D; parser.compilationUnit(); &#x2F;&#x2F; parse。开始语法分析的过程</span><br><span class="line"></span><br><span class="line">        ParseTreeWalker walker &#x3D; new ParseTreeWalker(); &#x2F;&#x2F; create standard walker，新建一个标准的遍历器</span><br><span class="line">        ExtractInterfaceListener extractor &#x3D; new ExtractInterfaceListener(parser);</span><br><span class="line">        walker.walk(extractor, tree); &#x2F;&#x2F; initiate walk of tree with listener，使用监听器初始化对语法分析树的遍历</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/13/%E6%B1%87%E7%BC%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/13/%E6%B1%87%E7%BC%96/" class="post-title-link" itemprop="url">汇编</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-13 16:00:00 / Modified: 15:15:19" itemprop="dateCreated datePublished" datetime="2020-12-13T16:00:00+08:00">2020-12-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="“被调用者保存”和“调用者保存”寄存器"><a href="#“被调用者保存”和“调用者保存”寄存器" class="headerlink" title="“被调用者保存”和“调用者保存”寄存器"></a>“被调用者保存”和“调用者保存”寄存器</h2><p>编译器的设计中有个概念叫做“被调用者保存”和“调用者保存”，可以近似的按子函数保存和父函数保存对应来理解，这一概念的出现完全是由于寄存器资源个数有限造成的。当父函数在调用子函数时，由于子函数可能访问到父函数用于保存数值的寄存器，为了互不干扰和造成覆盖，编译器就制定了相应的规则，%eax、%edx 和%ecx 被划分为“调用者保存”寄存器，顾名思义，这些寄存器上面存储的值，需要调用者（父函数）自己想办法先备份好，否则过会子函数直接使用这些寄存器时将无情的覆盖。如何备份？当然是事先压入栈中，等子函数调用完，再通过出栈恢复这些寄存器原本在父函数运行时的旧值；另外三个寄存器%ebx、%esi、%edi 被划分为“被调用者保存”寄存器，同样的，这些寄存器上有值，在使用前需要被调用者（子函数）自己想办法帮调用者（父函数）进行备份，具体方法就是子函数在覆盖他们之前，先进行入栈备份，等子函数返回时，再出栈还原父函数运行时这些寄存器上的旧值。</p>
<h2 id="七种寻址方式"><a href="#七种寻址方式" class="headerlink" title="七种寻址方式"></a>七种寻址方式</h2><h3 id="1-立即寻址方式"><a href="#1-立即寻址方式" class="headerlink" title="1 立即寻址方式"></a>1 立即寻址方式</h3><p>操作数作为指令的一部分而直接写在指令中，这种操作数称为立即数，这种寻址方式也就称为立即数寻址方式。</p>
<p>立即数可以是 8 位、16 位或 32 位，该数值紧跟在操作码之后。如果立即数为 16 位或 32 位，那么，它将按“高高低低”的原则进行存储。例如：</p>
<p>MOV AH, 80H 　　　 ADD AX, 1234H 　　　 MOV ECX, 123456H<br>MOV B1, 12H 　　　 MOV W1, 3456H 　　 ADD D1, 32123456H</p>
<p>其中：B1、W1 和 D1 分别是字节、字和双字单元。</p>
<p>以上指令中的第二操作数都是立即数，在汇编语言中，规定：立即数不能作为指令中的第二操作数。该规定与高级语言中“赋值语句的左边不能是常量”的规定相一致。</p>
<p>立即数寻址方式通常用于对通用寄存器或内存单元赋初值。图是指令“MOV AX, 4576H”存储形式和执行示意图。</p>
<h3 id="2-寄存器寻址方式"><a href="#2-寄存器寻址方式" class="headerlink" title="2 寄存器寻址方式"></a>2 寄存器寻址方式</h3><p>指令所要的操作数已存储在某寄存器中，或把目标操作数存入寄存器。把在指令中指出所使用寄存器(即：寄存器的助忆符)的寻址方式称为寄存器寻址方式。<br>指令中可以引用的寄存器及其符号名称如下：<br>　　 8 位寄存器有：AH、AL、BH、BL、CH、CL、DH 和 DL 等；<br>　　 16 位寄存器有：AX、BX、CX、DX、SI、DI、SP、BP 和段寄存器等；<br>　　 32 位寄存器有：EAX、EBX、ECX、EDX、ESI、EDI、ESP 和 EBP 等。<br>寄存器寻址方式是一种简单快捷的寻址方式，源和目的操作数都可以是寄存器。</p>
<p>1、源操作数是寄存器寻址方式<br>　　如：ADD VARD, EAX 　　 ADD VARW, AX 　　　 MOV VARB, BH 等。<br>　　其中：VARD、VARW 和 VARB 是双字，字和字节类型的内存变量。在第 4 章将会学到如何定义它们。</p>
<p>2、目的操作数是寄存器寻址方式<br>　　如：ADD BH, 78h 　　　　 ADD AX, 1234h 　　　 MOV EBX, 12345678H 等。</p>
<p>3、源和目的操作数都是寄存器寻址方式<br>　　如：MOV EAX, EBX 　　　 MOV AX, BX 　　　　 MOV DH, BL 等。</p>
<p>由于指令所需的操作数已存储在寄存器中，或操作的结果存入寄存器，这样，在指令执行过程中，会减少读/写存储器单元的次数，所以，使用寄存器寻址方式的指令具有较快的执行速度。通常情况下，我们提倡在编写汇编语言程序时，应尽可能地使用寄存器寻址方式，但也不要把它绝对化。</p>
<h3 id="3-七种寻址方式-直接寻址方式"><a href="#3-七种寻址方式-直接寻址方式" class="headerlink" title="3 七种寻址方式(直接寻址方式)"></a>3 七种寻址方式(直接寻址方式)</h3><p>指令所要的操作数存放在内存中，在指令中直接给出该操作数的有效地址，这种寻址方式为直接寻址方式。</p>
<p>在通常情况下，操作数存放在数据段中，所以，其物理地址将由数据段寄存器 DS 和指令中给出的有效地址直接形成，但如果使用段超越前缀，那么，操作数可存放在其它段。</p>
<p>例：假设有指令：MOV BX, [1234H]，在执行时，(DS)=2000H，内存单元 21234H 的值为 5213H。问该指令执行后，BX 的值是什么？</p>
<p>解：根据直接寻址方式的寻址规则，把该指令的具体执行过程用下图来表示。</p>
<p>从图中，可看出执行该指令要分三部分：</p>
<p>由于 1234H 是一个直接地址，它紧跟在指令的操作码之后，随取指令而被读出；</p>
<p>访问数据段的段寄存器是 DS，所以，用 DS 的值和偏移量 1234H 相加，得存储单元的物理地址：21234H；</p>
<p>取单元 21234H 的值 5213H，并按“高高低低”的原则存入寄存器 BX 中。</p>
<p>所以，在执行该指令后，BX 的值就为 5213H。</p>
<p>由于数据段的段寄存器默认为 DS，如果要指定访问其它段内的数据，可在指令中用段前缀的方式显式地书写出来。</p>
<p>下面指令的目标操作数就是带有段前缀的直接寻址方式。</p>
<p>MOV 　 ES:[1000H], AX</p>
<p>直接寻址方式常用于处理内存单元的数据，其操作数是内存变量的值，该寻址方式可在 64K 字节的段内进行寻址。</p>
<p>注意：立即寻址方式和直接寻址方式的书写格式的不同，直接寻址的地址要写在括号“[”，“]”内。在程序中，直接地址通常用内存变量名来表示，如：MOV BX, VARW，其中，VARW 是内存字变量。</p>
<p>试比较下列指令中源操作数的寻址方式(VARW 是内存字变量)：<br>　　 MOV 　 AX, 1234H MOV 　 AX, [1234H] ;前者是立即寻址，后者是直接寻址<br>　　 MOV 　 AX, VARW MOV 　 AX, [VARW] ;两者是等效的，均为直接寻址</p>
<h3 id="4-七种寻址方式-寄存器间接寻址方式"><a href="#4-七种寻址方式-寄存器间接寻址方式" class="headerlink" title="4 七种寻址方式(寄存器间接寻址方式)"></a>4 七种寻址方式(寄存器间接寻址方式)</h3><p>操作数在存储器中，操作数的有效地址用 SI、DI、BX 和 BP 等四个寄存器之一来指定，称这种寻址方式为寄存器间接寻址方式。该寻址方式物理地址的计算方法如下：</p>
<p>寄存器间接寻址方式读取存储单元的原理如图所示。</p>
<p>在不使用段超越前缀的情况下，有下列规定：</p>
<p>若有效地址用 SI、DI 和 BX 等之一来指定，则其缺省的段寄存器为 DS；<br>若有效地址用 BP 来指定，则其缺省的段寄存器为 SS(即：堆栈段)。</p>
<p>例:假设有指令：MOV BX,[DI]，在执行时，(DS)=1000H，(DI)=2345H，存储单元 12345H 的内容是 4354H。问执行指令后，BX 的值是什么？</p>
<p>解：根据寄存器间接寻址方式的规则，在执行本例指令时，寄存器 DI 的值不是操作数，而是操作数的地址。该操作数的物理地址应由 DS 和 DI 的值形成，即：</p>
<p>PA=(DS)<em>16+DI=1000H</em>16+2345H=12345H。</p>
<p>所以，该指令的执行效果是：把从物理地址为 12345H 开始的一个字的值传送给 BX。</p>
<p>其执行过程如图所示。</p>
<h3 id="5-七种寻址方式（寄存器相对寻址方式）"><a href="#5-七种寻址方式（寄存器相对寻址方式）" class="headerlink" title="5 七种寻址方式（寄存器相对寻址方式）"></a>5 七种寻址方式（寄存器相对寻址方式）</h3><p>操作数在存储器中，其有效地址是一个基址寄存器(BX、BP)或变址寄存器(SI、D</p>
<p>I)的内容和指令中的 8 位/16 位偏移量之和。其有效地址的计算公式如公式所示。</p>
<p>在不使用段超越前缀的情况下，有下列规定：</p>
<pre><code>若有效地址用SI、DI和BX等之一来指定，则其缺省的段寄存器为DS；

若有效地址用BP来指定，则其缺省的段寄存器为SS。</code></pre>
<p>指令中给出的 8 位/16 位偏移量用补码表示。在计算有效地址时，如果偏移量是 8 位，则进行符号扩展成 16 位。当所得的有效地址超过 0FFFFH，则取其 64K 的模。</p>
<p>例:假设指令：MOV BX, [SI+100H]，在执行它时，(DS)=1000H，(SI)=2345H，内存单元 12445H 的内容为 2715H，问该指令执行后，BX 的值是什么？</p>
<p>解：根据寄存器相对寻址方式的规则，在执行本例指令时，源操作数的有效地址 EA 为：</p>
<p>EA=(SI)+100H=2345H+100H=2445H</p>
<p>该操作数的物理地址应由 DS 和 EA 的值形成，即：</p>
<p>PA=(DS)<em>16+EA=1000H</em>16+2445H=12445H。</p>
<p>所以，该指令的执行效果是：把从物理地址为 12445H 开始的一个字的值传送给 BX。</p>
<p>其执行过程如图所示。</p>
<h3 id="6-七种寻址方式-基址加变址寻址方式"><a href="#6-七种寻址方式-基址加变址寻址方式" class="headerlink" title="6 七种寻址方式(基址加变址寻址方式)"></a>6 七种寻址方式(基址加变址寻址方式)</h3><p>操作数在存储器中，其有效地址是一个基址寄存器(BX、BP)和一个变址寄存器(SI、DI)的内容之和。其有效地址的计算公式如公式所示。</p>
<p>在不使用段超越前缀的情况下，规定：如果有效地址中含有 BP，则缺省的段寄存器为 SS；否则，缺省的段寄存器为 DS。</p>
<p>例:假设指令：MOV BX, [BX+SI]，在执行时，(DS)=1000H，(BX)=2100H，(SI)=0011H，内存单元 12111H 的内容为 1234H。问该指令执行后，BX 的值是什么？</p>
<p>解：根据基址加变址寻址方式的规则，在执行本例指令时，源操作数的有效地址 EA 为：</p>
<p>EA=(BX)+(SI)=2100H+0011H=2111H</p>
<p>该操作数的物理地址应由 DS 和 EA 的值形成，即：</p>
<p>PA=(DS)<em>16+EA=1000H</em>16+2111H=12111H</p>
<p>所以，该指令的执行效果是：把从物理地址为 12111H 开始的一个字的值传送给 BX。</p>
<p>其执行过程如图所示。</p>
<h3 id="7-七种寻址方式-相对基址加变址寻址方式"><a href="#7-七种寻址方式-相对基址加变址寻址方式" class="headerlink" title="7 七种寻址方式(相对基址加变址寻址方式)"></a>7 七种寻址方式(相对基址加变址寻址方式)</h3><p>操作数在存储器中，其有效地址是一个基址寄存器(BX、BP)的值、一个变址寄存器(SI、DI)的值和指令中的 8 位/16 位偏移量之和。其有效地址的计算公式如公式所示。</p>
<p>在不使用段超越前缀的情况下，规定：如果有效地址中含有 BP，则其缺省的段寄存器为 SS；否则，其缺省的段寄存器为 DS。</p>
<p>指令中给出的 8 位/16 位偏移量用补码表示。在计算有效地址时，如果偏移量是 8 位，则进行符号扩展成 16 位。当所得的有效地址超过 0FFFFH，则取其 64K 的模。</p>
<p>例:假设指令：MOV AX, [BX+SI+200H]，在执行时，(DS)=1000H，(BX)=2100H，(SI)=0010H，内存单元 12310H 的内容为 1234H。问该指令执行后，AX 的值是什么？</p>
<p>解：根据相对基址加变址寻址方式的规则，在执行本例指令时，源操作数的有效地址 EA 为：</p>
<p>EA=(BX)+(SI)+200H=2100H+0010H+200H=2310H</p>
<p>该操作数的物理地址应由 DS 和 EA 的值形成，即：</p>
<p>PA=(DS)<em>16+EA=1000H</em>16+2310H=12310H</p>
<p>所以，该指令的执行效果是：把从物理地址为 12310H 开始的一个字的值传送给 AX。其执行过程如图所示。</p>
<p>从相对基址加变址这种寻址方式来看，由于它的可变因素较多，看起来就显得复杂些，但正因为其可变因素多，它的灵活性也就很高。比如：</p>
<p>用 D1[i]来访问一维数组 D1 的第 i 个元素，它的寻址有一个自由度，用 D2[i][j]来访问二维数组 D2 的第 i 行、第 j 列的元素，其寻址有二个自由度。多一个可变的量，其寻址方式的灵活度也就相应提高了。</p>
<p>相对基址加变址寻址方式有多种等价的书写方式，下面的书写格式都是正确的，并且其寻址含义也是一致的。</p>
<p>MOV 　 AX, [BX+SI+1000H]　　　 MOV 　 AX, 1000H[BX+SI]<br>MOV 　 AX, 1000H[BX][si]　　　 MOV 　 AX, 1000H[SI][bx]</p>
<p>但书写格式 BX [1000+SI]和 SI[1000H+BX]等是错误的，即所用寄存器不能在“[“，”]”之外，该限制对寄存器相对寻址方式的书写也同样起作用。</p>
<p>相对基址加变址寻址方式是以上 7 种寻址方式中最复杂的一种寻址方式，它可变形为其它类型的存储器寻址方式。下表列举出该寻址方式与其它寻址方式之间的变形关系。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/07/KAFKA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/07/KAFKA/" class="post-title-link" itemprop="url">KAFKA</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-07 16:07:30 / Modified: 10:09:29" itemprop="dateCreated datePublished" datetime="2020-12-07T16:07:30+08:00">2020-12-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/images/kafka-1.png"></p>
<h2 id="1-根目录下的结构"><a href="#1-根目录下的结构" class="headerlink" title="1.根目录下的结构"></a>1.根目录下的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 72] ls &#x2F;</span><br><span class="line">[isr_change_notification, zookeeper, admin, consumers, cluster, config, latest_producer_id_block, controller, brokers, controller_epoch]</span><br></pre></td></tr></table></figure>

<h2 id="2-admin-的结构"><a href="#2-admin-的结构" class="headerlink" title="2. admin 的结构"></a>2. admin 的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 73] ls &#x2F;admin</span><br><span class="line">[delete_topics]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 74] ls &#x2F;admin&#x2F;delete_topics</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 75] get &#x2F;admin&#x2F;delete_topics</span><br><span class="line">null</span><br><span class="line">cZxid &#x3D; 0xe</span><br><span class="line">ctime &#x3D; Sun Sep 02 20:04:12 PDT 2018</span><br><span class="line">mZxid &#x3D; 0xe</span><br><span class="line">mtime &#x3D; Sun Sep 02 20:04:12 PDT 2018</span><br><span class="line">pZxid &#x3D; 0xe</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x0</span><br><span class="line">dataLength &#x3D; 0</span><br><span class="line">numChildren &#x3D; 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 76]</span><br></pre></td></tr></table></figure>

<h2 id="3-consumers-的结构"><a href="#3-consumers-的结构" class="headerlink" title="3.consumers 的结构"></a>3.consumers 的结构</h2><p>本环境上没有设置消费组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 78] ls &#x2F;consumers</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 79] get &#x2F;consumers</span><br><span class="line">null</span><br><span class="line">cZxid &#x3D; 0x2</span><br><span class="line">ctime &#x3D; Sun Sep 02 20:04:12 PDT 2018</span><br><span class="line">mZxid &#x3D; 0x2</span><br><span class="line">mtime &#x3D; Sun Sep 02 20:04:12 PDT 2018</span><br><span class="line">pZxid &#x3D; 0x2</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x0</span><br><span class="line">dataLength &#x3D; 0</span><br><span class="line">numChildren &#x3D; 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 80]</span><br><span class="line">## 4.config的结构</span><br><span class="line">[zk: localhost:2181(CONNECTED) 82] ls &#x2F;config</span><br><span class="line">[topics, clients, changes]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 83] ls &#x2F;config&#x2F;topics</span><br><span class="line">[__consumer_offsets, test, test2]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 84] ls &#x2F;config&#x2F;topics&#x2F;test2</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 85] get &#x2F;config&#x2F;topics&#x2F;test2</span><br><span class="line">&#123;&quot;version&quot;:1,&quot;config&quot;:&#123;&#125;&#125;</span><br><span class="line">cZxid &#x3D; 0xcc</span><br><span class="line">ctime &#x3D; Sun Sep 02 20:18:06 PDT 2018</span><br><span class="line">mZxid &#x3D; 0xcc</span><br><span class="line">mtime &#x3D; Sun Sep 02 20:18:06 PDT 2018</span><br><span class="line">pZxid &#x3D; 0xcc</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x0</span><br><span class="line">dataLength &#x3D; 25</span><br><span class="line">numChildren &#x3D; 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 86]</span><br></pre></td></tr></table></figure>

<h2 id="5-controllers-的结构"><a href="#5-controllers-的结构" class="headerlink" title="5.controllers 的结构"></a>5.controllers 的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 92] ls &#x2F;controller</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 93] get &#x2F;controller</span><br><span class="line">&#123;&quot;version&quot;:1,&quot;brokerid&quot;:0,&quot;timestamp&quot;:&quot;1535943857541&quot;&#125; &#x2F;&#x2F;表示broker0为kafka的控制节点</span><br><span class="line">cZxid &#x3D; 0x15</span><br><span class="line">ctime &#x3D; Sun Sep 02 20:04:17 PDT 2018</span><br><span class="line">mZxid &#x3D; 0x15</span><br><span class="line">mtime &#x3D; Sun Sep 02 20:04:17 PDT 2018</span><br><span class="line">pZxid &#x3D; 0x15</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x1659d6268f60000</span><br><span class="line">dataLength &#x3D; 54</span><br><span class="line">numChildren &#x3D; 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 94]</span><br><span class="line">## 6.brokers的结构</span><br><span class="line">[zk: localhost:2181(CONNECTED) 95] ls &#x2F;brokers</span><br><span class="line">[seqid, topics, ids]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 96] ls &#x2F;brokers&#x2F;ids</span><br><span class="line">[0]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 97] get &#x2F;brokers&#x2F;ids&#x2F;0</span><br><span class="line">&#123;&quot;listener_security_protocol_map&quot;:&#123;&quot;PLAINTEXT&quot;:&quot;PLAINTEXT&quot;&#125;,&quot;endpoints&quot;:[&quot;PLAINTEXT:&#x2F;&#x2F;localhost:9092&quot;],&quot;jmx_port&quot;:-1,&quot;host&quot;:&quot;localhost&quot;,&quot;timestamp&quot;:&quot;1535943859255&quot;,&quot;port&quot;:9092,&quot;version&quot;:4&#125;</span><br><span class="line">cZxid &#x3D; 0x1c</span><br><span class="line">ctime &#x3D; Sun Sep 02 20:04:19 PDT 2018</span><br><span class="line">mZxid &#x3D; 0x1c</span><br><span class="line">mtime &#x3D; Sun Sep 02 20:04:19 PDT 2018</span><br><span class="line">pZxid &#x3D; 0x1c</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x1659d6268f60000</span><br><span class="line">dataLength &#x3D; 188</span><br><span class="line">numChildren &#x3D; 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 98]</span><br><span class="line"></span><br><span class="line">------------------------------brokers&#x2F;topics----------------------</span><br><span class="line">[zk: localhost:2181(CONNECTED) 100] ls &#x2F;brokers&#x2F;topics</span><br><span class="line">[__consumer_offsets, test, test2]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 101] ls &#x2F;brokers&#x2F;topics&#x2F;test</span><br><span class="line"></span><br><span class="line">test    test2</span><br><span class="line">[zk: localhost:2181(CONNECTED) 101] ls &#x2F;brokers&#x2F;topics&#x2F;test2</span><br><span class="line">[partitions]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 102] ls &#x2F;brokers&#x2F;topics&#x2F;test2&#x2F;partitions</span><br><span class="line">[2, 1, 0]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 103] ls &#x2F;brokers&#x2F;topics&#x2F;test2&#x2F;partitions&#x2F;2</span><br><span class="line">[state]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 104] ls &#x2F;brokers&#x2F;topics&#x2F;test2&#x2F;partitions&#x2F;2&#x2F;state</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 105] get &#x2F;brokers&#x2F;topics&#x2F;test2&#x2F;partitions&#x2F;2&#x2F;state</span><br><span class="line">&#123;&quot;controller_epoch&quot;:1,&quot;leader&quot;:0,&quot;version&quot;:1,&quot;leader_epoch&quot;:0,&quot;isr&quot;:[0]&#125;</span><br><span class="line">&#x2F;&#x2F;表示partition 0 的leader是在0 broker上</span><br><span class="line">cZxid &#x3D; 0xd2</span><br><span class="line">ctime &#x3D; Sun Sep 02 20:18:06 PDT 2018</span><br><span class="line">mZxid &#x3D; 0xd2</span><br><span class="line">mtime &#x3D; Sun Sep 02 20:18:06 PDT 2018</span><br><span class="line">pZxid &#x3D; 0xd2</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x0</span><br><span class="line">dataLength &#x3D; 72</span><br><span class="line">numChildren &#x3D; 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 106]</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/06/tmux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/06/tmux/" class="post-title-link" itemprop="url">tmux相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-06 16:07:30 / Modified: 11:54:02" itemprop="dateCreated datePublished" datetime="2020-12-06T16:07:30+08:00">2020-12-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>tmux 是 Linux 中窗口管理程序，适用于终端复用，尤其适合远程连接。最近，我正苦闷与 ssh 自动超时退出和 broken pipe，决定投入 tmux 怀抱。<br>使用 tmux 最直接的好处，便是可以在一个远程连接中开启多个控制台，而不用浪费额外的终端来连接远程主机。更不用说 tmux 方便的 attach/detach,随时保存工作状态，还有方便的复制粘贴功能。</p>
<p>基本使用<br>tmux 的主要元素分为三层：</p>
<p>Session: 一组窗口的集合，通常用来概括同一个任务。session 可以有自己的名字便于任务之间的切换。<br>Window: 单个可见窗口。Windows 有自己的编号，也可以认为和 ITerm2 中的 Tab 类似。<br>Pane: 窗格，被划分成小块的窗口，类似于 Vim 中 C-w +v 后的效果。</p>
<p>在安装好 tmux 后，直接在终端中输入 tmux 并回车，就进入了一个全新的 tmux 会话，输入 exit 即可退出。<br>可以在一台计算机上创建多个会话，并且通过为每个会话指定一个唯一的名称来管理它们：<br>tmux new-session -s basic<br>此命令可简化为：tmux new -s basic。<br>由于我们的程序是在 tmux 环境里运行的，因此需要一种方式来告诉 tmux 当前所输入的命令是为了让 tmux 去执行而不是 tmux 里的应用程序去执行，这就是命令前缀的作用。tmux 中默认的命令前缀是 CTRL-b 组合键，但 CTRL-b 组合键使用不是很方便，可将其修改为 CTRL-a 组合键。按下命令前缀组合键，松开，再按相应键，即发送 tmux 命令。</p>
<p>tmux 创建会话</p>
<ul>
<li>tmux new-session 创建一个未命名的会话。可以简写为 tmux new 或者就一个简单的 tmux</li>
<li>tmux new -s development 创建一个名为 development 的会话</li>
<li>tmux new -s development -n editor 创建一个名为 development 的会话并把该会话的第一个窗口命名为 editor</li>
<li>tmux attach -t development 连接到一个名为 development 的会话</li>
</ul>
<p>tmux 会话、窗口和面板的默认快捷键</p>
<ul>
<li>PREFIX d 从一个会话中分离，让该会话在后台运行。</li>
<li>PREFIX : 进入命令模式</li>
<li>PREFIX c 在当前 tmux 会话创建一个新的窗口，是 new-window 命令的简写</li>
<li>PREFIX 0…9 根据窗口的编号选择窗口</li>
<li>PREFIX w 显示当前会话中所有窗口的可选择列表</li>
<li>PREFIX , 显示一个提示符来重命名一个窗口</li>
<li>PREFIX &amp; 杀死当前窗口，带有确认提示</li>
<li>PREFIX % 把当前窗口垂直地一分为二，分割后的两个面板各占 50% 大小</li>
<li>PREFIX “ 把当前窗口水平地一分为二，分割后的两个面板各占 50% 大小</li>
<li>PREFIX o 在已打开的面板之间循环移动当前焦点</li>
<li>PREFIX q 短暂地显示每个面板的编号</li>
<li>PREFIX x 关闭当前面板，带有确认提示</li>
<li>PREFIX SPACE 循环地使用 tmux 的几个默认面板布局</li>
</ul>
<p>tmux 复制粘贴</p>
<ul>
<li>PREFIX [ 进入复制模式</li>
<li>PREFIX ] 粘贴<br>进入复制模式后，可以用 vi 风格的快捷键进行移动（按上文的设置）。按下 sapce 就可以选择文本。回车键进行复制。然后再通过]进行粘贴。<br>也可以将复制粘贴设置为类似 vi 的模式，使用 esc 进入复制模式，v 进入粘贴模式，选择后 y 进行复制。Prefix-p 进行粘贴。</li>
</ul>
<h1 id="Copy-and-paste-like-in-vim"><a href="#Copy-and-paste-like-in-vim" class="headerlink" title="Copy and paste like in vim"></a>Copy and paste like in vim</h1><p>unbind [<br>bind Escape copy-mode<br>unbind p<br>bind p paste-buffer<br>bind -t vi-copy ‘v’ begin-selection<br>bind -t vi-copy ‘y’ copy-selection</p>
<p>所有的复制都会被记录到缓冲区，输入#或者 tmux list-buffers 查看缓冲区,同时也进入了复制模式。也可以使用”=”来选择并粘贴缓冲区内容。tmux 的缓冲区和系统剪贴板是完全独立的。</p>
<p>自主配置</p>
<h1 id="把前缀键从-C-b-更改为-C-a"><a href="#把前缀键从-C-b-更改为-C-a" class="headerlink" title="把前缀键从 C-b 更改为 C-a"></a>把前缀键从 C-b 更改为 C-a</h1><p>set -g prefix C-a</p>
<h1 id="释放之前的-Ctrl-b-前缀快捷键"><a href="#释放之前的-Ctrl-b-前缀快捷键" class="headerlink" title="释放之前的 Ctrl-b 前缀快捷键"></a>释放之前的 Ctrl-b 前缀快捷键</h1><p>unbind C-b</p>
<h1 id="设定前缀键和命令键之间的延时"><a href="#设定前缀键和命令键之间的延时" class="headerlink" title="设定前缀键和命令键之间的延时"></a>设定前缀键和命令键之间的延时</h1><p>set -sg escape-time 1</p>
<h1 id="确保可以向其它程序发送-Ctrl-A"><a href="#确保可以向其它程序发送-Ctrl-A" class="headerlink" title="确保可以向其它程序发送 Ctrl-A"></a>确保可以向其它程序发送 Ctrl-A</h1><p>bind C-a send-prefix</p>
<h1 id="把窗口的初始索引值从-0-改为-1"><a href="#把窗口的初始索引值从-0-改为-1" class="headerlink" title="把窗口的初始索引值从 0 改为 1"></a>把窗口的初始索引值从 0 改为 1</h1><p>set -g base-index 1</p>
<h1 id="把面板的初始索引值从-0-改为-1"><a href="#把面板的初始索引值从-0-改为-1" class="headerlink" title="把面板的初始索引值从 0 改为 1"></a>把面板的初始索引值从 0 改为 1</h1><p>setw -g pane-base-index 1</p>
<h1 id="使用-Prefix-r-重新加载配置文件"><a href="#使用-Prefix-r-重新加载配置文件" class="headerlink" title="使用 Prefix r 重新加载配置文件"></a>使用 Prefix r 重新加载配置文件</h1><p>bind r source-file ~/.tmux.conf ; display “Reloaded!”</p>
<h1 id="分割面板"><a href="#分割面板" class="headerlink" title="分割面板"></a>分割面板</h1><p>bind | split-window -h<br>bind - split-window -v</p>
<h1 id="在面板之间移动"><a href="#在面板之间移动" class="headerlink" title="在面板之间移动"></a>在面板之间移动</h1><p>bind h select-pane -L<br>bind j select-pane -D<br>bind k select-pane -U<br>bind l select-pane -R</p>
<h1 id="快速选择面板"><a href="#快速选择面板" class="headerlink" title="快速选择面板"></a>快速选择面板</h1><p>bind -r C-h select-window -t :-<br>bind -r C-l select-window -t :+</p>
<h1 id="调整面板大小"><a href="#调整面板大小" class="headerlink" title="调整面板大小"></a>调整面板大小</h1><p>bind -r H resize-pane -L 5<br>bind -r J resize-pane -D 5<br>bind -r K resize-pane -U 5<br>bind -r L resize-pane -R 5</p>
<h1 id="鼠标支持-如果你想使用的话把-off-改为-on"><a href="#鼠标支持-如果你想使用的话把-off-改为-on" class="headerlink" title="鼠标支持 - 如果你想使用的话把 off 改为 on"></a>鼠标支持 - 如果你想使用的话把 off 改为 on</h1><p>setw -g mode-mouse off<br>set -g mouse-select-pane off<br>set -g mouse-resize-pane off<br>set -g mouse-select-window off</p>
<h1 id="设置默认的终端模式为-256-色模式"><a href="#设置默认的终端模式为-256-色模式" class="headerlink" title="设置默认的终端模式为 256 色模式"></a>设置默认的终端模式为 256 色模式</h1><p>set -g default-terminal “screen-256color”</p>
<h1 id="开启活动通知"><a href="#开启活动通知" class="headerlink" title="开启活动通知"></a>开启活动通知</h1><p>setw -g monitor-activity on<br>set -g visual-activity on</p>
<h1 id="设置状态栏的颜色"><a href="#设置状态栏的颜色" class="headerlink" title="设置状态栏的颜色"></a>设置状态栏的颜色</h1><p>set -g status-fg white<br>set -g status-bg black</p>
<h1 id="设置窗口列表的颜色"><a href="#设置窗口列表的颜色" class="headerlink" title="设置窗口列表的颜色"></a>设置窗口列表的颜色</h1><p>setw -g window-status-fg cyan<br>setw -g window-status-bg default<br>setw -g window-status-attr dim</p>
<h1 id="设置活动窗口的颜色"><a href="#设置活动窗口的颜色" class="headerlink" title="设置活动窗口的颜色"></a>设置活动窗口的颜色</h1><p>setw -g window-status-current-fg white<br>setw -g window-status-current-bg red<br>setw -g window-status-current-attr bright</p>
<h1 id="设置面板和活动面板的颜色"><a href="#设置面板和活动面板的颜色" class="headerlink" title="设置面板和活动面板的颜色"></a>设置面板和活动面板的颜色</h1><p>set -g pane-border-fg green<br>set -g pane-border-bg black<br>set -g pane-active-border-fg white<br>set -g pane-active-border-bg yellow</p>
<h1 id="设置命令行或消息的颜色"><a href="#设置命令行或消息的颜色" class="headerlink" title="设置命令行或消息的颜色"></a>设置命令行或消息的颜色</h1><p>set -g message-fg white<br>set -g message-bg black<br>set -g message-attr bright</p>
<h1 id="设置状态栏左侧的内容和颜色"><a href="#设置状态栏左侧的内容和颜色" class="headerlink" title="设置状态栏左侧的内容和颜色"></a>设置状态栏左侧的内容和颜色</h1><p>set -g status-left-length 40<br>set -g status-left “#[fg=green]Session: #S #[fg=yellow]#I #[fg=cyan]#P”<br>set -g status-utf8 on</p>
<h1 id="设置状态栏右侧的内容和颜色"><a href="#设置状态栏右侧的内容和颜色" class="headerlink" title="设置状态栏右侧的内容和颜色"></a>设置状态栏右侧的内容和颜色</h1><h1 id="15-28-Nov-18-15"><a href="#15-28-Nov-18-15" class="headerlink" title="15% | 28 Nov 18:15"></a>15% | 28 Nov 18:15</h1><p>set -g status-right “#(~/battery Discharging) | #[fg=cyan]%d %b %R”</p>
<h1 id="每-60-秒更新一次状态栏"><a href="#每-60-秒更新一次状态栏" class="headerlink" title="每 60 秒更新一次状态栏"></a>每 60 秒更新一次状态栏</h1><p>set -g status-interval 60</p>
<h1 id="设置窗口列表居中显示"><a href="#设置窗口列表居中显示" class="headerlink" title="设置窗口列表居中显示"></a>设置窗口列表居中显示</h1><p>set -g status-justify centre</p>
<h1 id="开启-vi-按键"><a href="#开启-vi-按键" class="headerlink" title="开启 vi 按键"></a>开启 vi 按键</h1><p>setw -g mode-keys vi</p>
<h1 id="在相同目录下使用-tmux-panes-脚本开启面板"><a href="#在相同目录下使用-tmux-panes-脚本开启面板" class="headerlink" title="在相同目录下使用 tmux-panes 脚本开启面板"></a>在相同目录下使用 tmux-panes 脚本开启面板</h1><p>unbind v<br>unbind n<br>bind v send-keys “ ~/tmux-panes -h” C-m<br>bind n send-keys “ ~/tmux-panes -v” C-m</p>
<h1 id="临时最大化面板或恢复面板大小"><a href="#临时最大化面板或恢复面板大小" class="headerlink" title="临时最大化面板或恢复面板大小"></a>临时最大化面板或恢复面板大小</h1><p>unbind Up<br>bind Up new-window -d -n tmp ; swap-pane -s tmp.1 ; select-window -t tmp<br>unbind Down<br>bind Down last-window ; swap-pane -s tmp.1 ; kill-window -t tmp</p>
<h1 id="把日志输出到指定文件"><a href="#把日志输出到指定文件" class="headerlink" title="把日志输出到指定文件"></a>把日志输出到指定文件</h1><p>bind P pipe-pane -o “cat &gt;&gt;~/#W.log” ; display “Toggled logging to ~/#W.log”</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/06/mockito/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/06/mockito/" class="post-title-link" itemprop="url">Mockito相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-06 16:07:30 / Modified: 11:53:33" itemprop="dateCreated datePublished" datetime="2020-12-06T16:07:30+08:00">2020-12-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-Mockito-介绍"><a href="#1-Mockito-介绍" class="headerlink" title="1 Mockito 介绍"></a>1 Mockito 介绍</h1><h2 id="1-1-Mockito-是什么？"><a href="#1-1-Mockito-是什么？" class="headerlink" title="1.1 Mockito 是什么？"></a>1.1 Mockito 是什么？</h2><p>Mockito 是 mocking 框架，它让你用简洁的 API 做测试。而且 Mockito 简单易学，它可读性强和验证语法简洁。</p>
<h2 id="1-2-为什么需要-Mock"><a href="#1-2-为什么需要-Mock" class="headerlink" title="1.2 为什么需要 Mock"></a>1.2 为什么需要 Mock</h2><p>测试驱动的开发( TDD)要求我们先写单元测试，再写实现代码。在写单元测试的过程中，我们往往会遇到要测试的类有很多依赖，这些依赖的类/对象/资源又有别的依赖，从而形成一个大的依赖树，要在单元测试的环境中完整地构建这样的依赖，是一件很困难的事情。如下图所示：<br><img src="/images/mockito-1.png"><br>为了测试类 A，我们需要 Mock B 类和 C 类（用虚拟对象来代替）如下图所示：<br><img src="/images/mockito-2.png"></p>
<h2 id="1-3-Stub-和-Mock-异同-1"><a href="#1-3-Stub-和-Mock-异同-1" class="headerlink" title="1.3 Stub 和 Mock 异同[1]"></a>1.3 Stub 和 Mock 异同[1]</h2><p>相同：Stub 和 Mock 都是模拟外部依赖<br>不同：Stub 是完全模拟一个外部依赖， 而 Mock 还可以用来判断测试通过还是失败</p>
<h2 id="1-4-Mockito-资源"><a href="#1-4-Mockito-资源" class="headerlink" title="1.4 Mockito 资源"></a>1.4 Mockito 资源</h2><p>官网： <a target="_blank" rel="noopener" href="http://mockito.org/">http://mockito.org</a></p>
<p>API 文档：<a target="_blank" rel="noopener" href="http://docs.mockito.googlecode.com/hg/org/mockito/Mockito.html">http://docs.mockito.googlecode.com/hg/org/mockito/Mockito.html</a></p>
<p>项目源码：<a target="_blank" rel="noopener" href="https://github.com/mockito/mockito">https://github.com/mockito/mockito</a></p>
<h2 id="1-5-使用场景"><a href="#1-5-使用场景" class="headerlink" title="1.5 使用场景"></a>1.5 使用场景</h2><p>提前创建测试; TDD（测试驱动开发）<br>团队可以并行工作<br>你可以创建一个验证或者演示程序<br>为无法访问的资源编写测试<br>Mock 可以交给用户<br>隔离系统</p>
<h1 id="2-使用-Mockito"><a href="#2-使用-Mockito" class="headerlink" title="2 使用 Mockito"></a>2 使用 Mockito</h1><p>添加 maven 依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mockito&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mockito-all&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.9.5&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>添加 junit 依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.11&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>添加引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import static org.mockito.Mockito._;</span><br><span class="line">import static org.junit.Assert._;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-验证行为"><a href="#2-1-验证行为" class="headerlink" title="2.1 验证行为"></a>2.1 验证行为</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void verify_behaviour()&#123;</span><br><span class="line">&#x2F;&#x2F;模拟创建一个 List 对象</span><br><span class="line">List mock &#x3D; mock(List.class);</span><br><span class="line">&#x2F;&#x2F;使用 mock 的对象</span><br><span class="line">mock.add(1);</span><br><span class="line">mock.clear();</span><br><span class="line">&#x2F;&#x2F;验证 add(1)和 clear()行为是否发生</span><br><span class="line">verify(mock).add(1);</span><br><span class="line">verify(mock).clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-模拟我们所期望的结果"><a href="#2-2-模拟我们所期望的结果" class="headerlink" title="2.2 模拟我们所期望的结果"></a>2.2 模拟我们所期望的结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void when_thenReturn()&#123;</span><br><span class="line">&#x2F;&#x2F;mock 一个 Iterator 类</span><br><span class="line">Iterator iterator &#x3D; mock(Iterator.class);</span><br><span class="line">&#x2F;&#x2F;预设当 iterator 调用 next()时第一次返回 hello，第 n 次都返回 world</span><br><span class="line">when(iterator.next()).thenReturn(&quot;hello&quot;).thenReturn(&quot;world&quot;);</span><br><span class="line">&#x2F;&#x2F;使用 mock 的对象</span><br><span class="line">String result &#x3D; iterator.next() + &quot; &quot; + iterator.next() + &quot; &quot; + iterator.next();</span><br><span class="line">&#x2F;&#x2F;验证结果</span><br><span class="line">assertEquals(&quot;hello world world&quot;,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test(expected &#x3D; IOException.class)</span><br><span class="line">public void when_thenThrow() throws IOException &#123;</span><br><span class="line">OutputStream outputStream &#x3D; mock(OutputStream.class);</span><br><span class="line">OutputStreamWriter writer &#x3D; new OutputStreamWriter(outputStream);</span><br><span class="line">&#x2F;&#x2F;预设当流关闭时抛出异常</span><br><span class="line">doThrow(new IOException()).when(outputStream).close();</span><br><span class="line">outputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-RETURNS-SMART-NULLS-和-RETURNS-DEEP-STUBS"><a href="#2-3-RETURNS-SMART-NULLS-和-RETURNS-DEEP-STUBS" class="headerlink" title="2.3 RETURNS_SMART_NULLS 和 RETURNS_DEEP_STUBS"></a>2.3 RETURNS_SMART_NULLS 和 RETURNS_DEEP_STUBS</h2><p>RETURNS_SMART_NULLS 实现了 Answer 接口的对象，它是创建 mock 对象时的一个可选参数，mock(Class,Answer)。</p>
<p>在创建 mock 对象时，有的方法我们没有进行 stubbing，所以调用时会放回 Null 这样在进行操作是很可能抛出 NullPointerException。如果通过 RETURNS_SMART_NULLS 参数创建的 mock 对象在没有调用 stubbed 方法时会返回 SmartNull。例如：返回类型是 String，会返回””;是 int，会返回 0；是 List，会返回空的 List。另外，在控制台窗口中可以看到 SmartNull 的友好提示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void returnsSmartNullsTest() &#123;</span><br><span class="line">List mock &#x3D; mock(List.class, RETURNS_SMART_NULLS);</span><br><span class="line">System.out.println(mock.get(0));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用 RETURNS_SMART_NULLS 参数创建的 mock 对象，不会抛出 NullPointerException 异常。另外控制台窗口会提示信息“SmartNull returned by unstubbed get() method on mock”</span><br><span class="line">System.out.println(mock.toArray().length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RETURNS_DEEP_STUBS 也是创建 mock 对象时的备选参数</p>
<p>RETURNS_DEEP_STUBS 参数程序会自动进行 mock 所需的对象，方法 deepstubsTest 和 deepstubsTest2 是等价的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void deepstubsTest()&#123;</span><br><span class="line">Account account&#x3D;mock(Account.class,RETURNS_DEEP_STUBS);</span><br><span class="line">when(account.getRailwayTicket().getDestination()).thenReturn(&quot;Beijing&quot;);</span><br><span class="line">account.getRailwayTicket().getDestination();</span><br><span class="line">verify(account.getRailwayTicket()).getDestination();</span><br><span class="line">assertEquals(&quot;Beijing&quot;,account.getRailwayTicket().getDestination());</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void deepstubsTest2()&#123;</span><br><span class="line">Account account&#x3D;mock(Account.class);</span><br><span class="line">RailwayTicket railwayTicket&#x3D;mock(RailwayTicket.class);</span><br><span class="line"> when(account.getRailwayTicket()).thenReturn(railwayTicket);</span><br><span class="line">when(railwayTicket.getDestination()).thenReturn(&quot;Beijing&quot;);</span><br><span class="line"></span><br><span class="line">account.getRailwayTicket().getDestination();</span><br><span class="line">verify(account.getRailwayTicket()).getDestination();</span><br><span class="line"> assertEquals(&quot;Beijing&quot;,account.getRailwayTicket().getDestination());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RailwayTicket&#123;</span><br><span class="line">private String destination;</span><br><span class="line"></span><br><span class="line">        public String getDestination() &#123;</span><br><span class="line">            return destination;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setDestination(String destination) &#123;</span><br><span class="line">            this.destination &#x3D; destination;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class Account&#123;</span><br><span class="line">        private RailwayTicket railwayTicket;</span><br><span class="line"></span><br><span class="line">        public RailwayTicket getRailwayTicket() &#123;</span><br><span class="line">            return railwayTicket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setRailwayTicket(RailwayTicket railwayTicket) &#123;</span><br><span class="line">            this.railwayTicket &#x3D; railwayTicket;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-4-模拟方法体抛出异常"><a href="#2-4-模拟方法体抛出异常" class="headerlink" title="2.4 模拟方法体抛出异常"></a>2.4 模拟方法体抛出异常</h2><p>@Test(expected = RuntimeException.class)<br>public void doThrow_when(){<br>List list = mock(List.class);<br>doThrow(new RuntimeException()).when(list).add(1);<br>list.add(1);<br>}</p>
<h2 id="2-5-使用注解来快速模拟"><a href="#2-5-使用注解来快速模拟" class="headerlink" title="2.5 使用注解来快速模拟"></a>2.5 使用注解来快速模拟</h2><p>在上面的测试中我们在每个测试方法里都 mock 了一个 List 对象，为了避免重复的 mock，是测试类更具有可读性，我们可以使用下面的注解方式来快速模拟对象：</p>
<pre><code>@Mock
private List mockList;</code></pre>
<p>OK，我们再用注解的 mock 对象试试</p>
<pre><code>@Test
public void shorthand()&#123;
    mockList.add(1);
    verify(mockList).add(1);
&#125;</code></pre>
<p>运行这个测试类你会发现报错了，mock 的对象为 NULL，为此我们必须在基类中添加初始化 mock 的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MockitoExample2 &#123;</span><br><span class="line">@Mock</span><br><span class="line">private List mockList;</span><br><span class="line"></span><br><span class="line">    public MockitoExample2()&#123;</span><br><span class="line">        MockitoAnnotations.initMocks(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void shorthand()&#123;</span><br><span class="line">        mockList.add(1);</span><br><span class="line">        verify(mockList).add(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用 built-in runner：MockitoJUnitRunner</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(MockitoJUnitRunner.class)</span><br><span class="line">public class MockitoExample2 &#123;</span><br><span class="line">@Mock</span><br><span class="line">private List mockList;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void shorthand()&#123;</span><br><span class="line">        mockList.add(1);</span><br><span class="line">        verify(mockList).add(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-参数匹配"><a href="#2-6-参数匹配" class="headerlink" title="2.6 参数匹配"></a>2.6 参数匹配</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void with_arguments()&#123;</span><br><span class="line">Comparable comparable &#x3D; mock(Comparable.class);</span><br><span class="line">&#x2F;&#x2F;预设根据不同的参数返回不同的结果</span><br><span class="line">when(comparable.compareTo(&quot;Test&quot;)).thenReturn(1);</span><br><span class="line">when(comparable.compareTo(&quot;Omg&quot;)).thenReturn(2);</span><br><span class="line">assertEquals(1, comparable.compareTo(&quot;Test&quot;));</span><br><span class="line">assertEquals(2, comparable.compareTo(&quot;Omg&quot;));</span><br><span class="line">&#x2F;&#x2F;对于没有预设的情况会返回默认值</span><br><span class="line">assertEquals(0, comparable.compareTo(&quot;Not stub&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了匹配制定参数外，还可以匹配自己想要的任意参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void with_unspecified_arguments()&#123;</span><br><span class="line">List list &#x3D; mock(List.class);</span><br><span class="line">&#x2F;&#x2F;匹配任意参数</span><br><span class="line">when(list.get(anyInt())).thenReturn(1);</span><br><span class="line">when(list.contains(argThat(new IsValid()))).thenReturn(true);</span><br><span class="line">assertEquals(1, list.get(1));</span><br><span class="line">assertEquals(1, list.get(999));</span><br><span class="line">assertTrue(list.contains(1));</span><br><span class="line">assertTrue(!list.contains(3));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    private class IsValid extends ArgumentMatcher&lt;List&gt;&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean matches(Object o) &#123;</span><br><span class="line">            return o &#x3D;&#x3D; 1 || o &#x3D;&#x3D; 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：如果你使用了参数匹配，那么所有的参数都必须通过 matchers 来匹配，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void all_arguments_provided_by_matchers()&#123;</span><br><span class="line">Comparator comparator &#x3D; mock(Comparator.class);</span><br><span class="line">comparator.compare(&quot;nihao&quot;,&quot;hello&quot;);</span><br><span class="line">&#x2F;&#x2F;如果你使用了参数匹配，那么所有的参数都必须通过 matchers 来匹配</span><br><span class="line">verify(comparator).compare(anyString(),eq(&quot;hello&quot;));</span><br><span class="line">&#x2F;&#x2F;下面的为无效的参数匹配使用</span><br><span class="line">&#x2F;&#x2F;verify(comparator).compare(anyString(),&quot;hello&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7-自定义参数匹配"><a href="#2-7-自定义参数匹配" class="headerlink" title="2.7 自定义参数匹配"></a>2.7 自定义参数匹配</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void argumentMatchersTest()&#123;</span><br><span class="line">&#x2F;&#x2F;创建 mock 对象</span><br><span class="line">List&lt;String&gt; mock &#x3D; mock(List.class);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;argThat(Matches&lt;T&gt; matcher)方法用来应用自定义的规则，可以传入任何实现Matcher接口的实现类。</span><br><span class="line">        when(mock.addAll(argThat(new IsListofTwoElements()))).thenReturn(true);</span><br><span class="line"></span><br><span class="line">        mock.addAll(Arrays.asList(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;));</span><br><span class="line">        &#x2F;&#x2F;IsListofTwoElements用来匹配size为2的List，因为例子传入List为三个元素，所以此时将失败。</span><br><span class="line">        verify(mock).addAll(argThat(new IsListofTwoElements()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class IsListofTwoElements extends ArgumentMatcher&lt;List&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        public boolean matches(Object list)</span><br><span class="line">        &#123;</span><br><span class="line">            return((List)list).size()&#x3D;&#x3D;2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-8-捕获参数来进一步断言"><a href="#2-8-捕获参数来进一步断言" class="headerlink" title="2.8 捕获参数来进一步断言"></a>2.8 捕获参数来进一步断言</h2><p>较复杂的参数匹配器会降低代码的可读性，有些地方使用参数捕获器更加合适。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void capturing_args()&#123;</span><br><span class="line">PersonDao personDao &#x3D; mock(PersonDao.class);</span><br><span class="line">PersonService personService &#x3D; new PersonService(personDao);</span><br><span class="line"></span><br><span class="line">        ArgumentCaptor&lt;Person&gt; argument &#x3D; ArgumentCaptor.forClass(Person.class);</span><br><span class="line">        personService.update(1,&quot;jack&quot;);</span><br><span class="line">        verify(personDao).update(argument.capture());</span><br><span class="line">        assertEquals(1,argument.getValue().getId());</span><br><span class="line">        assertEquals(&quot;jack&quot;,argument.getValue().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     class Person&#123;</span><br><span class="line">        private int id;</span><br><span class="line">        private String name;</span><br><span class="line"></span><br><span class="line">        Person(int id, String name) &#123;</span><br><span class="line">            this.id &#x3D; id;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getId() &#123;</span><br><span class="line">            return id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface PersonDao&#123;</span><br><span class="line">        public void update(Person person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class PersonService&#123;</span><br><span class="line">        private PersonDao personDao;</span><br><span class="line"></span><br><span class="line">        PersonService(PersonDao personDao) &#123;</span><br><span class="line">            this.personDao &#x3D; personDao;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void update(int id,String name)&#123;</span><br><span class="line">            personDao.update(new Person(id,name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-9-使用方法预期回调接口生成期望值（Answer-结构）"><a href="#2-9-使用方法预期回调接口生成期望值（Answer-结构）" class="headerlink" title="2.9 使用方法预期回调接口生成期望值（Answer 结构）"></a>2.9 使用方法预期回调接口生成期望值（Answer 结构）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void answerTest()&#123;</span><br><span class="line">when(mockList.get(anyInt())).thenAnswer(new CustomAnswer());</span><br><span class="line">assertEquals(&quot;hello world:0&quot;,mockList.get(0));</span><br><span class="line">assertEquals(&quot;hello world:999&quot;,mockList.get(999));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    private class CustomAnswer implements Answer&lt;String&gt;&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String answer(InvocationOnMock invocation) throws Throwable &#123;</span><br><span class="line">            Object[] args &#x3D; invocation.getArguments();</span><br><span class="line">            return &quot;hello world:&quot;+args[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也可使用匿名内部类实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void answer_with_callback()&#123;</span><br><span class="line">&#x2F;&#x2F;使用 Answer 来生成我们我们期望的返回</span><br><span class="line">when(mockList.get(anyInt())).thenAnswer(new Answer&lt;Object&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Object answer(InvocationOnMock invocation) throws Throwable &#123;</span><br><span class="line">Object[] args &#x3D; invocation.getArguments();</span><br><span class="line">return &quot;hello world:&quot;+args[0];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">assertEquals(&quot;hello world:0&quot;,mockList.get(0));</span><br><span class="line">assertEquals(&quot;hello world:999&quot;,mockList.get(999));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-10-修改对未预设的调用返回默认期望"><a href="#2-10-修改对未预设的调用返回默认期望" class="headerlink" title="2.10 修改对未预设的调用返回默认期望"></a>2.10 修改对未预设的调用返回默认期望</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void unstubbed_invocations()&#123;</span><br><span class="line">&#x2F;&#x2F;mock 对象使用 Answer 来对未预设的调用返回默认期望值</span><br><span class="line">List mock &#x3D; mock(List.class,new Answer() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Object answer(InvocationOnMock invocation) throws Throwable &#123;</span><br><span class="line">return 999;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;下面的 get(1)没有预设，通常情况下会返回 NULL，但是使用了 Answer 改变了默认期望值</span><br><span class="line">assertEquals(999, mock.get(1));</span><br><span class="line">&#x2F;&#x2F;下面的 size()没有预设，通常情况下会返回 0，但是使用了 Answer 改变了默认期望值</span><br><span class="line">assertEquals(999,mock.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-11-用-spy-监控真实对象"><a href="#2-11-用-spy-监控真实对象" class="headerlink" title="2.11 用 spy 监控真实对象"></a>2.11 用 spy 监控真实对象</h2><p>Mock 不是真实的对象，它只是用类型的 class 创建了一个虚拟对象，并可以设置对象行为<br>Spy 是一个真实的对象，但它可以设置对象行为<br>InjectMocks 创建这个类的对象并自动将标记@Mock、@Spy 等注解的属性值注入到这个中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Test(expected &#x3D; IndexOutOfBoundsException.class)</span><br><span class="line">public void spy_on_real_objects()&#123;</span><br><span class="line">List list &#x3D; new LinkedList();</span><br><span class="line">List spy &#x3D; spy(list);</span><br><span class="line">&#x2F;&#x2F;下面预设的 spy.get(0)会报错，因为会调用真实对象的 get(0)，所以会抛出越界异常</span><br><span class="line">&#x2F;&#x2F;when(spy.get(0)).thenReturn(3);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;使用doReturn-when可以避免when-thenReturn调用真实对象api</span><br><span class="line">        doReturn(999).when(spy).get(999);</span><br><span class="line">        &#x2F;&#x2F;预设size()期望值</span><br><span class="line">        when(spy.size()).thenReturn(100);</span><br><span class="line">        &#x2F;&#x2F;调用真实对象的api</span><br><span class="line">        spy.add(1);</span><br><span class="line">        spy.add(2);</span><br><span class="line">        assertEquals(100,spy.size());</span><br><span class="line">        assertEquals(1,spy.get(0));</span><br><span class="line">        assertEquals(2,spy.get(1));</span><br><span class="line">        verify(spy).add(1);</span><br><span class="line">        verify(spy).add(2);</span><br><span class="line">        assertEquals(999,spy.get(999));</span><br><span class="line">        spy.get(2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-12-真实的部分-mock"><a href="#2-12-真实的部分-mock" class="headerlink" title="2.12 真实的部分 mock"></a>2.12 真实的部分 mock</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void real_partial_mock()&#123;</span><br><span class="line">&#x2F;&#x2F;通过 spy 来调用真实的 api</span><br><span class="line">List list &#x3D; spy(new ArrayList());</span><br><span class="line">assertEquals(0,list.size());</span><br><span class="line">A a &#x3D; mock(A.class);</span><br><span class="line">&#x2F;&#x2F;通过 thenCallRealMethod 来调用真实的 api</span><br><span class="line">when(a.doSomething(anyInt())).thenCallRealMethod();</span><br><span class="line">assertEquals(999,a.doSomething(999));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    class A&#123;</span><br><span class="line">        public int doSomething(int i)&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-13-重置-mock"><a href="#2-13-重置-mock" class="headerlink" title="2.13 重置 mock"></a>2.13 重置 mock</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void reset_mock()&#123;</span><br><span class="line">List list &#x3D; mock(List.class);</span><br><span class="line">when(list.size()).thenReturn(10);</span><br><span class="line">list.add(1);</span><br><span class="line">assertEquals(10,list.size());</span><br><span class="line">&#x2F;&#x2F;重置 mock，清除所有的互动和预设</span><br><span class="line">reset(list);</span><br><span class="line">assertEquals(0,list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-14-验证确切的调用次数"><a href="#2-14-验证确切的调用次数" class="headerlink" title="2.14 验证确切的调用次数"></a>2.14 验证确切的调用次数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void verifying_number_of_invocations()&#123;</span><br><span class="line">List list &#x3D; mock(List.class);</span><br><span class="line">list.add(1);</span><br><span class="line">list.add(2);</span><br><span class="line">list.add(2);</span><br><span class="line">list.add(3);</span><br><span class="line">list.add(3);</span><br><span class="line">list.add(3);</span><br><span class="line">&#x2F;&#x2F;验证是否被调用一次，等效于下面的 times(1)</span><br><span class="line">verify(list).add(1);</span><br><span class="line">verify(list,times(1)).add(1);</span><br><span class="line">&#x2F;&#x2F;验证是否被调用 2 次</span><br><span class="line">verify(list,times(2)).add(2);</span><br><span class="line">&#x2F;&#x2F;验证是否被调用 3 次</span><br><span class="line">verify(list,times(3)).add(3);</span><br><span class="line">&#x2F;&#x2F;验证是否从未被调用过</span><br><span class="line">verify(list,never()).add(4);</span><br><span class="line">&#x2F;&#x2F;验证至少调用一次</span><br><span class="line">verify(list,atLeastOnce()).add(1);</span><br><span class="line">&#x2F;&#x2F;验证至少调用 2 次</span><br><span class="line">verify(list,atLeast(2)).add(2);</span><br><span class="line">&#x2F;&#x2F;验证至多调用 3 次</span><br><span class="line">verify(list,atMost(3)).add(3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-15-连续调用"><a href="#2-15-连续调用" class="headerlink" title="2.15 连续调用"></a>2.15 连续调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test(expected &#x3D; RuntimeException.class)</span><br><span class="line">public void consecutive_calls()&#123;</span><br><span class="line">&#x2F;&#x2F;模拟连续调用返回期望值，如果分开，则只有最后一个有效</span><br><span class="line">when(mockList.get(0)).thenReturn(0);</span><br><span class="line">when(mockList.get(0)).thenReturn(1);</span><br><span class="line">when(mockList.get(0)).thenReturn(2);</span><br><span class="line">when(mockList.get(1)).thenReturn(0).thenReturn(1).thenThrow(new RuntimeException());</span><br><span class="line">assertEquals(2,mockList.get(0));</span><br><span class="line">assertEquals(2,mockList.get(0));</span><br><span class="line">assertEquals(0,mockList.get(1));</span><br><span class="line">assertEquals(1,mockList.get(1));</span><br><span class="line">&#x2F;&#x2F;第三次或更多调用都会抛出异常</span><br><span class="line">mockList.get(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-16-验证执行顺序"><a href="#2-16-验证执行顺序" class="headerlink" title="2.16 验证执行顺序"></a>2.16 验证执行顺序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void verification_in_order()&#123;</span><br><span class="line">List list &#x3D; mock(List.class);</span><br><span class="line">List list2 &#x3D; mock(List.class);</span><br><span class="line">list.add(1);</span><br><span class="line">list2.add(&quot;hello&quot;);</span><br><span class="line">list.add(2);</span><br><span class="line">list2.add(&quot;world&quot;);</span><br><span class="line">&#x2F;&#x2F;将需要排序的 mock 对象放入 InOrder</span><br><span class="line">InOrder inOrder &#x3D; inOrder(list,list2);</span><br><span class="line">&#x2F;&#x2F;下面的代码不能颠倒顺序，验证执行顺序</span><br><span class="line">inOrder.verify(list).add(1);</span><br><span class="line">inOrder.verify(list2).add(&quot;hello&quot;);</span><br><span class="line">inOrder.verify(list).add(2);</span><br><span class="line">inOrder.verify(list2).add(&quot;world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-17-确保模拟对象上无互动发生"><a href="#2-17-确保模拟对象上无互动发生" class="headerlink" title="2.17 确保模拟对象上无互动发生"></a>2.17 确保模拟对象上无互动发生</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void verify_interaction()&#123;</span><br><span class="line">List list &#x3D; mock(List.class);</span><br><span class="line">List list2 &#x3D; mock(List.class);</span><br><span class="line">List list3 &#x3D; mock(List.class);</span><br><span class="line">list.add(1);</span><br><span class="line">verify(list).add(1);</span><br><span class="line">verify(list,never()).add(2);</span><br><span class="line">&#x2F;&#x2F;验证零互动行为</span><br><span class="line">verifyZeroInteractions(list2,list3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-18-找出冗余的互动-即未被验证到的"><a href="#2-18-找出冗余的互动-即未被验证到的" class="headerlink" title="2.18 找出冗余的互动(即未被验证到的)"></a>2.18 找出冗余的互动(即未被验证到的)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test(expected &#x3D; NoInteractionsWanted.class)</span><br><span class="line">public void find_redundant_interaction()&#123;</span><br><span class="line">List list &#x3D; mock(List.class);</span><br><span class="line">list.add(1);</span><br><span class="line">list.add(2);</span><br><span class="line">verify(list,times(2)).add(anyInt());</span><br><span class="line">&#x2F;&#x2F;检查是否有未被验证的互动行为，因为 add(1)和 add(2)都会被上面的 anyInt()验证到，所以下面的代码会通过</span><br><span class="line">verifyNoMoreInteractions(list);</span><br><span class="line"></span><br><span class="line">        List list2 &#x3D; mock(List.class);</span><br><span class="line">        list2.add(1);</span><br><span class="line">        list2.add(2);</span><br><span class="line">        verify(list2).add(1);</span><br><span class="line">        &#x2F;&#x2F;检查是否有未被验证的互动行为，因为add(2)没有被验证，所以下面的代码会失败抛出异常</span><br><span class="line">        verifyNoMoreInteractions(list2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-Mockito-如何实现-Mock"><a href="#3-Mockito-如何实现-Mock" class="headerlink" title="3 Mockito 如何实现 Mock"></a>3 Mockito 如何实现 Mock</h1><p>Mockito 并不是创建一个真实的对象，而是模拟这个对象，他用简单的 when(mock.method(params)).thenRetrun(result)语句设置 mock 对象的行为，如下语句：</p>
<p>// 设置 mock 对象的行为 － 当调用其 get 方法获取第 0 个元素时，返回”first”<br>Mockito.when(mockedList.get(0)).thenReturn(“first”);<br>在 Mock 对象的时候，创建一个 proxy 对象，保存被调用的方法名（get），以及调用时候传递的参数（0），然后在调用 thenReturn 方法时再把“first”保存起来，这样，就有了构建一个 stub 方法所需的所有信息，构建一个 stub。当 get 方法被调用的时候，实际上调用的是之前保存的 proxy 对象的 get 方法，返回之前保存的数据。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/29/Golang%E7%9A%84%E5%8C%85%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/29/Golang%E7%9A%84%E5%8C%85%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">Golang 的包管理机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-11-29 16:07:30 / Modified: 16:30:30" itemprop="dateCreated datePublished" datetime="2020-11-29T16:07:30+08:00">2020-11-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在 Go1.5 之前用 GOPATH 以及 GOROOT 这两个环境变量来管理包的位置，GOROOT 为 Go 的安装目录，以及编译过程中使用到的系统库存放位置，如 fmt。Go1.5 到 Go1.7 开始稳定到 Vendor 方式，即依赖包需要放到 $GOPATH/src/vendor 目录下，这样每个项目都有自己的 vendor 目录，但是如果依赖同样的三方包，很容易造成资源重复，Go vendor 出现了几种主流的管理工具，包括 godep、govendor、golide 等。</p>
<p>在 Go1.11 之前，GOPATH 是开发时的工作目录，其中包含三个子目录：</p>
<p>src 目录：存放 go 项目源码和依赖源码，包括使用 go get 下载的包<br>bin 目录：通过使用 go install 命令将 go build 编译出的二进制可执行文件存放于此<br>pkg 目录：go 源码包编译生成的 lib 文件存储的地方<br>在 Go1.11 之前，import 包时的搜索路径</p>
<p>GOROOT/src: 该目录保存了 Go 标准库代码(首先搜寻导入包的地方)<br>GOPATH/src: 该目录保存了应用自身的各个包代码和第三方依赖的代码<br>./vendor ：vendor 方式第三方依赖包（如果支持 Vendor）<br>在 Unix 和类 Unix 系统上，GOPATH 默认值是 $HOME/go，Go1.11 版本后，开启 GO Modules 后，GOPATH 的作用仅仅为存放依赖的目录了。</p>
<p>在 Go 的 1.11 版本之前，GOPATH 是必需的，且所有的 Go 项目代码都要保存在 GOPATH/src 目录下，也就是如果想引用本地的包，你需要将包放在 $GOPATH/src 目录下才能找得到。Go 的 1.11 版本之后，GO 官方引入了 Go Modules，不仅仅方便的使用我们的依赖，而且还对依赖的版本进行了管理。</p>
<p>在 Go1.11 后通过 go mod vendor 和 -mod=vendor 来实现 Vendor 管理依赖方式。本来在 vgo 项目(Go Modules 前身)是要完全放弃 vendor，但是在社区反馈下还是保留了。总之就是在 Go.1.11 之后需要开启 Go Modules 条件下才能使用 Vendor，具体地感兴趣或还沿用了 Vendor 的朋友可以去了解下，不过建议以后仅使用 Go Modules 包管理方式了。</p>
<h2 id="dep-govendor-机制"><a href="#dep-govendor-机制" class="headerlink" title="dep/govendor 机制"></a>dep/govendor 机制</h2><h4 id="vendor-使用限制"><a href="#vendor-使用限制" class="headerlink" title="vendor 使用限制"></a>vendor 使用限制</h4><p>使用 vendor 来管理包的项目，必须位于$GOPATH/src 下面。</p>
<h4 id="vendor-目录和-json-文件"><a href="#vendor-目录和-json-文件" class="headerlink" title="vendor 目录和 json 文件"></a>vendor 目录和 json 文件</h4><p>该工具将项目依赖的外部包拷贝到项目下的 vendor 目录下，并通过 vendor.json 文件来记录依赖包的版本，方便用户使用相对稳定的依赖。</p>
<h4 id="vendor-机制下，如何搜索包依赖"><a href="#vendor-机制下，如何搜索包依赖" class="headerlink" title="vendor 机制下，如何搜索包依赖"></a>vendor 机制下，如何搜索包依赖</h4><p>那么查找依赖包路径的解决方案如下：</p>
<ul>
<li>当前包下的 vendor 目录。</li>
<li>向上级目录查找，直到找到 src 下的 vendor 目录。</li>
<li>在 GOPATH 下面查找依赖包。</li>
<li>在 GOROOT 目录下查找</li>
</ul>
<h4 id="如果我们已经使用-GOPATH-去存储-packages-了，问什么还需要使用-vendor-目录呢？"><a href="#如果我们已经使用-GOPATH-去存储-packages-了，问什么还需要使用-vendor-目录呢？" class="headerlink" title="如果我们已经使用 GOPATH 去存储 packages 了，问什么还需要使用 vendor 目录呢？"></a>如果我们已经使用 GOPATH 去存储 packages 了，问什么还需要使用 vendor 目录呢？</h4><p>这是一个很实战的问题。假如多个应用使用一个依赖包的不同版本？这个问题不只是 Go 应用，其他语言也会有这个问题。<br>vendor 目录允许不同的代码库拥有它自己的依赖包，并且不同于其他代码库的版本，这就很好的做到了工程的隔离。<br>每个项目都有各自的 vendor，每个 vendor 可以存放不同版本的依赖包。</p>
<h2 id="module-机制"><a href="#module-机制" class="headerlink" title="module 机制"></a>module 机制</h2><p>在 go1.11 版本中，新增了 module 管理模块功能，用来管理依赖包。要知道，在这个之前，想要对 go 语言包进行管理，只能依赖第三方库实现，比如 Vendor,GoVendor,GoDep,Dep,Glide 等等，对于初学者来说，真的是选择困难症。</p>
<h4 id="开启-module-特性"><a href="#开启-module-特性" class="headerlink" title="开启 module 特性"></a>开启 module 特性</h4><p>要开始使用 go module 的特性， 需要先设置 GO111MODULE 环境变量。<br>开启 GO111MODULE。<br>要使用 go module,首先要设置 GO111MODULE=on,这没什么可说的，如果没设置，执行命令的时候会有提示，这个大家应该都了解了</p>
<h4 id="在-GOAPTH-src-中创建项目"><a href="#在-GOAPTH-src-中创建项目" class="headerlink" title="在$GOAPTH/src 中创建项目"></a>在$GOAPTH/src 中创建项目</h4><p>在$GOPATH/src 目录下创建 github.com/cnwyt/mytest 目录，mytest 为项目目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $GOPATH&#x2F;src&#x2F;github.com&#x2F;cnwyt&#x2F;mytest</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ export GO111MODULE&#x3D;on</span><br><span class="line">$ go mod init github.com&#x2F;cnwyt&#x2F;mytest</span><br><span class="line">go: creating new go.mod: module github.com&#x2F;cnwyt&#x2F;mytest</span><br></pre></td></tr></table></figure>

<p>当然这个 go 模块可以创建在任意位置，不强制邀请放在 GOPATH 路径下。</p>
<h4 id="在-GOPATH-src-外也可以创建项目"><a href="#在-GOPATH-src-外也可以创建项目" class="headerlink" title="在$GOPATH/src 外也可以创建项目"></a>在$GOPATH/src 外也可以创建项目</h4><p>在 GOPATH 以外的模块，创建一个 helloworld 目录，用来调用刚刚创建的 mytest 模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir helloworld &amp;&amp; cd helloworld</span><br><span class="line">$ vi main.go</span><br></pre></td></tr></table></figure>

<p>创建一个 main.go 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">&#x2F;&#x2F;import &quot;github.com&#x2F;cnwyt&#x2F;mytest&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;Hello, World!&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;mytest.ShowTest1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>初始化该模块，引入 github.com/cnwyt/mytest 模块，指定版本为 latest:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init helloworld</span><br><span class="line">$ go mod edit -require github.com&#x2F;cnwyt&#x2F;mytest@latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>初始化后，会生成一个 go.mod 文件，类似 npm 里的 package.json 或者 composer 的 composer.json 的一个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module helloworld</span><br><span class="line"></span><br><span class="line">require github.com&#x2F;cnwyt&#x2F;mytest v0.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样直接执行 go test 或者 go run main.go 会报错:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go test</span><br><span class="line">build helloworld: cannot find module for path github.com&#x2F;cnwyt&#x2F;mytest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是为啥呢？ 这是因为我们虽然创建了一个名为 github.com/cnwyt/mytest 模块，在 GOPATH 路径里也有这个模块。但是，GO 模块去 Github 去找这个模块，而不是在 GOPATH 路径里去找，所以找不到。</p>
<p>那该怎么办呢?<br>有两个解决办法：<br>第一个办法，很简单，就是直接将 cnwyt/mytest 模块推送的 GitHub 上。<br>但是，如果我要修改 cnwyt/mytest 里的代码，都得先推送到 GitHub 上，才能生效，实在太麻烦了。<br>那就直接使用第二个办法， 使用 go replace:</p>
<p>直接修改 go.mod，新增一行 replace:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module helloworld</span><br><span class="line"></span><br><span class="line">require github.com&#x2F;cnwyt&#x2F;mytest v0.0.0</span><br><span class="line"></span><br><span class="line">replace github.com&#x2F;cnwyt&#x2F;mytest &#x3D;&gt; &#x2F;Users&#x2F;wangtom&#x2F;goworkspace&#x2F;mytest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意版本号必须填写，可以填 v0.0.0 或者 latest.</p>
<h4 id="调用第三方模块"><a href="#调用第三方模块" class="headerlink" title="调用第三方模块"></a>调用第三方模块</h4><p>比如项目中会用到比较流行的路由模块 gorilla/mux:</p>
<p>直接修改 go.mod，新增一行 require，不指定版本可以直接写 latest 获取最新版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require github.com&#x2F;gorilla&#x2F;mux latest</span><br></pre></td></tr></table></figure>

<p>运行 go build 或 go test 会自动从 GitHub 下载模块，并会修改 go.mod 文件。</p>
<p>比如运行后会把 latest 直接修改成目前最新的版本 v1.6.2 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module helloworld</span><br><span class="line"></span><br><span class="line">require github.com&#x2F;cnwyt&#x2F;mytest v0.0.0</span><br><span class="line">require github.com&#x2F;gorilla&#x2F;mux v1.6.2</span><br><span class="line"></span><br><span class="line">replace github.com&#x2F;cnwyt&#x2F;mytest &#x3D;&gt; &#x2F;Users&#x2F;wangtom&#x2F;goworkspace&#x2F;godict</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到模块 gorilla/mux 代码会下载到 $GOPATH/pkg/mod/ 模块下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ll &#x2F;Users&#x2F;wangtom&#x2F;goworkspace&#x2F;pkg&#x2F;mod&#x2F;github.com&#x2F;gorilla</span><br><span class="line">total 0</span><br><span class="line">dr-xr-xr-x  22 wangtom  staff 704B 12 24 22:14 mux@v1.6.2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="不使用-vendor-和-module-机制时，可以手动下载所有依赖"><a href="#不使用-vendor-和-module-机制时，可以手动下载所有依赖" class="headerlink" title="不使用 vendor 和 module 机制时，可以手动下载所有依赖"></a>不使用 vendor 和 module 机制时，可以手动下载所有依赖</h2><p>在不使用 vendor 和 module 的情况下，可以使用较原始的方式，将代码中依赖的内容全部下载并编译在$GOPATH 路径下。<br>在项目目录下，执行如下命令：<br>go get -d -v ./…</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
