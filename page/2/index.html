<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/page/2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'default'
  };
</script>
<title>Hexo</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/29/git%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/29/git%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">Git相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-11-29 16:07:30 / Modified: 16:30:33" itemprop="dateCreated datePublished" datetime="2020-11-29T16:07:30+08:00">2020-11-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Git-区域的划分与提交回滚"><a href="#Git-区域的划分与提交回滚" class="headerlink" title="Git 区域的划分与提交回滚"></a>Git 区域的划分与提交回滚</h3><p><img src="/images/git-1.png"></p>
<h3 id="区域划分"><a href="#区域划分" class="headerlink" title="区域划分"></a>区域划分</h3><p>分为工作区，本地库(暂存区和分支)，远程库。<br>工作区：分为原文件和已经修改但是未暂存的文件。<br>暂存区：存放已经 git add 添加后的文件,此区位于本地库。<br>分支：存放已经 git commit 提交后的文件，此区位于本地库<br>远程库：存放已经 git push 后的文件。</p>
<ol>
<li><p>修改本地已被跟踪文件，文件进入未暂存区域。</p>
</li>
<li><p>未暂存区域转到暂存区域 git add files</p>
</li>
<li><p>暂存区提交到本地仓库 git commit -m</p>
</li>
<li><p>直接从未暂存区提交到本地仓库<br>git commit -am<br>经测试，对已跟踪的文件可以正确执行，而对于未跟踪文件（即新增文件）则会出错</p>
</li>
<li><p>本地库回退到暂存区<br>git reset –soft hash 值<br>git reset –soft origin/master<br>一般回退到暂存区的文件作排查用，不要直接修改，不然会同时出现在暂存区和未暂存区（其实即使修改了也木有太大关系）</p>
</li>
<li><p>本地库回退到未暂存区<br>git reset –mixed hash 值<br>git reset –mixed origin/master<br>一般回退到未暂存状态就是为了进一步的修改</p>
</li>
<li><p>本地库回退到文件初始状态（即此版本的）<br>git reset –hard hash 值<br>注意这里，通常先执行一次 fetch，保证本地版本是 origin 的最新版本，然后再回退。（最厉害的是，这么操作不会有冲突，直接让文件变成和 origin 保持一致）<br>git fetch origin<br>git reset –hard origin/master<br>特别注意：这么操作会使你对文件的修改全部消失，还原成最初状态。<br>(针对上一条情况衍生讲解)通常在推送到 origin 时，先要 pull，然后再推送，一般是修改提交了的文件和 pull 下来的同一个文件产生冲突（所以建议修改代码前，一定先要 pull）<br>git pull<br>git push origin master</p>
</li>
<li><p>暂存区回退到未暂存区<br>git reset – files<br>git rest<br>撤销所有暂存区的文件</p>
</li>
<li><p>未暂存区回退到文件初始状态<br>git checkout – files</p>
</li>
<li><p>暂存区回退到文件初始状态<br>git checkout head – files</p>
</li>
</ol>
<h3 id="换一个角度看"><a href="#换一个角度看" class="headerlink" title="换一个角度看"></a>换一个角度看</h3><ul>
<li>从工作区一直到远程仓库的过程是：git add files,git commit, git push.</li>
<li>从远程仓库到工作区的过程是:git fetch/git clone/git pull,git reset – files, git checkout – files。<br>files 是指文件名。<br><img src="/images/git-2.png"></li>
</ul>
<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><img src="/images/git-3.png"></p>
<ul>
<li>git reset –soft,重置位置的同时，保留 working Tree 工作目录和 index 暂存区的内容，只让 repository 中的内容和 reset 目标节点(reset 目标节点是指 reset 命令执行后，head 所指向的节点，或者说 commit 记录)保持一致，因此原节点和 reset 节点之间的【差异变更集】会放入 index 暂存区中(Staged files)。所以效果看起来就是工作目录的内容不变，暂存区原有的内容也不变，只是原节点和 Reset 节点之间的所有差异都会放到暂存区中。</li>
<li>git reset –mixed,重置位置的同时，只保留 Working Tree 工作目录的內容，但会将 Index 暂存区 和 Repository 中的內容更改和 reset 目标节点一致，因此原节点和 Reset 节点之间的【差异变更集】会放入 Working Tree 工作目录中。所以效果看起来就是原节点和 Reset 节点之间的所有差异都会放到工作目录中。</li>
<li>git reset –hard,重置位置的同时，直接将 working Tree 工作目录、 index 暂存区及 repository 都重置成目标 Reset 节点的內容,所以效果看起来等同于清空暂存区和工作区。可以使用 **git reset –hard HEAD^ 来回退到上一次 commit 的状态。<br>此命令可以用来回退到任意版本：git reset –hard commitid **</li>
<li>git reset,用来从暂存区撤销上一次 git add 添加的修改内容。可以使用 git reset HEAD filepathname （比如： git reset HEAD readme.md）来放弃指定文件的缓存，放弃所有的缓存可以使用 git reset HEAD . 命令。不影响工作区中的内容。<br>git reset 详细解释可以参看，<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c2ec5f06cf1a">https://www.jianshu.com/p/c2ec5f06cf1a</a></li>
</ul>
<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p><img src="/images/git-4.png"></p>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>这要从 git 的分支说起，git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。git 是如何知道你当前在哪个分支上工作的呢？<br>其实答案也很简单，它保存着一个名为 HEAD 的特别指针。在 git 中，它是一个指向你正在工作中的本地分支的指针，可以将 HEAD 想象为当前分支的别名。<br><img src="/images/git-5.png"></p>
<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>git 的四个工作区<br><img src="/images/git-6.png"></p>
<p>git diff：是查看 workspace（工作区） 与 index（暂存区） 的差别的。<br>git diff –cached：是查看 index（暂存区） 与 local repositorty（本地仓库） 的差别的。<br>git diff HEAD：是查看 workspace 和 local repository 的差别的。（HEAD 指向的是 local repository 中最新提交的版本）</p>
<p>注：git diff 后跟两个参数，如果只写一个参数，表示默认跟 workspace 中的代码作比较。git diff 显示的结果为 第二个参数所指的代码在第一个参数所指代码基础上的修改。如，git diff HEAD 表示 workspace 在 最新 commit 的基础上所做的修改</p>
<h4 id="比较工作区与暂存区"><a href="#比较工作区与暂存区" class="headerlink" title="比较工作区与暂存区"></a>比较工作区与暂存区</h4><p><img src="/images/git-7.png"></p>
<h4 id="比较本地库的当前版本和上一次版本"><a href="#比较本地库的当前版本和上一次版本" class="headerlink" title="比较本地库的当前版本和上一次版本"></a>比较本地库的当前版本和上一次版本</h4><p><img src="/images/git-8.png"></p>
<h3 id="git-pull-时冲突了怎么办"><a href="#git-pull-时冲突了怎么办" class="headerlink" title="git pull 时冲突了怎么办"></a>git pull 时冲突了怎么办</h3><ol>
<li>忽略本地修改，强制拉取远程到本地</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line"></span><br><span class="line">git reset --hard origin&#x2F;dev</span><br><span class="line"></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>未 commit 先 pull，视本地修改量选择 revert 或 stash</p>
<ul>
<li>本地修改量小。<code>-&gt; revert(把自己的代码取消) -&gt; 重新pull -&gt; 在最新代码上修改 -&gt; [pull确认最新] -&gt; commit&amp;push</code></li>
<li>本地修改量大。<code>-&gt; stash save(把自己的代码隐藏存起来) -&gt; 重新pull -&gt; stash pop(把存起来的隐藏的代码取回来 ) -&gt; 代码文件会显示冲突 -&gt; 右键选择resolve conflict -&gt; 打开文件解决冲突 -&gt;commit&amp;push</code><br>git stash 能够将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录。</li>
</ul>
</li>
<li><p>已 commit 未 push，视本地修改量选择 reset 或直接 merge</p>
<ul>
<li>修改量小。<code>-&gt; reset(回退到未修改之前，选hard模式，把自己的更改取消) -&gt; 重新pull -&gt; 在最新代码上修改 -&gt; [pull确认最新] -&gt; commit&amp;push</code></li>
<li>修改量大。<code>-&gt; commit后pull显示冲突 -&gt; 手动merge解决冲突 -&gt; 重新commit -&gt; push</code></li>
</ul>
</li>
</ol>
<h3 id="git-revert-和-reset-的区别"><a href="#git-revert-和-reset-的区别" class="headerlink" title="git revert 和 reset 的区别"></a>git revert 和 reset 的区别</h3><p>git revert 和 git reset 的区别</p>
<ul>
<li>git revert 是用一次新的 commit 来回滚之前的 commit，此次提交之前的 commit 都会被保留；</li>
<li>git reset 是回到某次提交，提交及之前的 commit 都会被保留，但是此 commit id 之后的修改都会被删除</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/22/Java%E7%9A%84SPI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/22/Java%E7%9A%84SPI/" class="post-title-link" itemprop="url">JAVA SPI</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-22 12:01:22" itemprop="dateCreated datePublished" datetime="2020-11-22T12:01:22+08:00">2020-11-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-29 16:08:28" itemprop="dateModified" datetime="2020-11-29T16:08:28+08:00">2020-11-29</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="spi-使用"><a href="#spi-使用" class="headerlink" title="spi 使用"></a>spi 使用</h1><p>首先，通过一张图来看，完成 spi 的实现，需要哪些操作，需要遵循哪些规范？</p>
<h2 id="1-代码编写"><a href="#1-代码编写" class="headerlink" title="1.代码编写"></a>1.代码编写</h2><p>既然是 spi，那么就必须先定义好接口。其次，就是定义好接口的实现类。</p>
<h2 id="2-创建一个文件夹"><a href="#2-创建一个文件夹" class="headerlink" title="2.创建一个文件夹"></a>2.创建一个文件夹</h2><p>在项目的\src\main\resources\下创建\META-INF<br>\services 目录(笔者在网上找了很多文章，很多都没有告知具体这个文件夹放在哪，放在其他位置下无法加载得到)</p>
<h2 id="3-文件夹下增加配置文件"><a href="#3-文件夹下增加配置文件" class="headerlink" title="3.文件夹下增加配置文件"></a>3.文件夹下增加配置文件</h2><p>在上面 META-INF<br>\services 的目录下再增加一个配置文件，这个文件必须以接口的全限定类名保持一致，例如：com.jiaboyan.test.HelloService</p>
<h2 id="4-配置文件增加描述"><a href="#4-配置文件增加描述" class="headerlink" title="4.配置文件增加描述"></a>4.配置文件增加描述</h2><p>上面介绍 spi 时说道，除了代码上的接口实现之外，你还需要把该实现的描述提供给 JDK。那么，此步骤就是在配置文件中撰写接口实现描述。很简单，就是在配置文件中写入具体实现类的全限定类名，如有多个便换行写入。</p>
<h2 id="5-使用-JDK-来载入"><a href="#5-使用-JDK-来载入" class="headerlink" title="5.使用 JDK 来载入"></a>5.使用 JDK 来载入</h2><p>编写 main()方法，输出测试接口。使用 JDK 提供的 ServiceLoader.load()来加载配置文件中的描述信息，完成类加载操作。</p>
<p><img src="/images/spi-1.png"></p>
<p>接口定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface HelloService &#123;</span><br><span class="line"></span><br><span class="line">    void hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class HelloService1Impl implements HelloService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(&quot;hello jiaboyan&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HelloService2Impl implements HelloService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加 JDK 描述，在 META-INF\services 目录下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.jiaboyan.test.impl.HelloService1Impl</span><br><span class="line">com.jiaboyan.test.impl.HelloService2Impl</span><br></pre></td></tr></table></figure>

<p>编写 main()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] agrs) &#123;</span><br><span class="line">        ServiceLoader&lt;HelloService&gt; loaders &#x3D; ServiceLoader.load(HelloService.class);</span><br><span class="line">        for (HelloService helloService : loaders) &#123;</span><br><span class="line">            helloService.hello();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SPI-机制"><a href="#SPI-机制" class="headerlink" title="SPI-机制"></a>SPI-机制</h1><p>SPI 全称为 Service Provider Interface，是 JDK 内置的一种服务提供发现机制。简单来说，它就是一种动态替换发现机制。例如：有个接口想在运行时才发现具体的实现类，那么你只需要在程序运行前添加一个实现即可，并把新加的实现描述给 JDK 即可。此外，在程序的运行过程中，也可以随时对该描述进行修改，完成具体实现的替换。</p>
<p>Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。</p>
<p>这些 SPI 的接口是由 Java 核心库来提供，而 SPI 的实现则是作为 Java 应用所依赖的 jar 包被包含进类路径（CLASSPATH）中。例如：JDBC 的实现 mysql 就是通过 maven 被依赖进来。</p>
<p>那么问题来了，SPI 的接口是 Java 核心库的一部分，是由引导类加载器(Bootstrap Classloader)来加载的。SPI 的实现类是由系统类加载器(System ClassLoader)来加载的。</p>
<p>引导类加载器在加载时是无法找到 SPI 的实现类的，因为双亲委派模型中规定，引导类加载器 BootstrapClassloader 无法委派系统类加载器 AppClassLoader 来加载。这时候，该如何解决此问题？</p>
<p>线程上下文类加载由此诞生，它的出现也破坏了类加载器的双亲委派模型，使得程序可以进行逆向类加载</p>
<h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>通过名字可知，线程上下文类加载，就是当前线程所拥有的类加载器，可通过 Thread.currentThread()获取当前线程。</p>
<p>线程上下文类加载器（Thread Context ClassLoader）可以通过 java.lang.Thread 类的 setContextClassLoader()方法设置，创建线程时候未指定的话，则默认从父线程中继承。</p>
<p>那父线程中也没指定呢？那么会默认为应用程序的类加载器。例如：main 方法的线程上下文类加载器就是 sun.misc.Launcher$AppClassLoader。</p>
<p>前两篇文章中，我们讲解了类加载器的双亲委派模型，该模型的实现是通过类加载器中的 parent 属性(父加载器)来完成的，默认统一交给最上层类加载器去尝试加载。</p>
<p>那，这个线程上下文类加载器又是干啥的？</p>
<p>在介绍线程上下文类加载前，我们先了解下 Java 的 SPI 机制。</p>
<h2 id="线程上下文类加载实现"><a href="#线程上下文类加载实现" class="headerlink" title="线程上下文类加载实现"></a>线程上下文类加载实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class JVMTest6 &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] agrs) throws ClassNotFoundException &#123;</span><br><span class="line">       ClassLoader loader &#x3D; JVMTest6.class.getClassLoader();</span><br><span class="line">       System.out.println(loader); &#x2F;&#x2F;默认是应用类加载器</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;此时获得上下文类加载器：</span><br><span class="line">       ClassLoader loader2 &#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">       System.out.println(loader2);&#x2F;&#x2F;默认也是应用类加载器</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;设置为自定义类加载器：</span><br><span class="line">       Thread.currentThread().setContextClassLoader(</span><br><span class="line">               new ClassLoaderTest(&quot;d:&#x2F;&quot;));</span><br><span class="line">       System.out.println(Thread.currentThread().getContextClassLoader());</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;使用自定义类加载器加载：</span><br><span class="line">       Class c &#x3D; Thread.currentThread().getContextClassLoader().loadClass(&quot;HelloWorld&quot;);</span><br><span class="line">       System.out.println(c.getClassLoader());&#x2F;&#x2F;线程上下文类加载器</span><br><span class="line"></span><br><span class="line">       ClassLoader loader3 &#x3D; String.class.getClassLoader();</span><br><span class="line">       System.out.println(loader3);&#x2F;&#x2F;启动类加载器 &#x3D; null</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@41dee0d7</span><br><span class="line">sun.misc.Launcher$AppClassLoader@41dee0d7</span><br><span class="line">ClassLoaderTest@516a4aef</span><br><span class="line">ClassLoaderTest@516a4aef</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<h2 id="spi-具体实现："><a href="#spi-具体实现：" class="headerlink" title="spi 具体实现："></a>spi 具体实现：</h2><p>在下面代码中，通过 SPI 方式来完成 java.sql.Driver 接口实现类的类加载操作。</p>
<p>java.sql.DriverManager 包中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">    public Void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;通过SPI方式，读取META-INF&#x2F;services下文件中的类名：</span><br><span class="line">        ServiceLoader&lt;Driver&gt; loadedDrivers &#x3D; ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator driversIterator &#x3D; loadedDrivers.iterator();</span><br><span class="line">        try&#123;</span><br><span class="line">            while(driversIterator.hasNext()) &#123;</span><br><span class="line">                driversIterator.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(Throwable t) &#123;&#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>获取到 ServiceLoader 对象后，进行遍历操作，遍历出所有 META-INF/services 文件夹下的实现类名称，之后再进行 Class.forName(“”)类加载操作。类加载操作在 driversIterator.next()中完成。</p>
<p>java.util.ServiceLoader 包中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123;</span><br><span class="line">    &#x2F;&#x2F;获取线程上下文类加载器：</span><br><span class="line">    ClassLoader cl &#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">    &#x2F;&#x2F;生成ServiceLoader对象：</span><br><span class="line">    return ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service,</span><br><span class="line">                                        ClassLoader loader)&#123;</span><br><span class="line">    return new ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) &#123;</span><br><span class="line">    service &#x3D; svc;</span><br><span class="line">    loader &#x3D; cl;</span><br><span class="line">    reload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在获取 ServiceLoader 对象时，获取了此时线程上下文中的类加载器，将此类加载赋值给 ServiceLoader 类中的 loader 成员变量。在后续类加载过程中，都是使用的此类加载来完成。这一步的操作，直接打破了双亲委派模型，实现了逆向类加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    while(driversIterator.hasNext()) &#123;</span><br><span class="line">        driversIterator.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch(Throwable t) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>通过 debug 发现，driversIterator.next()方法内部会调用 Class c = Class.forName(cn, false, loader)方法进行类加载操作。而此时传递的 loader 就是之前获取的线程上下文类加载器，传递的 cn 就是 META-INF/services 文件中的具体实现类。</p>
<p>由于笔者是通过本地的 test 进行测试，所以上文中涉及到的类加载器都是 AppClassLoader 系统类加载器。</p>
<p>作者：贾博岩<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e4262536000d">https://www.jianshu.com/p/e4262536000d</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/28/sharding-core-merge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/28/sharding-core-merge/" class="post-title-link" itemprop="url">sharding-core-merge</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-10-28 12:17:30" itemprop="dateCreated datePublished" datetime="2019-10-28T12:17:30+08:00">2019-10-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-22 14:14:28" itemprop="dateModified" datetime="2020-11-22T14:14:28+08:00">2020-11-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>模块结构<br>sharding-core-merge的主要功能是利用属性<code>DatabaseType databaseType;</code>，<code>SQLRouteResult routeResult;</code>(route产生)，<code>SelectSQLStatementContext selectSQLStatementContext;</code>(preprocess产生)，<code>List&lt;QueryResult&gt; queryResults;</code>(execute模块产生)，产生MergedResult。按功能分类可以分成三个部分：</li>
</ul>
<ol>
<li>org.apache.shardingsphere.core.merge.dal。包含若干DAL操作相关的MergedResult实现类和DALMergeEngine是一个合并引擎。此引擎对外提供merge()功能,负责将DAL操作的相关结果合并，返回包内定义的MergedResult实体类。</li>
<li>org.apache.shardingsphere.core.merge.dql。包含若干DQL操作相关的MergedResult实现类和DQLMergeEngine是一个合并引擎。此引擎对外提供merge()功能,负责将DQL操作的相关结果合并，返回包内定义的MergedResult实体类。</li>
<li>org.apache.shardingsphere.core.merge。包含MergedResult和MergeEngine接口的定义。MergeEngineFactory，负责创建MergeEngine实例。TransparentMergeEngine是一个合并引擎，实现了MergeEngine接口，此方法不对queryResults进行处理，直接返回迭代流式MergeResult。</li>
</ol>
<ul>
<li>模块结构图<br><img src="/images/sharding-core-merge.png"></li>
<li>主要逻辑流程和关键类分析<br>分片执行的主要逻辑是从***MergeEngine实现类开始的。这里以DQLMergeEngine为例子，进行分析。首先判断<code>List&lt;QueryResult&gt; queryResults;</code>是否为1，如果为1则不需要处理，直接创建迭代流式归并MergedResult。否则，判断是否为orderBy或groupby，并创建相关MergedResult。最后，对分页进行处理，也就是在decorate()方法中，根据数据库类型，创建不同MergeResult。<br><img src="/images/sharding-core-merge-flow-graph.png"></li>
<li>设计模式和设计原则</li>
</ul>
<ol>
<li>简单工厂方法<br>MergeEngineFactory.newInstance（）方法，根据SQLStatement类型来创建不同的MergeEngine。具体的MergeEngine类型为：DQLMergeEngine，DALMergeEngine，TransparentMergeEngine。MergeEngineFactory的存在方便了不同类型的MergeEngine创建，调用者不再需要关心如何创建MergeEngine，而只需要把这件事交给MergeEngineFactory就行。</li>
<li>适配器模式<br>LocalMergedResultAdapter类是一个抽象类，它实现了MergedResult接口的部分方法，使得它的子类<code>ShowDatabasesMergedResult</code>和<code>ShowShardingCTLMergedResult</code>无需MergedResult接口的所有方法。当实现类和接口的方法无法完全匹配时，可以考虑使用适配器模式。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/27/sharding-sql-test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/27/sharding-sql-test/" class="post-title-link" itemprop="url">sharding-sql-test</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-10-27 14:58:30" itemprop="dateCreated datePublished" datetime="2019-10-27T14:58:30+08:00">2019-10-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-22 14:14:20" itemprop="dateModified" datetime="2020-11-22T14:14:20+08:00">2020-11-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>模块结构<br>sharding-sql-test的主要功能是对sql测试用例xml文件进行加载，生成测试用例封装在SQLCases对象中，JAXB 实现java对象与xml之间互相转换<br>。包含三个部分：</li>
</ul>
<ol>
<li>org.apache.shardingsphere.test.sql.loader。对外提供了SQL Cases的三种注册中心，里面含有SQLCasesLoader属性来读取配置文件。</li>
<li>org.apache.shardingsphere.test.sql.SQLCase。对应与xml里部分的实体类，包含属性：id,value,databaseTypes和sqlType。</li>
<li>org.apache.shardingsphere.test.sql.SQLCases。对应与xml里部分的实体类，包含属性：databaseTypes和sqlCases。</li>
<li>org.apache.shardingsphere.test.sql.SQLCaseType。定义两种SQL类型，Literal是指值已经写在sql语句中，Placeholder是指sql语句使用?来做parameter的占位符。</li>
</ol>
<ul>
<li><p>模块结构图<br><img src="/images/sharding-sql-test.png"></p>
</li>
<li><p>设计模式和设计原则</p>
</li>
</ul>
<ol>
<li>单例模式<br>EncryptSQLCasesRegistry,ShardingSQLCasesRegistry,ShardingUnsupportedSQLCasesRegistry这三个都采用了单例模式。内部只有一个属性<code>private SQLCasesLoader sqlCasesLoader;</code>用于加载测试用例文件。<br>保证一个类仅有一个实例，并提供一个访问它的全局访问点。避免一个全局使用的类频繁地创建与销毁，此外单个实例还节省了内存资源。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/26/sharding-core-entry/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/26/sharding-core-entry/" class="post-title-link" itemprop="url">sharding-core-entry</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-10-26 19:11:30" itemprop="dateCreated datePublished" datetime="2019-10-26T19:11:30+08:00">2019-10-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-22 14:14:17" itemprop="dateModified" datetime="2020-11-22T14:14:17+08:00">2020-11-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>模块结构<br>sharding-core-entry的主要功能是对sql进行分片得到SQLRouteResult，包含三个类：</li>
</ul>
<ol>
<li>BaseShardingEngine。是抽象类，对外提供SQLRouteResult shard(final String sql, final List<Object> parameters)方法。此方法是模板方法，可以将一些子算法的实现，延迟到实现类中。cloneParameters()和route()的实现就是在子类完成的。</Object></li>
<li>PreparedQueryShardingEngine。它是BaseShardingEngine的实现类，实现了cloneParameters()和route()的实现就是在子类完成的。含有属性<code>PreparedStatementRoutingEngine routingEngine;</code>，它在route()中发挥了作用。</li>
<li>SimpleQueryShardingEngine。它是BaseShardingEngine的实现类，实现了cloneParameters()和route()的实现就是在子类完成的。含有属性<code>StatementRoutingEngine routingEngine;</code>，它在route()中发挥了作用。</li>
</ol>
<ul>
<li><p>模块结构图<br><img src="/images/sharding-core-entry.png"></p>
</li>
<li><p>设计模式和设计原则</p>
</li>
</ul>
<ol>
<li>模板方法<br>BaseShardingEngine类的SQLRouteResult shard(final String sql, final List<Object> parameters)方法使用了模板方法模式，父类BaseShardingEngine定义了整个算法的骨架，让子类去实现具体的细节。route()和cloneParameters()就是留给子类自定义的细节部分，使得子类在不变更整体算法的情况下，就可以重新定义该算法的特定步骤。</Object></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/24/sharding-core-execute/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/24/sharding-core-execute/" class="post-title-link" itemprop="url">sharding-core-execute</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-10-24 19:11:30" itemprop="dateCreated datePublished" datetime="2019-10-24T19:11:30+08:00">2019-10-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-22 14:14:30" itemprop="dateModified" datetime="2020-11-22T14:14:30+08:00">2020-11-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>模块结构<br>sharding-core-execute的主要功能是将路由和改写生成的RoutingUnit对象（RoutingUnit内部含有SQLUnit），产生执行QueryResult。按功能分类可以分成四个部分：</li>
</ul>
<ol>
<li>org.apache.shardingsphere.core.execute.hook。在执行的关键操作过程中，发送事件，用于跟踪和事务。</li>
<li>org.apache.shardingsphere.core.execute.metadata。主要提供了加载获取TableMetaData的功能，主要存储表的元数据信息，如表中的列名，数据类，列是否为主键。</li>
<li>org.apache.shardingsphere.core.execute.sql。主要有两个子包：prepare和execute。prepare的作用是在执行前搜集信息，产生ShardingExecuteGroup的集合。<br>execute的作用是将ShardingExecuteGroup中StatementExecuteUnit发送到数据库进行执行。</li>
<li>org.apache.shardingsphere.core.execute。 包含ShardingExecuteEngine、SharidngExecuteCallback等重要类，是整个执行模块的核心部分。</li>
</ol>
<ul>
<li>模块结构图<br><img src="/images/sharding-core-execute.png"></li>
<li>主要逻辑流程和关键类分析<br>分片执行的主要逻辑是从sharding-jdbc-core的StatementExecutor开始的，真正执行的部分位于sharding-core-execute中，以查询为例，主要逻辑流程图如下。其中，虚线箭头表示从属关系，实线表示执行顺序。<br><img src="/images/sharding-core-execute-flow-graph.jpg"></li>
<li>设计模式和设计原则</li>
</ul>
<ol>
<li>模板方法<br>SQLExecuteCallback类的execute(final Collection statementExecuteUnits, final boolean isTrunkThread, final Map shardingExecuteDataMap)方法使用了模板方法模式，父类SQLExecuteCallback定义了整个算法的骨架，让子类去实现具体的细节。executeSQL(RouteUnit routeUnit, Statement statement, ConnectionMode connectionMode)就是留给子类自定义的细节部分，使得子类在不变更整体算法的情况下，就可以重新定义该算法的特定步骤。</li>
<li>依赖倒转原则<br>SQLExecutePrepareCallback是一个接口类。BatchPreparedStatementExecutor和PreparedStatementExecutor对与这个类有依赖，由于这个类是个接口，所以调用者可以，在使用前根据实际情况，再定义接口中的抽象方法。这种使用方式对于调用者更加灵活，可以依据场景和需求，自定义相关抽象方法。</li>
</ol>
<ul>
<li>Java编程技巧</li>
</ul>
<ol>
<li>com.google.common.collect.Lists<br>SQLExecutePrepareTemplate.getSQLExecuteGroups()方法中使用了Lists，<code>Lists.partition(sqlUnits, desiredPartitionSize);</code>，可以将原本的List切分成多个List。</li>
<li>com.google.common.util.concurrent<br>ShardingExecutorService.ShardingExecutorService(final int executorSize, final String nameFormat)方法中，使用了异步回调线程池。同时，设定了JVM关闭时线程池采用的动作。<br>在多线程编程中异步回调使得原本需要阻塞等待的异步结果，因为回调的存在而不用等待。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">executorService &#x3D; MoreExecutors.listeningDecorator(getExecutorService(executorSize, nameFormat));</span><br><span class="line">MoreExecutors.addDelayedShutdownHook(executorService, 60, TimeUnit.SECONDS);</span><br><span class="line"></span><br></pre></td></tr></table></figure>








</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/22/sharding-core-rewrite/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/22/sharding-core-rewrite/" class="post-title-link" itemprop="url">sharding-core-rewrite</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-10-22 19:11:30" itemprop="dateCreated datePublished" datetime="2019-10-22T19:11:30+08:00">2019-10-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-22 14:14:24" itemprop="dateModified" datetime="2020-11-22T14:14:24+08:00">2020-11-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>模块结构<br>sharding-core-rewrite的主要功能是将路由生成的RoutingUnit对象，进行改写生成SQLUnit。按功能分类可以分成六个部分：</li>
</ul>
<ol>
<li>org.apache.shardingsphere.core.rewrite.SQLRewriteEngine。SQLRewriteEngine类是整个改写功能的入口，通过构造方法和generateSQL()方法，对外提供改写功能，生成SQLUnit。SQLUnit包含两个属性:sql和parameters，作为改写后的结果返回。这两个属性分别依赖org.apache.shardingsphere.core.rewrite.sql和org.apache.shardingsphere.core.rewrite.parameter包。</li>
<li>org.apache.shardingsphere.core.rewrite.sql。主要类是SQLBuilder，它对外提供构建改写SQL的功能。这个模块内部的SQLToken是改写时重要的依赖。</li>
<li>org.apache.shardingsphere.core.rewrite.parameter。包含ParameterBuilder和ParameterRewriter，分别抽象了参数列表构建和参数改写。其中org.apache.shardingsphere.core.rewrite.parameter.rewriter子包的功能较重要的类是：EncryptParameterBuilderFactory和ShardingParameterBuilderFactory。它俩通过build方法来完成对parameterBuilder的相关参数的设置，例如：在StandardParameterBuilder中设置addedIndexAndParameters和replacedIndexAndParameters。</li>
<li>org.apache.shardingsphere.core.rewrite.SQLRewriteDecorator。接口类。定义了decorate()方法，为sqlRewriteEngine的parameterBuilder设置相关的parameter参数。它的实现类为ShardingRewriterDecorator和EncryptRewriterDecorator。</li>
<li>org.apache.shardingsphere.core.rewrite.sharding。ShardingRewriterDecorator为主要功能类。ShardingParameterBuilderFactory.build()方法，为sqlRewriteEngine的parameterBuilder设置相关的parameter参数</li>
<li>org.apache.shardingsphere.core.rewrite.encrypt。EncryptRewriterDecorator为主要功能类。EncryptParameterBuilderFactory.build()方法，为sqlRewriteEngine的parameterBuilder设置相关的parameter参数。</li>
</ol>
<ul>
<li>模块结构图<br><img src="/images/sharding-core-rewrite.jpg"></li>
<li>主要逻辑流程和关键类分析<br>sharding-core-rewrite的主要逻辑是从SQLRewriteEngine.generateSQLgenerateSQL(final RoutingUnit routingUnit, final Map&lt;String, String&gt; logicAndActualTables)开始的，主逻辑流程图如下。其中，虚线箭头表示从属关系，实线表示执行顺序。<br><img src="/images/sharding-core-rewrite-flow-graph.jpg"></li>
<li>设计模式和设计原则</li>
</ul>
<ol>
<li><p>接口分离原则和里式替换原则<br>org.apache.shardingsphere.core.rewrite.sql.token.pojo。这个包对面向对象编程有比较好的实践。首先，定义了SQLToken抽象类，所有实现类都继承它，它将实体类的公共的部分抽象封装了起来。其次，定义了三个接口<br>Alterable、Attachable、Substitutable三个接口，这三个接口从使用角度按照改写、附加、直接替换三个方面进行了划分，实现类根据自身特点来实现其中的接口。最后，调用者在调用时使用抽象类的引用，达到了统一处理的目的，同时可以根据实现类所属的接口进行差异化操作，这点在如下代码中有体现：<br>SQLBuilder的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private String getSQLTokenLiterals(final SQLToken sqlToken, final RoutingUnit routingUnit, final Map&lt;String, String&gt; logicAndActualTables) &#123;</span><br><span class="line">    return sqlToken instanceof Alterable ? ((Alterable) sqlToken).toString(routingUnit, logicAndActualTables) : sqlToken.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对父类的继承，使得调用者代码可以使用统一的类来引用不同的子类对象。<br>接口的实现，使得调用者代码可以对不同接口的实现类对象，进行差异化处理。<br>org.apache.shardingsphere.core.rewrite.sql.token.generator包对接口合理的使用，也达到类似的效果。同样也是优秀的面向对象编程实践。</p>
</li>
<li><p>依赖倒转原则<br>org.apache.shardingsphere.core.rewrite.parameter.builder和org.apache.shardingsphere.core.rewrite.parameter.rewriter体现了依赖倒转原则，ParameterBuilder和ParameterRewriter都是接口类，是对内部多个实现类的良好抽象，调用者只需要声明接口引用，就可以使用多种实现类。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/18/sharding-core-preprocess/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/18/sharding-core-preprocess/" class="post-title-link" itemprop="url">sharding-core-preprocess</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-10-18 19:11:30" itemprop="dateCreated datePublished" datetime="2019-10-18T19:11:30+08:00">2019-10-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-22 14:14:25" itemprop="dateModified" datetime="2020-11-22T14:14:25+08:00">2020-11-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>模块结构<br>sharding-core-preprocess的主要功能是对SQLStatment对象进行预处理生成SQLStatementContext对象，为路由提供必要信息。按功能分类可以分成三个部分：</li>
</ul>
<ol>
<li>org.apache.shardingsphere.core.optimize。SQLStatementContextFactory类，主要作用根据传入的SQLStatement类型创建相应的SQLStatementContext对象。创建SelectSQLStatementContext、InsertSQLStatementContext、CommonSQLStatementContext三种。</li>
<li>org.apache.shardingsphere.core.optimize.statement。包含SQLStatementContext接口和SelectSQLStatementContext、InsertSQLStatementContext、CommonSQLStatementContext三种实现类。存储：TablesContext、SQLStatement和其他类型Context。</li>
<li>org.apache.shardingsphere.core.optimize.segment。内部分insert、select、table三种类型，包含segment对应的context。</li>
</ol>
<ul>
<li>模块结构图<br><img src="/images/sharding-core-preprocessor.jpg"></li>
<li>主要逻辑流程和关键类分析<br>sharding-core-preprocess的主要逻辑是从SQLStatementContextFactory.newInstance()方法开始的，主逻辑流程图如下。其中，虚线箭头表示从属关系，实线表示执行顺序。<br><img src="/images/sharding-core-preprocessor-flow-graph.jpg"></li>
<li>设计模式和设计原则</li>
</ul>
<ol>
<li>简单工厂模式<br>SQLStatementContextFactory.newInstance()方法根据sqlStatement的类型来决定要创建SQLStatmentContext实例。SQLStatementContext是一个接口，它拥有SelectSQLStatementContext、InsertSQLStatementContext、CommonSQLStatementContext这三个实现类。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/15/sharding-core-route/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/15/sharding-core-route/" class="post-title-link" itemprop="url">sharding-core-route</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-10-15 19:11:30" itemprop="dateCreated datePublished" datetime="2019-10-15T19:11:30+08:00">2019-10-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-22 14:14:22" itemprop="dateModified" datetime="2020-11-22T14:14:22+08:00">2020-11-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>模块结构<br>sharding-core-route的主要功能是将解析生成的SQLStatement对象，进行预处理和路由生成SQLRouteResult对象。这里只讲解路由部分，预处理部分单独一片文章讲解。按功能分类可以分成四个部分：</li>
</ul>
<ol>
<li>org.apache.shardingsphere.core.route.hook。hook相关的类，用于跟踪和分析。</li>
<li>org.apache.shardingsphere.core.route.router。包含分片路由和主备路由两个逻辑的实现，分别位于ShardingRouter和ShardingMasterSlaveRouter，生成SQLRouteResult对象</li>
<li>org.apache.shardingsphere.core.route.type。主要包含RoutingEngine的接口和具体类的实现，实现了route()方法，完成了在具体SQLstatementContext、ShardingRule、ShardingCondition中完成分片操作，生成RoutingResult。支持ShardingRouter和ShardingMasterSlaveRouter的方法实现。</li>
<li>org.apache.shardingsphere.core.route。主要的类为：StatementRoutingEngine和PreparedStatementRoutingEngine。这两个类是核心，路由逻辑的入口在它的route()方法中。前者提供 public SQLRouteResult route(final String logicSQL)，后者提供public SQLRouteResult route(final List<Object> parameters)。</Object></li>
</ol>
<ul>
<li>模块结构图<br><img src="/images/sharding-core-route.jpg"></li>
<li>主要逻辑流程和关键类分析<br>sharding-core-route的主要逻辑是从StatementRoutingEngine.route(final String logicSQL)开始的，主逻辑流程图如下。其中，虚线箭头表示从属关系，实线表示执行顺序。<br><img src="/images/sharding-core-route-flow-graph.jpg"><br>上图中的logicSQL的位置和语句对应有偏差，下方图使用EXCEL更准确描述。<br><img src="/images/sharding-core-route-flow-graph-1.png"></li>
<li>设计模式和设计原则</li>
</ul>
<ol>
<li><p>简单工厂模式+依赖倒转原则<br>RoutingEngine抽象出来route()方法，具体的实现类来实现具体的方法，每个实现类实现自己的路由算法。产生的实现类依据RoutingEngineFactory.newInstance(final ShardingRule shardingRule, final ShardingSphereMetaData metaData, final SQLStatementContext sqlStatementContext, final ShardingConditions shardingConditions)方法中的传入参数。具体代码位于ShardingRouter.route(final String logicSQL, final List<Object> parameters, final SQLStatement sqlStatement)方法中。</Object></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RoutingEngine routingEngine &#x3D; RoutingEngineFactory.newInstance(shardingRule, metaData, sqlStatementContext, shardingConditions);</span><br><span class="line">RoutingResult routingResult &#x3D; routingEngine.route();</span><br></pre></td></tr></table></figure></li>
<li><p>简单工厂模式<br>简单工厂模式在模块中若干处有出现，例如：org.apache.shardingsphere.core.route.router.sharding.validator包内和org.apache.shardingsphere.core.route.router.sharding.condition.generator包内。</p>
</li>
<li><p>依赖倒转<br>依赖倒转强调面向接口编程而不是面向实现编程，这样使得模块之间耦合度降低，方便以后扩展。org.apache.shardingsphere.core.route.type包内的RoutingEngine接口和若干实现类。方便以后新增路由引擎和修改路由引擎。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/30/sharding-core-parse/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/09/30/sharding-core-parse/" class="post-title-link" itemprop="url">sharding-core-parse</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-09-30 17:01:22" itemprop="dateCreated datePublished" datetime="2019-09-30T17:01:22+08:00">2019-09-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-22 14:14:27" itemprop="dateModified" datetime="2020-11-22T14:14:27+08:00">2020-11-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>模块结构<br>sharding-core-parse的主要功能是将sql语句执行分片或加密操作生成最后的SQLStatement对象，供后面的模块调用。内部有7个子模块，按功能分类可以分成四个部分：</li>
</ul>
<ol>
<li>sharding-core-parse-common，实现了SQL解析的主要功能。</li>
<li>sharding-core-parse-mysql,sharding-core-parse-oracle,sharding-core-parse-postgresql,sharding-core-parse-sqlserver。这四个模块分别对应四个不同的数据库类型，里面包含该类型数据库特有的一些实现类。</li>
<li>sharding-core-parse-spi，主要定义了两个接口。SQLParser，抽象了antlr4生成的语法解析器的解析方法execute()。SQLParserEntry,抽象了获取antlr4生成的词法解析器和语法解析器的方法。</li>
<li>sharding-core-parse-test，主要包含了对sharding-core-parse模块内部主要功能的测试，使用jaxb技术来定义测试用例和测试结果。</li>
</ol>
<ul>
<li>模块结构图<br><img src="/images/sharding-core-parse.jpg"></li>
<li>主要逻辑流程和关键类分析<br>sharding-core-parse的主要逻辑是从SQLParseEngine.parse()开始的，主逻辑流程图如下。其中，虚线箭头表示从属关系，实线表示执行顺序。<br><img src="/images/sharding-core-parse-flow-graph.jpg"></li>
<li>设计模式和设计原则</li>
</ul>
<ol>
<li>享元模式<br>SQLParseEngineFactory的功能是创建SQLParseEngine。它使用了享元模式，避免大量实例化相同类的开销，通过共享大幅度地减少单个实例的数目。SQLParseEngineFactory的<code>getSQLParseEngine()</code>方法显示了享元模式的主要逻辑，首先判断ENGINES（Map类型）里面是否含有<code>databaseType.getName()</code>相应的元素，如果有则直接返回，否则根据databaseType来创建SQLParseEngine对象，缓存在ENGINES中，并返回此对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static SQLParseEngine getSQLParseEngine(final DatabaseType databaseType) &#123;</span><br><span class="line">    if (ENGINES.containsKey(databaseType.getName())) &#123;</span><br><span class="line">        return ENGINES.get(databaseType.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (ENGINES) &#123;</span><br><span class="line">        if (ENGINES.containsKey(databaseType.getName())) &#123;</span><br><span class="line">            return ENGINES.get(databaseType.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        SQLParseEngine result &#x3D; new SQLParseEngine(databaseType);</span><br><span class="line">        ENGINES.put(databaseType.getName(), result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>依赖倒转原则<br>依赖倒转强调面向接口编程而不是面向实现编程，这样使得模块之间耦合度降低，方便以后扩展。<code>org.apache.shardingsphere.core.parse.core.filler</code>，<code>org.apache.shardingsphere.core.parse.core.extractor</code>，<code>org.apache.shardingsphere.core.parse.sql.segment</code>，<code>org.apache.shardingsphere.core.parse.sql.statement</code>等。这些包的内部结构体现了这一原则。比如SQLStatementFillerEngine类的fill()方法内部调用SQLSegmentFiller接口，SQLSegmentFiller接口的实现类定义在<code>impl</code>包中。<br>依赖倒转还体现在不同的数据库模块的实现。<code>sharding-core-parse-common</code>定义了SQLSegmentExtractor和SQLSegmentFiller接口,<code>sharding-core-parse-spi</code>定义了SQLParser接口和SQLParserEntry接口。，<code>sharding-core-parse-mysql</code>,<code>sharding-core-parse-oracle</code>,<code>sharding-core-parse-postgresql</code>,<code>sharding-core-parse-sqlserver</code>这四个模块会不同程度地实现上面的接口，不同的数据库都有各自特点，需要实现自身独有的实现类。依赖倒转为此提供了便捷，使得不同数据库只关注自身的实现。</li>
<li>工厂模式<br>SQLParserFactory类的<code>newInstance()</code>体现了简单工厂的设计思想。它将对象的创建和使用分离开，对使用者屏蔽了复杂的创建过程。相关代码和注释如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static SQLParser newInstance(final DatabaseType databaseType, final String sql) &#123;</span><br><span class="line">    &#x2F;&#x2F;NewInstanceServiceLoader.newServiceInstances()返回一个装满SQLParserEntry类型对象的List</span><br><span class="line">    &#x2F;&#x2F;for循环遍历这个List</span><br><span class="line">    for (SQLParserEntry each : NewInstanceServiceLoader.newServiceInstances(SQLParserEntry.class)) &#123;</span><br><span class="line">        &#x2F;&#x2F;DatabaseTypes.getActualDatabaseType()根据名字返回对应databaseType，如果each的databaseType能够与传入的参数databaseType匹配则进行下面的计算</span><br><span class="line">        if (DatabaseTypes.getActualDatabaseType(each.getDatabaseType()) &#x3D;&#x3D; databaseType) &#123;</span><br><span class="line">            &#x2F;&#x2F;创建SQLParser对象</span><br><span class="line">            return createSQLParser(sql, each);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new UnsupportedOperationException(String.format(&quot;Cannot support database type &#39;%s&#39;&quot;, databaseType));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
