<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/page/2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'default'
  };
</script>
<title>Hexo</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/29/gRPC%E5%92%8CProtobuf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/29/gRPC%E5%92%8CProtobuf/" class="post-title-link" itemprop="url">gRPC和Protobuf</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-29 21:00:00" itemprop="dateCreated datePublished" datetime="2020-12-29T21:00:00+08:00">2020-12-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-31 14:06:44" itemprop="dateModified" datetime="2020-12-31T14:06:44+08:00">2020-12-31</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="gRPC-是什么？"><a href="#gRPC-是什么？" class="headerlink" title="gRPC 是什么？"></a>gRPC 是什么？</h1><p>参考 <a target="_blank" rel="noopener" href="http://doc.oschina.net/grpc?t=58008">http://doc.oschina.net/grpc?t=58008</a><br>在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。<br><img src="/images/grpc-protobuf/grpc1.png"><br>gRPC 客户端和服务端可以在多种环境中运行和交互 - 从 google 内部的服务器到你自己的笔记本，并且可以用任何 gRPC 支持的语言来编写。所以，你可以很容易地用 Java 创建一个 gRPC 服务端，用 Go、Python、Ruby 来创建客户端。</p>
<h1 id="使用-protocol-buffers"><a href="#使用-protocol-buffers" class="headerlink" title="使用 protocol buffers"></a>使用 protocol buffers</h1><p>gRPC 默认使用 protocol buffers，这是 Google 开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如 JSON）。正如你将在下方例子里所看到的，你用 proto files 创建 gRPC 服务，用 protocol buffers 消息类型来定义方法参数和返回类型。</p>
<h2 id="protobuf-定义服务，JAVA-实现"><a href="#protobuf-定义服务，JAVA-实现" class="headerlink" title="protobuf 定义服务，JAVA 实现"></a>protobuf 定义服务，JAVA 实现</h2><p>protobuf 的详细用法<a target="_blank" rel="noopener" href="https://blog.51cto.com/9291927/2331980">https://blog.51cto.com/9291927/2331980</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option java_package &#x3D; &quot;io.grpc.examples&quot;;</span><br><span class="line"></span><br><span class="line">package helloworld;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The greeter service definition.</span><br><span class="line">service Greeter &#123;</span><br><span class="line">  &#x2F;&#x2F; Sends a greeting</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The request message containing the user&#39;s name.</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The response message containing the greetings</span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  string message &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编译-protobuf-生成服务端接口和客户端存根"><a href="#编译-protobuf-生成服务端接口和客户端存根" class="headerlink" title="编译 protobuf 生成服务端接口和客户端存根"></a>编译 protobuf 生成服务端接口和客户端存根</h3><p>一旦定义好服务，我们可以使用 protocol buffer 编译器 protoc 来生成创建应用所需的特定客户端和服务端的代码 - 你可以生成任意 gRPC 支持的语言的代码，当然 PHP 和 Objective-C 仅支持创建客户端代码。生成的代码同时包括客户端的存根和服务端要实现的抽象接口，均包含 Greeter 所定义的方法。<br>以下类包含所有我们需要创建这个例子所有的代码：</p>
<ul>
<li>HelloRequest.java， HelloResponse.java 和其他文件包含所有 protocol buffer 用来填充、序列化和提取 HelloRequest 和 HelloReply 消息类型的代码。</li>
<li>GreeterGrpc.java， 包含 (还有其他有用的代码)：<br>Greeter 服务端需要实现的接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static interface Greeter &#123;</span><br><span class="line">    public void sayHello(Helloworld.HelloRequest request,</span><br><span class="line">    StreamObserver&lt;HelloReply&gt; responseObserver);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>客户端用来与 Greeter 服务端进行对话的 存根 类。就像你所看到的，异步存根也实现了 Greeter 接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static class GreeterStub extends AbstractStub&lt;GreeterStub&gt;</span><br><span class="line">    implements Greeter &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="写一个服务器"><a href="#写一个服务器" class="headerlink" title="写一个服务器"></a>写一个服务器</h3><p>现在让我们写点代码！首先我们将创建一个服务应用来实现服务</p>
<h4 id="服务实现"><a href="#服务实现" class="headerlink" title="服务实现"></a>服务实现</h4><p>GreeterImpl.java 准确地实现了 Greeter 服务所需要的行为。<br>正如你所见，GreeterImpl 类通过实现 sayHello 方法，实现了从 IDL 生成的 GreeterGrpc.Greeter 接口 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public  static GreeterImpl impliment Greeter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello(HelloRequest req, StreamObserver&lt;HelloReply&gt; responseObserver) &#123;</span><br><span class="line">    HelloReply reply &#x3D; HelloReply.newBuilder().setMessage(&quot;Hello &quot; + req.getName()).build();</span><br><span class="line">    responseObserver.onNext(reply);</span><br><span class="line">    responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sayHello 有两个参数：</p>
<ul>
<li>HelloRequest，请求。</li>
<li>StreamObserver<HelloReply>： 应答观察者，一个特殊的接口，服务器用应答来调用它。</HelloReply></li>
</ul>
<p>为了返回给客户端应答并且完成调用：</p>
<ul>
<li>用我们的激动人心的消息构建并填充一个在我们接口定义的 HelloReply 应答对象。</li>
<li>将 HelloReply 返回给客户端，然后表明我们已经完成了对 RPC 的处理。</li>
</ul>
<h4 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h4><p>需要提供一个 gRPC 服务的另一个主要功能是让这个服务实在在网络上可用。<br>HelloWorldServer.java 提供了以下代码作为 Java 的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* The port on which the server should run *&#x2F;</span><br><span class="line">private int port &#x3D; 50051;</span><br><span class="line">private Server server;</span><br><span class="line">private void start() throws Exception &#123;</span><br><span class="line">    server &#x3D; ServerBuilder.forPort(port)</span><br><span class="line">        .addService(GreeterGrpc.bindService(new GreeterImpl()))</span><br><span class="line">        .build()</span><br><span class="line">        .start();</span><br><span class="line">    logger.info(&quot;Server started, listening on &quot; + port);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(new Thread() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; Use stderr here since the logger may has been reset by its JVM shutdown hook.</span><br><span class="line">        System.err.println(&quot;*** shutting down gRPC server since JVM is shutting down&quot;);</span><br><span class="line">        HelloWorldServer.this.stop();</span><br><span class="line">        System.err.println(&quot;*** server shut down&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h4><p>客户端的 gRPC 非常简单。在这一步，我们将用生成的代码写一个简单的客户程序来访问我们在上一节里创建的 Greeter 服务器。<br>首先我们看一下我们如何连接 Greeter 服务器。我们需要创建一个 gRPC 频道，指定我们要连接的主机名和服务器端口。然后我们用这个频道创建存根实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final ManagedChannel channel;</span><br><span class="line">private final GreeterGrpc.GreeterBlockingStub blockingStub;</span><br><span class="line">public HelloWorldClient(String host, int port) &#123;</span><br><span class="line">    channel &#x3D; ManagedChannelBuilder.forAddress(host, port)</span><br><span class="line">        .usePlaintext(true)</span><br><span class="line">        .build();</span><br><span class="line">    blockingStub &#x3D; GreeterGrpc.newBlockingStub(channel);</span><br><span class="line">    HelloRequest req &#x3D; HelloRequest.newBuilder().setName(name).build();</span><br><span class="line">    HelloReply reply &#x3D; blockingStub.sayHello(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子里，我们创建了一个阻塞的存根。这意味着 RPC 调用要等待服务器应答，将会返回一个应答或抛出一个异常。 gRPC Java 还可以有其他种类的存根，可以向服务器发出非阻塞的调用，这种情况下应答是异步返回的。</p>
<ul>
<li>我们创建并填充一个 HelloRequest 发送给服务。</li>
<li>我们用请求调用存根的 SayHello()，如果 RPC 成功，会得到一个填充的 HelloReply ，从其中我们可以获得 greeting。</li>
</ul>
<h1 id="gRPC-进阶"><a href="#gRPC-进阶" class="headerlink" title="gRPC 进阶"></a>gRPC 进阶</h1><h2 id="在-protobuf-中定义服务"><a href="#在-protobuf-中定义服务" class="headerlink" title="在 protobuf 中定义服务"></a>在 protobuf 中定义服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option java_multiple_files &#x3D; true;</span><br><span class="line">option java_package &#x3D; &quot;io.grpc.examples.routeguide&quot;; &#x2F;&#x2F;指定java文件中的package包名</span><br><span class="line">option java_outer_classname &#x3D; &quot;RouteGuideProto&quot;;</span><br><span class="line">option objc_class_prefix &#x3D; &quot;RTG&quot;;</span><br><span class="line"></span><br><span class="line">package routeguide;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Interface exported by the server.</span><br><span class="line">service RouteGuide &#123;&#x2F;&#x2F;service用于指定服务，定义rpc方法，指定请求和相应类型</span><br><span class="line">  &#x2F;&#x2F;一个 简单 RPC ， 客户端使用存根发送请求到服务器并等待响应返回，就像平常的函数调用一样。</span><br><span class="line">  rpc GetFeature(Point) returns (Feature) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一个 服务器端流式 RPC ， 客户端发送请求到服务器，拿到一个流去读取返回的消息序列。 客户端读取返回的流，直到里面没有任何消息。从例子中可以看出，通过在 响应 类型前插入 stream 关键字，可以指定一个服务器端的流方法。</span><br><span class="line">  rpc ListFeatures(Rectangle) returns (stream Feature) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一个 客户端流式 RPC ， 客户端写入一个消息序列并将其发送到服务器，同样也是使用流。一旦 客户端完成写入消息，它等待服务器完成读取返回它的响应。通过在 请求 类型前指定 stream 关键字来指定一个客户端的流方法。</span><br><span class="line">  rpc RecordRoute(stream Point) returns (RouteSummary) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一个 双向流式 RPC 是双方使用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务器 可以以任意喜欢的顺序读写：比如， 服务器可以在写入响应前等待接收所有的客户端消息，或者可以交替 的读取和写入消息，或者其他读写的组合。 每个流中的消息顺序被预留。你可以通过在请求和响应前加 stream 关键字去制定方法的类型。</span><br><span class="line">  rpc RouteChat(stream RouteNote) returns (stream RouteNote) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">我们的 .proto 文件也包含了所有请求的 protocol buffer 消息类型定义以及在服务方法中使用的响</span><br><span class="line">应类型——比如，下面的Point消息类型：</span><br><span class="line">&#x2F;&#x2F; Points are represented as latitude-longitude pairs in the E7 representation</span><br><span class="line">&#x2F;&#x2F; (degrees multiplied by 10**7 and rounded to the nearest integer).</span><br><span class="line">&#x2F;&#x2F; Latitudes should be in the range +&#x2F;- 90 degrees and longitude should be in</span><br><span class="line">&#x2F;&#x2F; the range +&#x2F;- 180 degrees (inclusive).</span><br><span class="line">message Point &#123;</span><br><span class="line">  int32 latitude &#x3D; 1;</span><br><span class="line">  int32 longitude &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A latitude-longitude rectangle, represented as two diagonally opposite</span><br><span class="line">&#x2F;&#x2F; points &quot;lo&quot; and &quot;hi&quot;.</span><br><span class="line">message Rectangle &#123;</span><br><span class="line">  &#x2F;&#x2F; One corner of the rectangle.</span><br><span class="line">  Point lo &#x3D; 1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The other corner of the rectangle.</span><br><span class="line">  Point hi &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A feature names something at a given point.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; If a feature could not be named, the name is empty.</span><br><span class="line">message Feature &#123;</span><br><span class="line">  &#x2F;&#x2F; The name of the feature.</span><br><span class="line">  string name &#x3D; 1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The point where the feature is detected.</span><br><span class="line">  Point location &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Not used in the RPC.  Instead, this is here for the form serialized to disk.</span><br><span class="line">message FeatureDatabase &#123;</span><br><span class="line">  repeated Feature feature &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A RouteNote is a message sent while at a given point.</span><br><span class="line">message RouteNote &#123;</span><br><span class="line">  &#x2F;&#x2F; The location from which the message is sent.</span><br><span class="line">  Point location &#x3D; 1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The message to be sent.</span><br><span class="line">  string message &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A RouteSummary is received in response to a RecordRoute rpc.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; It contains the number of individual points received, the number of</span><br><span class="line">&#x2F;&#x2F; detected features, and the total distance covered as the cumulative sum of</span><br><span class="line">&#x2F;&#x2F; the distance between each point.</span><br><span class="line">message RouteSummary &#123;</span><br><span class="line">  &#x2F;&#x2F; The number of points received.</span><br><span class="line">  int32 point_count &#x3D; 1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The number of known features passed while traversing the route.</span><br><span class="line">  int32 feature_count &#x3D; 2;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The distance covered in metres.</span><br><span class="line">  int32 distance &#x3D; 3;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The duration of the traversal in seconds.</span><br><span class="line">  int32 elapsed_time &#x3D; 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成客户端和服务端代码"><a href="#生成客户端和服务端代码" class="headerlink" title="生成客户端和服务端代码"></a>生成客户端和服务端代码</h2><p>接下来我们需要从 .proto 的服务定义中生成 gRPC 客户端和服务器端的接口。我们通过 protocol buffer 的编译器 protoc 以及一个特殊的 gRPC Java 插件来完成。为了生成 gRPC 服务，你必须使用 proto3 编译器。<br>下面的类都是从我们的服务定义中生成：</p>
<ul>
<li>包含了所有填充，序列化以及获取请求和应答的消息类型的 Feature.java，Point.java， Rectangle.java 以及其它类文件。</li>
<li>RouteGuideGrpc.java 文件包含（以及其它一些有用的代码）：<ul>
<li>RouteGuide 服务器要实现的一个接口 RouteGuideGrpc.RouteGuide，其中所有的方法都定 义在 RouteGuide 服务中。</li>
<li>客户端可以用来和 RouteGuide 服务器交互的 存根 类。 异步的存根也实现了 RouteGuide 接口。</li>
</ul>
</li>
</ul>
<h2 id="创建服务器"><a href="#创建服务器" class="headerlink" title="创建服务器"></a>创建服务器</h2><p>让 RouteGuide 服务工作有两个部分：</p>
<ul>
<li>实现我们服务定义的生成的服务接口：做我们的服务的实际的“工作”。</li>
<li>运行一个 gRPC 服务器，监听来自客户端的请求并返回服务的响应。</li>
</ul>
<h3 id="实现-RouteGuide"><a href="#实现-RouteGuide" class="headerlink" title="实现 RouteGuide"></a>实现 RouteGuide</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line">public class RouteGuideServer &#123;</span><br><span class="line">  private static final Logger logger &#x3D; Logger.getLogger(RouteGuideServer.class.getName());</span><br><span class="line"></span><br><span class="line">  private final int port;</span><br><span class="line">  private final Server server;</span><br><span class="line"></span><br><span class="line">  public RouteGuideServer(int port) throws IOException &#123;</span><br><span class="line">    this(port, RouteGuideUtil.getDefaultFeaturesFile());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Create a RouteGuide server listening on &#123;@code port&#125; using &#123;@code featureFile&#125; database. *&#x2F;</span><br><span class="line">  public RouteGuideServer(int port, URL featureFile) throws IOException &#123;</span><br><span class="line">    this(ServerBuilder.forPort(port), port, RouteGuideUtil.parseFeatures(featureFile));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Create a RouteGuide server using serverBuilder as a base and features as data. *&#x2F;</span><br><span class="line">  public RouteGuideServer(ServerBuilder&lt;?&gt; serverBuilder, int port, Collection&lt;Feature&gt; features) &#123;</span><br><span class="line">    this.port &#x3D; port;</span><br><span class="line">    server &#x3D; serverBuilder.addService(new RouteGuideService(features))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Start serving requests. *&#x2F;</span><br><span class="line">  public void start() throws IOException &#123;</span><br><span class="line">    server.start();</span><br><span class="line">    logger.info(&quot;Server started, listening on &quot; + port);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(new Thread() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; Use stderr here since the logger may have been reset by its JVM shutdown hook.</span><br><span class="line">        System.err.println(&quot;*** shutting down gRPC server since JVM is shutting down&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">          RouteGuideServer.this.stop();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(&quot;*** server shut down&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Stop serving requests and shutdown resources. *&#x2F;</span><br><span class="line">  public void stop() throws InterruptedException &#123;</span><br><span class="line">    if (server !&#x3D; null) &#123;</span><br><span class="line">      server.shutdown().awaitTermination(30, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Await termination on the main thread since the grpc library uses daemon threads.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  private void blockUntilShutdown() throws InterruptedException &#123;</span><br><span class="line">    if (server !&#x3D; null) &#123;</span><br><span class="line">      server.awaitTermination();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Main method.  This comment makes the linter happy.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    RouteGuideServer server &#x3D; new RouteGuideServer(8980);</span><br><span class="line">    server.start();</span><br><span class="line">    server.blockUntilShutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 我们的服务器有一个实现了生成的 RouteGuideGrpc.Service 接口的 RouteGuideService 类：</span><br><span class="line">   *</span><br><span class="line">   * &lt;p&gt;See route_guide.proto for details of the methods.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  private static class RouteGuideService extends RouteGuideGrpc.RouteGuideImplBase &#123;</span><br><span class="line">    private final Collection&lt;Feature&gt; features;</span><br><span class="line">    private final ConcurrentMap&lt;Point, List&lt;RouteNote&gt;&gt; routeNotes &#x3D;</span><br><span class="line">        new ConcurrentHashMap&lt;Point, List&lt;RouteNote&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    RouteGuideService(Collection&lt;Feature&gt; features) &#123;</span><br><span class="line">      this.features &#x3D; features;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 简单 RPC</span><br><span class="line">     * 1. 如在我们的服务定义中指定的那样，我们组织并填充一个 Feature 应答对象返回给客户端。在这个 例子中，我们通过一个单独的私有方法checkFeature()来实现。</span><br><span class="line">     * 2. 我们使用应答观察者的 onNext() 方法返回 Feature。</span><br><span class="line">     * 3. 我们使用应答观察者的 onCompleted() 方法来指出我们已经完成了和 RPC的交互。</span><br><span class="line">     * @param request the requested location for the feature. 请求</span><br><span class="line">     * @param responseObserver the observer that will receive the feature at the requested point.一个应答的观察者，实际上是服务器调用它应答的一个特殊接口。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void getFeature(Point request, StreamObserver&lt;Feature&gt; responseObserver) &#123;</span><br><span class="line">      responseObserver.onNext(checkFeature(request));</span><br><span class="line">      responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 服务器端流式 RPC</span><br><span class="line">     * 这次我们得到了需要返回给客户端的足够多的 Feature 对象（在这个场景下，我们根据他们是否在我们的 Rectangle 请求中，从服务的特性集合中选择他们），并且使用 onNext() 方法轮流往响应观察* 者写入。最后，和简单 RPC 的例子一样，我们使用响应观察者的 onCompleted() 方法去告诉 gRPC 写入应答已完成。</span><br><span class="line">     * @param request the bounding rectangle for the requested features.</span><br><span class="line">     * @param responseObserver the observer that will receive the features.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void listFeatures(Rectangle request, StreamObserver&lt;Feature&gt; responseObserver) &#123;</span><br><span class="line">      int left &#x3D; min(request.getLo().getLongitude(), request.getHi().getLongitude());</span><br><span class="line">      int right &#x3D; max(request.getLo().getLongitude(), request.getHi().getLongitude());</span><br><span class="line">      int top &#x3D; max(request.getLo().getLatitude(), request.getHi().getLatitude());</span><br><span class="line">      int bottom &#x3D; min(request.getLo().getLatitude(), request.getHi().getLatitude());</span><br><span class="line"></span><br><span class="line">      for (Feature feature : features) &#123;</span><br><span class="line">        if (!RouteGuideUtil.exists(feature)) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int lat &#x3D; feature.getLocation().getLatitude();</span><br><span class="line">        int lon &#x3D; feature.getLocation().getLongitude();</span><br><span class="line">        if (lon &gt;&#x3D; left &amp;&amp; lon &lt;&#x3D; right &amp;&amp; lat &gt;&#x3D; bottom &amp;&amp; lat &lt;&#x3D; top) &#123;</span><br><span class="line">          responseObserver.onNext(feature);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 客户端流式 RPC</span><br><span class="line">     * 如你所见，我们的方法和前面的方法类型相似，拿到一个 StreamObserver 应答观察者参数，但是这次它返回一个 StreamObserver 以便客户端写入它的 Point。</span><br><span class="line">     * 在这个方法体中，我们返回了一个匿名 StreamObserver 实例，其中我们：</span><br><span class="line">     * 覆写了 onNext() 方法，每次客户端写入一个 Point 到消息流时，拿到特性和其它信息。</span><br><span class="line">     * 覆写了 onCompleted() 方法（在 客户端 结束写入消息时调用），用来填充和构建我们的 RouteSummary。然后我们用 RouteSummary 调用方法自己的的响应观察者的 onNext()，之后调用它的 onCompleted() 方法，结束服务器端的调用。</span><br><span class="line">     *</span><br><span class="line">     * @param responseObserver an observer to receive the response summary.</span><br><span class="line">     * @return an observer to receive the requested route points.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public StreamObserver&lt;Point&gt; recordRoute(final StreamObserver&lt;RouteSummary&gt; responseObserver) &#123;</span><br><span class="line">      return new StreamObserver&lt;Point&gt;() &#123;</span><br><span class="line">        int pointCount;</span><br><span class="line">        int featureCount;</span><br><span class="line">        int distance;</span><br><span class="line">        Point previous;</span><br><span class="line">        final long startTime &#x3D; System.nanoTime();</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(Point point) &#123;</span><br><span class="line">          pointCount++;</span><br><span class="line">          if (RouteGuideUtil.exists(checkFeature(point))) &#123;</span><br><span class="line">            featureCount++;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; For each point after the first, add the incremental distance from the previous point to</span><br><span class="line">          &#x2F;&#x2F; the total distance value.</span><br><span class="line">          if (previous !&#x3D; null) &#123;</span><br><span class="line">            distance +&#x3D; calcDistance(previous, point);</span><br><span class="line">          &#125;</span><br><span class="line">          previous &#x3D; point;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable t) &#123;</span><br><span class="line">          logger.log(Level.WARNING, &quot;recordRoute cancelled&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line">          long seconds &#x3D; NANOSECONDS.toSeconds(System.nanoTime() - startTime);</span><br><span class="line">          responseObserver.onNext(RouteSummary.newBuilder().setPointCount(pointCount)</span><br><span class="line">              .setFeatureCount(featureCount).setDistance(distance)</span><br><span class="line">              .setElapsedTime((int) seconds).build());</span><br><span class="line">          responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 双向流式RPC(与客户端流的差别主要是在responseObserver.onNext()方法的调用位置，这个调用位置位于onNext()方法中。而客户端流是在onComplete()方法中，意味着需要把客户端流处理完成后，才能调用onNext方法处理并立即结束。)</span><br><span class="line">     * 和我们的客户端流的例子一样，我们拿到和返回一个 StreamObserver 应答观察者，除了这次我们在客户端仍然写入消息到 它们的 消息流时通过我们方法的应答观察者返回值。这里读写的语法和客户端流以及服务器流方法一样。虽然每一端都会按照它们写入的顺序拿到另一端的消息，客户端和服务器都可以任意顺序读写——流的操作是互不依赖的。</span><br><span class="line">     *</span><br><span class="line">     * @param responseObserver an observer to receive the stream of previous messages.</span><br><span class="line">     * @return an observer to handle requested message&#x2F;location pairs.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public StreamObserver&lt;RouteNote&gt; routeChat(final StreamObserver&lt;RouteNote&gt; responseObserver) &#123;</span><br><span class="line">      return new StreamObserver&lt;RouteNote&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(RouteNote note) &#123;</span><br><span class="line">          List&lt;RouteNote&gt; notes &#x3D; getOrCreateNotes(note.getLocation());</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; Respond with all previous notes at this location.</span><br><span class="line">          for (RouteNote prevNote : notes.toArray(new RouteNote[0])) &#123;</span><br><span class="line">            responseObserver.onNext(prevNote);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; Now add the new note to the list</span><br><span class="line">          notes.add(note);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable t) &#123;</span><br><span class="line">          logger.log(Level.WARNING, &quot;routeChat cancelled&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line">          responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Get the notes list for the given location. If missing, create it.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private List&lt;RouteNote&gt; getOrCreateNotes(Point location) &#123;</span><br><span class="line">      List&lt;RouteNote&gt; notes &#x3D; Collections.synchronizedList(new ArrayList&lt;RouteNote&gt;());</span><br><span class="line">      List&lt;RouteNote&gt; prevNotes &#x3D; routeNotes.putIfAbsent(location, notes);</span><br><span class="line">      return prevNotes !&#x3D; null ? prevNotes : notes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Gets the feature at the given point.</span><br><span class="line">     *</span><br><span class="line">     * @param location the location to check.</span><br><span class="line">     * @return The feature object at the point. Note that an empty name indicates no feature.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Feature checkFeature(Point location) &#123;</span><br><span class="line">      for (Feature feature : features) &#123;</span><br><span class="line">        if (feature.getLocation().getLatitude() &#x3D;&#x3D; location.getLatitude()</span><br><span class="line">            &amp;&amp; feature.getLocation().getLongitude() &#x3D;&#x3D; location.getLongitude()) &#123;</span><br><span class="line">          return feature;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; No feature was found, return an unnamed feature.</span><br><span class="line">      return Feature.newBuilder().setName(&quot;&quot;).setLocation(location).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Calculate the distance between two points using the &quot;haversine&quot; formula.</span><br><span class="line">     * The formula is based on http:&#x2F;&#x2F;mathforum.org&#x2F;library&#x2F;drmath&#x2F;view&#x2F;51879.html.</span><br><span class="line">     *</span><br><span class="line">     * @param start The starting point</span><br><span class="line">     * @param end The end point</span><br><span class="line">     * @return The distance between the points in meters</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static int calcDistance(Point start, Point end) &#123;</span><br><span class="line">      int r &#x3D; 6371000; &#x2F;&#x2F; earth radius in meters</span><br><span class="line">      double lat1 &#x3D; toRadians(RouteGuideUtil.getLatitude(start));</span><br><span class="line">      double lat2 &#x3D; toRadians(RouteGuideUtil.getLatitude(end));</span><br><span class="line">      double lon1 &#x3D; toRadians(RouteGuideUtil.getLongitude(start));</span><br><span class="line">      double lon2 &#x3D; toRadians(RouteGuideUtil.getLongitude(end));</span><br><span class="line">      double deltaLat &#x3D; lat2 - lat1;</span><br><span class="line">      double deltaLon &#x3D; lon2 - lon1;</span><br><span class="line"></span><br><span class="line">      double a &#x3D; sin(deltaLat &#x2F; 2) * sin(deltaLat &#x2F; 2)</span><br><span class="line">          + cos(lat1) * cos(lat2) * sin(deltaLon &#x2F; 2) * sin(deltaLon &#x2F; 2);</span><br><span class="line">      double c &#x3D; 2 * atan2(sqrt(a), sqrt(1 - a));</span><br><span class="line"></span><br><span class="line">      return (int) (r * c);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">  gRpcServer &#x3D; NettyServerBuilder.forPort(port)</span><br><span class="line">      .addService(RouteGuideGrpc.bindService(new RouteGuideService(features)))</span><br><span class="line">      .build().start();</span><br><span class="line">  logger.info(&quot;Server started, listening on &quot; + port);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了做到这个，我们需要：</p>
<ul>
<li>创建我们服务实现类 RouteGuideService 的一个实例并且将其传给生成的 RouteGuideGrpc 类的静态方法 bindService() 去获得服务定义。</li>
<li>使用生成器的 forPort() 方法指定地址以及期望客户端请求监听的端口。</li>
<li>通过传入将 bindService() 返回的服务定义，用生成器注册我们的服务实现到生成器的 addService() 方法。</li>
<li>调用生成器上的 build() 和 start() 方法为我们的服务创建和启动一个 RPC 服务器。</li>
</ul>
<h2 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h2><h3 id="创建存根"><a href="#创建存根" class="headerlink" title="创建存根"></a>创建存根</h3><p>为了调用服务方法，我们需要首先创建一个 存根，或者两个存根：</p>
<ul>
<li>一个 阻塞/同步 存根：这意味着 RPC 调用等待服务器响应，并且要么返回应答，要么造成异常。</li>
<li>一个 非阻塞/异步 存根可以向服务器发起非阻塞调用，应答会异步返回。你可以使用异步存根去发起特定类型的流式调用。</li>
</ul>
<p>我们首先为存根创建一个 gRPC channel，指明服务器地址和我们想连接的端口号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel &#x3D; NettyChannelBuilder.forAddress(host, port)</span><br><span class="line">       .negotiationType(NegotiationType.PLAINTEXT)</span><br><span class="line">       .build();</span><br></pre></td></tr></table></figure>

<p>如你所见，我们用一个 NettyServerBuilder 构建和启动服务器。这个服务器的生成器基于 Netty 传输框架。<br>我们使用 Netty 传输框架，所以我们用一个 NettyServerBuilder 启动服务器。<br>现在我们可以通过从 .proto 中生成的 RouteGuideGrpc 类的 newStub 和 newBlockingStub 方法，使用频道去创建我们的存根。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blockingStub &#x3D; RouteGuideGrpc.newBlockingStub(channel);</span><br><span class="line">asyncStub &#x3D; RouteGuideGrpc.newStub(channel);</span><br></pre></td></tr></table></figure>

<h3 id="调用服务方法"><a href="#调用服务方法" class="headerlink" title="调用服务方法"></a>调用服务方法</h3><h4 id="简单-RPC"><a href="#简单-RPC" class="headerlink" title="简单 RPC"></a>简单 RPC</h4><p>在阻塞存根上调用简单 RPC GetFeature 几乎是和调用一个本地方法一样直观。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point request &#x3D; Point.newBuilder().setLatitude(lat).setLongitude(lon).build();</span><br><span class="line">Feature feature &#x3D; blockingStub.getFeature(request);</span><br></pre></td></tr></table></figure>

<p>我们创建和填充了一个请求 protocol buffer 对象（在这个场景下是 Point），在我们的阻塞存根上将其传给 getFeature() 方法，拿回一个 Feature。</p>
<h4 id="服务器端流式-RPC"><a href="#服务器端流式-RPC" class="headerlink" title="服务器端流式 RPC"></a>服务器端流式 RPC</h4><p>接下来，让我们看一个对于 ListFeatures 的服务器端流式调用，这个调用会返回一个地理性的 Feature 流：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rectangle request &#x3D;</span><br><span class="line">    Rectangle.newBuilder()</span><br><span class="line">        .setLo(Point.newBuilder().setLatitude(lowLat).setLongitude(lowLon).build())</span><br><span class="line">        .setHi(Point.newBuilder().setLatitude(hiLat).setLongitude(hiLon).build()).build();</span><br><span class="line">Iterator&lt;Feature&gt; features &#x3D; blockingStub.listFeatures(request);</span><br></pre></td></tr></table></figure>

<p>如你所见，这和我们刚看过的简单 RPC 很相似，除了方法返回客户端用来读取所有返回的 Feature 的 一个 Iterator，而不是单个的 Feature。</p>
<h4 id="客户端流式-RPC"><a href="#客户端流式-RPC" class="headerlink" title="客户端流式 RPC"></a>客户端流式 RPC</h4><p>现在看看稍微复杂点的东西：我们在客户端流方法 RecordRoute 中发送了一个 Point 流给服务器并且拿到一个 RouteSummary。为了这个方法，我们需要使用异步存根。如果你已经阅读了<br>创建服务器，一些部分看起来很相近——异步流式 RPC 是在两端通过相似的方式实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public void recordRoute(List&lt;Feature&gt; features, int numPoints) throws Exception &#123;</span><br><span class="line">    info(&quot;*** RecordRoute&quot;);</span><br><span class="line">    final SettableFuture&lt;Void&gt; finishFuture &#x3D; SettableFuture.create();</span><br><span class="line">    StreamObserver&lt;RouteSummary&gt; responseObserver &#x3D; new StreamObserver&lt;RouteSummary&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onNext(RouteSummary summary) &#123;</span><br><span class="line">        info(&quot;Finished trip with &#123;0&#125; points. Passed &#123;1&#125; features. &quot;</span><br><span class="line">            + &quot;Travelled &#123;2&#125; meters. It took &#123;3&#125; seconds.&quot;, summary.getPointCount(),</span><br><span class="line">            summary.getFeatureCount(), summary.getDistance(), summary.getElapsedTime());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void onError(Throwable t) &#123;</span><br><span class="line">        finishFuture.setException(t);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void onCompleted() &#123;</span><br><span class="line">        finishFuture.set(null);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    StreamObserver&lt;Point&gt; requestObserver &#x3D; asyncStub.recordRoute(responseObserver);</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; Send numPoints points randomly selected from the features list.</span><br><span class="line">      StringBuilder numMsg &#x3D; new StringBuilder();</span><br><span class="line">      Random rand &#x3D; new Random();</span><br><span class="line">      for (int i &#x3D; 0; i &lt; numPoints; ++i) &#123;</span><br><span class="line">        int index &#x3D; rand.nextInt(features.size());</span><br><span class="line">        Point point &#x3D; features.get(index).getLocation();</span><br><span class="line">        info(&quot;Visiting point &#123;0&#125;, &#123;1&#125;&quot;, RouteGuideUtil.getLatitude(point),</span><br><span class="line">            RouteGuideUtil.getLongitude(point));</span><br><span class="line">        requestObserver.onNext(point);</span><br><span class="line">        &#x2F;&#x2F; Sleep for a bit before sending the next one.</span><br><span class="line">        Thread.sleep(rand.nextInt(1000) + 500);</span><br><span class="line">        if (finishFuture.isDone()) &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      info(numMsg.toString());</span><br><span class="line">      requestObserver.onCompleted();</span><br><span class="line"></span><br><span class="line">      finishFuture.get();</span><br><span class="line">      info(&quot;Finished RecordRoute&quot;);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      requestObserver.onError(e);</span><br><span class="line">      logger.log(Level.WARNING, &quot;RecordRoute Failed&quot;, e);</span><br><span class="line">      throw e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，为了调用这个方法我们需要创建一个 StreamObserver，它为了服务器用它的 RouteSummary 应答实现了一个特殊的接口。在 StreamObserver 中，我们：</p>
<p>覆写了 onNext() 方法，在服务器把 RouteSummary 写入到消息流时，打印出返回的信息。<br>覆写了 onCompleted() 方法（在 服务器 完成自己的调用时调用）去设置 SettableFuture，这样我们可以检查服务器是不是完成写入。<br>之后，我们将 StreamObserver 传给异步存根的 recordRoute() 方法，拿到我们自己的 StreamObserver 请求观察者将 Point 发给服务器。一旦完成点的写入，我们使用请求观察者的 onCompleted() 方法告诉 gRPC 我们已经完成了客户端的写入。一旦完成，我们就检查 SettableFuture 验证服务器是否已经完成写入。</p>
<h4 id="双向流式-RPC"><a href="#双向流式-RPC" class="headerlink" title="双向流式 RPC"></a>双向流式 RPC</h4><p>最后，让我们看看双向流式 RPC RouteChat()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void routeChat() throws Exception &#123;</span><br><span class="line">    info(&quot;*** RoutChat&quot;);</span><br><span class="line">    final SettableFuture&lt;Void&gt; finishFuture &#x3D; SettableFuture.create();</span><br><span class="line">    StreamObserver&lt;RouteNote&gt; requestObserver &#x3D;</span><br><span class="line">        asyncStub.routeChat(new StreamObserver&lt;RouteNote&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void onNext(RouteNote note) &#123;</span><br><span class="line">            info(&quot;Got message \&quot;&#123;0&#125;\&quot; at &#123;1&#125;, &#123;2&#125;&quot;, note.getMessage(), note.getLocation()</span><br><span class="line">                .getLatitude(), note.getLocation().getLongitude());</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          public void onError(Throwable t) &#123;</span><br><span class="line">            finishFuture.setException(t);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          public void onCompleted() &#123;</span><br><span class="line">            finishFuture.set(null);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      RouteNote[] requests &#x3D;</span><br><span class="line">          &#123;newNote(&quot;First message&quot;, 0, 0), newNote(&quot;Second message&quot;, 0, 1),</span><br><span class="line">              newNote(&quot;Third message&quot;, 1, 0), newNote(&quot;Fourth message&quot;, 1, 1)&#125;;</span><br><span class="line"></span><br><span class="line">      for (RouteNote request : requests) &#123;</span><br><span class="line">        info(&quot;Sending message \&quot;&#123;0&#125;\&quot; at &#123;1&#125;, &#123;2&#125;&quot;, request.getMessage(), request.getLocation()</span><br><span class="line">            .getLatitude(), request.getLocation().getLongitude());</span><br><span class="line">        requestObserver.onNext(request);</span><br><span class="line">      &#125;</span><br><span class="line">      requestObserver.onCompleted();</span><br><span class="line"></span><br><span class="line">      finishFuture.get();</span><br><span class="line">      info(&quot;Finished RouteChat&quot;);</span><br><span class="line">    &#125; catch (Exception t) &#123;</span><br><span class="line">      requestObserver.onError(t);</span><br><span class="line">      logger.log(Level.WARNING, &quot;RouteChat Failed&quot;, t);</span><br><span class="line">      throw t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>和我们的客户端流的例子一样，我们拿到和返回一个 StreamObserver 应答观察者，除了这次我们在客户端仍然写入消息到 它们的 消息流时通过我们方法的应答观察者返回值。这里读写的语法和客户端流以及服务器流方法一样。虽然每一端都会按照它们写入的顺序拿到另一端的消息，客户端和服务器都可以任意顺序读写——流的操作是互不依赖的。</p>
<h1 id="ProtoBuf-存储原理"><a href="#ProtoBuf-存储原理" class="headerlink" title="ProtoBuf 存储原理"></a>ProtoBuf 存储原理</h1><p>核心是 Google 提出了“Base 128 Varints”编码,这是一种变字节长度的编码,官方描述为:varints 是用一个或多个字节序列化整形的一种方法。</p>
<h2 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h2><p>protobuf 把 message 通过一系列 key_value 对来表示。<br>Key 的算法为：(field_number &lt;&lt; 3）| wired_type<br>这里 field_number 就是具体的索引，wired_type 的值按下表查询。</p>
<table>
<thead>
<tr>
<th>wired_type</th>
<th>.proto 类型</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Varint int32, int64, uint32, uint64, sint32, sint64, bool, enum</td>
</tr>
<tr>
<td>1</td>
<td>64-bit fixed64, sfixed64, double</td>
</tr>
<tr>
<td>2</td>
<td>Length-delimited string, bytes, embedded messages, packed repeated fields</td>
</tr>
<tr>
<td>5</td>
<td>32-bit fixed32, sfixed32, float</td>
</tr>
<tr>
<td>对于 int，bool，enum 类型，value 就是 Varint。</td>
<td></td>
</tr>
</tbody></table>
<p>而对于 string，bytes，message 等等类型，value 是长度+原始内容编码。</p>
<ul>
<li><p>举例 int 类型存储(Varint 存储原理)<br>存储一个 int32 类型的数字，通常是 4 个字节。但是 Varints 最少只需要一个字节就可以了。<br>Varints 规定小于 128 的数字都可以用一个字节来表示，比如 10， 它就会用一个字节 0000 1010 来存储。<br>对于大于 128 的数字，则用更多个字节存储。<br>以 150 举例：protobuf 的存储字节是 1001 0110 0000 0001。<br>为什么会这样标识呢？首先我们了解一个字节共 8 位，表示的数字是 255，但是 Varints 只用一个字节表示小于 128 的数字，换句话说，就是 Varints 只用了 8 位中的 7 位来表示数字，而还有一位被用来干嘛了呢？<br>Varints 在官方规定中表示，每个字节的最高位是有特殊含义，当最高位为 1 的时候，代表后续的字节也是该数字的一部分。当最高位为 0 的时候，则表示结束。<br>比如过 150，二进制表示为 1001 0110。<br>先取后七位 001 0110， 作为第一个字节的内容。<br>再取余下 1 位，前面补 0 凑齐 7 位，就是 000 0001，作为第二字节。<br>对于 intel 机器，是小端字节序，低字节位于地址低的。0010110 是低字节地址，因此排在前面，因为后面的也是数字的一部分，所以高位补 1，也就成了 10010110。 同样的，高字节 000 0001，排在后面，并且它后面没有后续字节了，所以补 0，也就成了 0000 0001。<br>因此 150 在 protobuf 中的表示方式为 1001 0110 0000 0001。</p>
</li>
<li><p>举例 string 类型存储</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message Test &#123;</span><br><span class="line">required string desc &#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如把 a 设置为 “testing”的话， 那么序列化后的就是<br>12 07 74 65 73 74 69 64 67<br>其中 12 是 key。剩下的是 value。<br>怎么算的呢？先看 12， 这里的 12，是个 16 进制数字，其二进制位表示为 0001 0010。<br>0010 就是类型 string 的对应的 Type 值，根据上表，也就是 2。<br>field_number (required string desc)是 2，也就是 0010，左移三位，就成了 0001 0000。<br>按照 key 的计算公式，和 Type 值取并后就变成了 0001 0010，即 12。<br>Value 是长度加原始内容编码。<br>07 就是长度， 代表 string 总长 7 个字节。 后面 7 个数字一次代表每个字母所对应的 16 进制表示。</p>
</li>
</ul>
<h2 id="json-与-protobuf-的互转"><a href="#json-与-protobuf-的互转" class="headerlink" title="json 与 protobuf 的互转"></a>json 与 protobuf 的互转</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.google.protobuf&#x2F;protobuf-java-util --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.protobuf&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;protobuf-java-util&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.6.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>自定义的 bean 与 proto 是可以通过 Json 相互转换的，然而它们之间的转换需要第三方 JSON 转换工具和 protobuf util 的支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;to Json</span><br><span class="line">JsonFormat.Printer printer &#x3D; JsonFormat.printer();</span><br><span class="line">String print &#x3D; &quot;&quot;;</span><br><span class="line">try &#123;</span><br><span class="line">    print &#x3D; printer.print(person);</span><br><span class="line">    System.out.println(print);</span><br><span class="line">&#125; catch (InvalidProtocolBufferException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;to Object</span><br><span class="line">JsonFormat.Parser parser &#x3D; JsonFormat.parser();</span><br><span class="line">try &#123;</span><br><span class="line">    PersonProto.Person.Builder newBuilder &#x3D; PersonProto.Person.newBuilder();</span><br><span class="line">    parser.merge(print, newBuilder);</span><br><span class="line">    System.out.println(newBuilder.build());</span><br><span class="line">&#125; catch (InvalidProtocolBufferException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加java bean 此类对性数据库的字段，同时与proto类属性名相同</span><br><span class="line">public class Person implements Serializable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Boolean sex;</span><br><span class="line">    private Date dirthday;&#x2F;&#x2F;此处注意这里是时间类型而非proto类中的long类型</span><br><span class="line">    private String address;</span><br><span class="line">    private List&lt;Car&gt; cars &#x3D; new ArrayList&lt;Car&gt;();</span><br><span class="line">    private Map&lt;String, String&gt; other &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Car implements Serializable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在上面的转换中间添加以下代码,发现同样转换成功</span><br><span class="line">Person myPerson &#x3D; JsonUtil.toObject(print, Person.class);</span><br><span class="line">System.out.println(myPerson);</span><br><span class="line">print &#x3D; JsonUtil.toJson(myPerson);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/Web%E5%9F%BA%E7%A1%80+tomcat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/27/Web%E5%9F%BA%E7%A1%80+tomcat/" class="post-title-link" itemprop="url">Web基础+Tomcat</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-27 21:00:00 / Modified: 15:07:20" itemprop="dateCreated datePublished" datetime="2020-12-27T21:00:00+08:00">2020-12-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Web-基础和-tomcat"><a href="#Web-基础和-tomcat" class="headerlink" title="Web 基础和 tomcat"></a>Web 基础和 tomcat</h1><h2 id="tomcat-学艺"><a href="#tomcat-学艺" class="headerlink" title="tomcat 学艺"></a>tomcat 学艺</h2><p>JavaEE 规范：JDBC，JNDI，EJB，RMI，JSP，Servlets，XML，JMS，Java IDL，JTS，JTA，JavaMail，JAF。<br>Tomcat 只实现了俩：Servlet 和 JSP。其他服务器比如 JBoss、Weblogic 啥的都是完全支持的。所以人们往往更愿意叫 Tomcat 为轻量级的服务器，也有叫它 Servlet/JSP 容器的。所以 java 开发时不需要额外依赖 servlet 和 JSP，但是需要额外依赖 JDBC，因为 tomcat 里只实现了 Servlet 和 JSP。</p>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>服务器的主要作用:</p>
<ul>
<li>将资源对外暴露</li>
<li>配合各种传输协议进行响应输出<br>请先了解以下三个概念:</li>
<li>IP:电子设备在网络中的唯一表示，一个 IP 对应一台实体电脑。</li>
<li>端口：应用程序在计算机中的唯一标识，一个端口只能被唯一程序占用。</li>
<li>传输协议：数据传输的规则。<br>浏览器与服务器通信流程如下：<br><img src="/images/tomcat/tomcat-web-1.png"><br>实际请求时，最终还是要换算成 IP 去访问。总得来说有两种换算的途径：1.本机的 hosts 文件 2.DNS 服务器<br>DNS 解析域名得到对应的 IP 后，Request 请求里还是会带上 host。为什么？</li>
</ul>
<p>因为：域名!=IP。</p>
<p>实际上一个 IP 可以对应多个域名。也就是说一台实体服务器（大铁柜），理论上可以有多个域名（虚拟主机）。实体服务器和网站是两个概念。IP 只是对应实体服务器，而域名对应具体的网站。</p>
<p>比如上面百度服务器，虽然看起来 115.239.210.27 这个 IP 完全等同于<a href="http://www.baidu.com，但也有可能这个IP对应的服务器上配置了两个虚拟主机：www.baidu.com和tieba.baidu.com。所以即使找到了IP对应的服务器实体，Request请求还是要带上host主机名，以确定是哪个虚拟主机。">http://www.baidu.com，但也有可能这个IP对应的服务器上配置了两个虚拟主机：www.baidu.com和tieba.baidu.com。所以即使找到了IP对应的服务器实体，Request请求还是要带上host主机名，以确定是哪个虚拟主机。</a><br><img src="/images/tomcat/tomcat-web-2.png"><br>另外，如果两个域名对应同一个 IP，那么必须设置其中一个域名为默认的，不然同一台服务器有两个虚拟主机，我该访问谁？<br>已经知道 IP，就无需 DNS 解析，可直接访问服务器。若这个 IP 对应的服务器有两个虚拟主机，而用户 Request 请求行中又没有指定 host，则会访问默认主机（因此服务器要事先指定默认主机！Tomcat 默认 localhost，localhost 这个名称是一个保留域名）<br><img src="/images/tomcat/tomcat-web-3.png"><br>最后，再用 Tomcat 举个例子。比如，现在我有一台笔记本电脑（一个实体服务器），它的本机 IP 是 192.168.112.1，我在上面装了 Tomcat。如果 Tomcat 不改动配置，则默认只有一个虚拟主机 localhost（默认主机）。接着我开发了一个 JavaWeb 程序 demo1 部署到 Tomcat，然后我同事在浏览器输入下方地址。192.168.112.1:8080/demo1/index.html。访问我的电脑。虽然没有带 host，但是 localhost 是默认的，于是访问它。<br><img src="/images/tomcat/tomcat-web-4.png"></p>
<h2 id="3-个容易混淆的概念"><a href="#3-个容易混淆的概念" class="headerlink" title="3 个容易混淆的概念"></a>3 个容易混淆的概念</h2><p>其实，Tomcat 服务器 = Web 服务器 + Servlet/JSP 容器（Web 容器）。<br>Web 服务器的作用是接收客户端的请求，给客户端作出响应。但是很明显，服务器不止静态资源呀，所以客户端发起请求后，如果是动态资源，Web 服务器不可能直接把它响应回去（比如 JSP），因为浏览器只认识静态资源。所以对于 JavaWeb 程序而言，还需要 JSP/Servlet 容器，JSP/Servlet 容器的基本功能是把动态资源转换成静态资源。我们 JavaWeb 工程师需要使用 Web 服务器和 JSP/Servlet 容器，而通常这两者会集于一身，比如 Tomcat。<br><img src="/images/tomcat/tomcat-web-5.jpg"></p>
<h2 id="我们开发的-Web-应用都是半成品"><a href="#我们开发的-Web-应用都是半成品" class="headerlink" title="我们开发的 Web 应用都是半成品"></a>我们开发的 Web 应用都是半成品</h2><p>我们开发 JavaWeb 时，你操心过如何接收 HTTP 请求和响应 HTTP 请求吗？显然没有嘛！因为服务器都已经完成了。所以，我们用 Java 开发的 Web 应用只是一个半成品，类似于一个插件，而服务器则像一个收发器：<br><img src="/images/tomcat/tomcat-web-6.png"></p>
<h2 id="什么是动态资源"><a href="#什么是动态资源" class="headerlink" title="什么是动态资源"></a>什么是动态资源</h2><p>其实对于何谓动态资源，我也没有很精准的概念。要讲清楚一个东西是什么，有时是比较难的事。不如先说它不是什么。</p>
<p>首先，动态资源不等同于动态页面。所谓动态页面，就是页面会动，而会动的页面不一定是动态资源。比如我可以用 JQuery 执行一段代码，让一个 Div 不断放大缩小，但是很显然它还是一个 HTML 页面。</p>
<p>所谓动态资源，其实最显著的特征就是它能动态地生成 HTML！比如 JSP。动态资源有个“特色”：它的数据是“可拼装”的、而且“可以随时间变化”。下面用号称可以抗住 8 个明星同时出轨的新浪服务器举个例子：<br><img src="/images/tomcat/tomcat-web-7.png"></p>
<h2 id="Tomcat-架构"><a href="#Tomcat-架构" class="headerlink" title="Tomcat 架构"></a>Tomcat 架构</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><img src="/images/tomcat/tomcat-web-8.jpg"></p>
<h3 id="Tomcat-的架构"><a href="#Tomcat-的架构" class="headerlink" title="Tomcat 的架构"></a>Tomcat 的架构</h3><p><img src="/images/tomcat/tomcat-web-9.jpg"></p>
<h3 id="server-xml-配置"><a href="#server-xml-配置" class="headerlink" title="server.xml 配置"></a>server.xml 配置</h3><p><img src="/images/tomcat/tomcat-web-10.jpg"><br><img src="/images/tomcat/tomcat-web-11.jpg"><br>简略解释一下 xml 里的配置：</p>
<ul>
<li><p>Server.xml 文件中的配置结构和 Tomcat 的架构是一一对应的。根目录是<Server>，代表服务器，<Server>下面有且仅有 1 个<Service>，代表服务。<br><Service>下有两个<Connector>，代表连接（需要的话可以再加）。</Connector></Service></Service></Server></Server></p>
</li>
<li><p>其实这个 Connector 就是我们在上面讨论百度服务器时画过的端口。大家可以看到 Tomcat 默认配置了两个端口，一个是 HTTP/1.1 协议的，一个是 AJP/1.3 协议（AJP 连接器可以通过 AJP 协议和另一个 web 服务器行交互）。前者专门处理 HTTP 请求，后者可以通其他 web 服务器连接。<br><img src="/images/tomcat/tomcat-web-12.jpeg"></p>
</li>
<li><p>当我们在浏览器输入”<a target="_blank" rel="noopener" href="http://localhost:8080/demo/index.html&quot;%E6%97%B6%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E4%BB%A5HTTP%E5%8D%8F%E8%AE%AE%E5%8F%91%E9%80%81%E7%9A%84%EF%BC%8C%E5%BD%93%E8%BF%99%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%88%B0%E4%BA%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%EF%BC%8C%E4%BC%9A%E8%A2%AB%E8%AF%86%E5%88%AB%E4%B8%BAHTTP%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BA%8E%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B0%B1%E6%89%BE%E6%9D%A5%E4%B8%93%E9%97%A8%E5%A4%84%E7%90%86HTTP%E7%9A%84Connector%EF%BC%8C%E5%AE%83%E7%9A%84%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E6%AD%A3%E6%98%AF%E4%B8%8A%E9%97%A8Server.xml%E9%85%8D%E7%BD%AE%E7%9A%848080%E3%80%82">http://localhost:8080/demo/index.html&quot;时，浏览器是以HTTP协议发送的，当这个请求到了服务器后，会被识别为HTTP类型，于是服务器就找来专门处理HTTP的Connector，它的默认端口正是上门Server.xml配置的8080。</a></p>
</li>
<li><p>与 Connector 平级的还有个<Engine>（Tomcat 引擎），也就是说<Service>有两个孩子，小儿子是<Connector>，大儿子是<Engine>。Connector 的作用说穿了就是监听端口，如果用户访问地址是“localhost:8080/xx/xx”，那就由监听 8080 端口的 Connector 负责，如果是”<a target="_blank" rel="noopener" href="https://www.baidu.com&quot;,那么就是443端口处理.其实connector也不处理实际业务,它只是个孩子.但它会负责把客人(请求)带到哥哥engine那,然后engine会处理./">https://www.baidu.com&quot;，那么就是443端口处理。其实Connector也不处理实际业务，它只是个孩子。但它会负责把客人（请求）带到哥哥Engine那，然后Engine会处理。</a></Engine></Connector></Service></Engine></p>
</li>
<li><p><Engine>下面有个 Host，代表主机。一个是默认的虚拟主机 localhost,一个是虚拟主机 xxxhost。localhost 对应的 appBase 是 webapps，所以请求到达 localhost 之后，会在 webapps 文件夹下面寻找对应子目录。</Engine></p>
</li>
</ul>
<h3 id="tomcat-中的-DefaultServlet"><a href="#tomcat-中的-DefaultServlet" class="headerlink" title="tomcat 中的 DefaultServlet"></a>tomcat 中的 DefaultServlet</h3><p>实际使用 tomcat 的时候，即使没有编写 Servlet，tomcat 依然可以处理请求返回结果，是因为 tomcat 有一个 DefaultServlet。像 Tomcat 这样的 Servlet 容器来说，任何一个请求的背后肯定有个 Servlet 在默默处理：<br><img src="/images/tomcat/tomcat-web-13.png"><br>在 tomcat/conf/web.xml 中，声明了一个 DefaultServlet。我们每个动态 web 工程都有个 web.xml，而 conf 里的这个，是它们的“老爹”。它里面的配置，如果动态 web 工程没有覆盖，就会被“继承”下来。我们会发现，conf/web.xml 里配置了一个 DefaultServlet：<br><img src="/images/tomcat/tomcat-web-14.jpg"><br>DefaultServlet 的作用：最低级匹配，当没有对应的 Servlet 处理当前请求时，才轮到它处理。要么找到并响应请求的资源，要么给出 404 页面</p>
<h3 id="JSP-剖析"><a href="#JSP-剖析" class="headerlink" title="JSP 剖析"></a>JSP 剖析</h3><p>我们都知道 JSP 是“化了浓妆”的 Servlet，但是好不容易伪装成了一个 JSP，是谁帮它卸妆的呢？另外，大家仔细想想，一般来说 JavaWeb 阶段我们访问资源有三种“形式”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localhost:8080&#x2F;demo&#x2F;AServlet：很明显，我们手动写了一个AServlet处理它</span><br><span class="line">localhost:8080&#x2F;demo&#x2F;haha.html：虽然我们没写，但是Tomcat自己准备了DefaultServlet</span><br><span class="line">localhost:8080&#x2F;demo&#x2F;index.jsp：我擦，谁来处理？</span><br></pre></td></tr></table></figure>

<p>对呀，细思恐极，这*.jsp 的资源，谁来处理？其实就是 JspServlet。它的作用简而言之就是：</p>
<p>首先，根据请求路径找到 JSP<br>然后，将它“翻译成”Servlet</p>
<p>JSP 的 Servlet 也定义在 conf/web.xml。<br><img src="/images/tomcat/tomcat-web-15.png"></p>
<h3 id="tomcat-处理请求的几种方式"><a href="#tomcat-处理请求的几种方式" class="headerlink" title="tomcat 处理请求的几种方式"></a>tomcat 处理请求的几种方式</h3><p><img src="/images/tomcat/tomcat-web-16.jpg"></p>
<h3 id="tomcat-处理-http-流程"><a href="#tomcat-处理-http-流程" class="headerlink" title="tomcat 处理 http 流程"></a>tomcat 处理 http 流程</h3><p>1、用户点击网页内容，请求被发送到本机端口 8080，被在那里监听的 Coyote HTTP/1.1 Connector 获得。<br>2、Connector 把该请求交给它所在的 Service 的 Engine 来处理，并等待 Engine 的回应。<br>3、Engine 获得请求 localhost/servlet/helloServlet，匹配所有的虚拟主机 Host。<br>4、Engine 匹配到名为 localhost 的 Host（即使匹配不到也把请求交给该 Host 处理，因为该 Host 被定义为该 Engine 的默认主机），名为 localhost 的 Host 获得求/servlet/HelloServlet，匹配它所拥有的所有的 Context。Host 匹配到路径为/servlet 的 Context（如果匹配不到就把该请求交给路径名为“ ”的 Context 去处理）。<br>5、path=“/servlet”的 Context 获得请求/HelloServlet，在它的 mapping table 中寻找出对应的 Servlet。<br>6、构造 HttpServletRequest 对象和 HttpServletResponse 对象，作为参数调用 Servlet 的 doGet（）或 doPost（）.执行业务逻辑、数据存储等程序。<br>7、Context 把执行完之后的 HttpServletResponse 对象返回给 Host。<br>8、Host 把 HttpServletResponse 对象返回给 Engine。<br>9、Engine 把 HttpServletResponse 对象返回 Connector。<br>10、Connector 把 HttpServletResponse 对象返回给客户 Browser。<br><img src="/images/tomcat/tomcat-web-17.jpg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/Servlet%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/27/Servlet%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">Servlet与SpringMVC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-27 13:01:22 / Modified: 18:37:15" itemprop="dateCreated datePublished" datetime="2020-12-27T13:01:22+08:00">2020-12-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>Java Servlet 技术简称 Servlet 技术，是 Java 开发 Web 应用的底层技术。由 Sun 公司于 1996 年发布，用来代替 CGU—-当时生成 Web 动态内容的主流技术。CGI 的问题是每一个 WEB 请求都需要重新启动一个进程来处理。创建进程需要消耗不少 CPU 周期，导致难以编写刻苦鏖战的 CGI 程序，而 Servlet 在创建后（处理第一个请求时）就一直保存在内存中，这就比 CGI 有着更好的性能。</p>
<p>Servlet 是一个 Java 程序，一个 servlet 应用有一个或多个 Servlet 程序。JSP 页面会被转换和编译成 servlet 程序。</p>
<p>Servlet 程序无法独立运行，必须运行在 Servlet 容器中。Servlet 容器将用户的请求床底给 servlet 应用，并将结果返回给用户。由于大部分 Servlet 用用都包含多个 JSP 页面，因此更准确地说是“Servlet/JSP 应用”。</p>
<p>Servlet/JSP 容器是一个可以同时处理 Servlet 和静态内容的 Web 容器。过去，由于通常认为 HTTP 服务器比 Servlet/JSP 容器更加可靠，因此人们习惯将 servlet 容器当做 HTTP 服务器的一个模块，这种模式下，HTTP 服务器用来处理静态资源，Servlet 容器则负责生成动态内容。</p>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Constructor of the object.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public HelloServlet() &#123;</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Destruction of the servlet. &lt;br&gt;</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void destroy() &#123;</span><br><span class="line">		super.destroy(); &#x2F;&#x2F; Just puts &quot;destroy&quot; string in log</span><br><span class="line">		&#x2F;&#x2F; Put your code here</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * The doGet method of the servlet. &lt;br&gt;</span><br><span class="line">	 *</span><br><span class="line">	 * This method is called when a form has its tag value method equals to get.</span><br><span class="line">	 *</span><br><span class="line">	 * @param request the request send by the client to the server</span><br><span class="line">	 * @param response the response send by the server to the client</span><br><span class="line">	 * @throws ServletException if an error occurred</span><br><span class="line">	 * @throws IOException if an error occurred</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">		response.setContentType(&quot;text&#x2F;html&quot;);</span><br><span class="line">		PrintWriter out &#x3D; response.getWriter();</span><br><span class="line">		out.println(&quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN\&quot;&gt;&quot;);</span><br><span class="line">		out.println(&quot;&lt;HTML&gt;&quot;);</span><br><span class="line">		out.println(&quot;  &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;&#x2F;TITLE&gt;&lt;&#x2F;HEAD&gt;&quot;);</span><br><span class="line">		out.println(&quot;  &lt;BODY&gt;&quot;);</span><br><span class="line">		out.print(&quot;    This is &quot;);</span><br><span class="line">		out.print(this.getClass());</span><br><span class="line">		out.println(&quot;, using the GET method&quot;);</span><br><span class="line">		out.println(&quot;  &lt;&#x2F;BODY&gt;&quot;);</span><br><span class="line">		out.println(&quot;&lt;&#x2F;HTML&gt;&quot;);</span><br><span class="line">		out.flush();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * The doPost method of the servlet. &lt;br&gt;</span><br><span class="line">	 *</span><br><span class="line">	 * This method is called when a form has its tag value method equals to post.</span><br><span class="line">	 *</span><br><span class="line">	 * @param request the request send by the client to the server</span><br><span class="line">	 * @param response the response send by the server to the client</span><br><span class="line">	 * @throws ServletException if an error occurred</span><br><span class="line">	 * @throws IOException if an error occurred</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">		response.setContentType(&quot;text&#x2F;html&quot;);</span><br><span class="line">		PrintWriter out &#x3D; response.getWriter();</span><br><span class="line">		out.println(&quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN\&quot;&gt;&quot;);</span><br><span class="line">		out.println(&quot;&lt;HTML&gt;&quot;);</span><br><span class="line">		out.println(&quot;  &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;&#x2F;TITLE&gt;&lt;&#x2F;HEAD&gt;&quot;);</span><br><span class="line">		out.println(&quot;  &lt;BODY&gt;&quot;);</span><br><span class="line">		out.print(&quot;    This is &quot;);</span><br><span class="line">		out.print(this.getClass());</span><br><span class="line">		out.println(&quot;, using the POST method&quot;);</span><br><span class="line">		out.println(&quot;  &lt;&#x2F;BODY&gt;&quot;);</span><br><span class="line">		out.println(&quot;&lt;&#x2F;HTML&gt;&quot;);</span><br><span class="line">		out.flush();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Initialization of the servlet. &lt;br&gt;</span><br><span class="line">	 *</span><br><span class="line">	 * @throws ServletException if an error occurs</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void init() throws ServletException &#123;</span><br><span class="line">		&#x2F;&#x2F; Put your code here</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看见，这个 HelloServlet 继承了 HTTPServlet 类，主要有 init()、doGet（）、doPost（）、destroy()四个方法。我们在浏览器中分别用 get 和 post 访问这个 servlet。<br><img src="/images/web/servlet-1.png"><br>我们可以看到，这就是上文我们编写的 doGet 方法中的 Html 生成的页面。</p>
<h1 id="Servlet-前世今生"><a href="#Servlet-前世今生" class="headerlink" title="Servlet 前世今生"></a>Servlet 前世今生</h1><p>一个 web 请求过程：</p>
<ul>
<li>接受请求</li>
<li>处理请求</li>
<li>相应请求<br>web 服务器负责接受请求和相应请求，如果是静态资源那么 web 服务器就够用了。如果是动态资源就要处理请求，这时候就需要 servlet 了。 servlet 专门用来处理请求，编写业务逻辑。后来三层架构出现了，servlet 就把一些任务分担到 servier 和 dao，形成了 servlet(contrller)+service+dao。servlet 本身不擅长往浏览器输出 HTML 页面，所以出现了 JSP。<br>等 Spring 家族出现后，Servlet 开始退居幕后，取而代之的是 SpringMVC。SpringMVC 的核心组件 DispatcherServlet 其实本质就是一个 Servlet。但它已经自立门户，在原来 HTTPServlet 的基础上，又封装了一条逻辑。<br>Servlet 是 J2EE 规范中的一种，主要是为了扩展 java 作为 web 服务的功能，事实上，servlet 就是一个 Java 接口。<br><img src="/images/web/servlet-2.png"></li>
</ul>
<h1 id="Servlet-与-SpringMVC"><a href="#Servlet-与-SpringMVC" class="headerlink" title="Servlet 与 SpringMVC"></a>Servlet 与 SpringMVC</h1><p>参考连接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/65658315">https://zhuanlan.zhihu.com/p/65658315</a></p>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>ServletContext 对象的作用是在整个 Web 应用的动态资源（Servlet/JSP）之间共享数据。例如在 AServlet 中向 ServletContext 对象保存一个值，然后在 BServlet 中就可以获取这个值。</p>
<h2 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h2><p>这种用来装载共享数据的对象，在 JavaWeb 中共有 4 个，而且更习惯被成为“域对象”：</p>
<ul>
<li>ServletContext 域（Servlet 间共享数据）</li>
<li>Session 域（一次会话间共享数据，也可以理解为多次请求间共享数据）</li>
<li>Request 域（同一次请求共享数据）</li>
<li>Page 域（JSP 页面内共享数据）<br>它们都可以看做是 map，都有 getAttribute()/setAttribute()方法。</li>
</ul>
<h2 id="ServletContext-的方法"><a href="#ServletContext-的方法" class="headerlink" title="ServletContext 的方法"></a>ServletContext 的方法</h2><p>所以，获取 ServletContext 的方法共 5 种（page 域这里不考虑，JSP 太少用了）：</p>
<ul>
<li>ServletConfig#getServletContext();</li>
<li>GenericServlet#getServletContext();</li>
<li>HttpSession#getServletContext();</li>
<li>HttpServletRequest#getServletContext();</li>
<li>ServletContextEvent#getServletContext();</li>
</ul>
<h2 id="Filter-过滤器"><a href="#Filter-过滤器" class="headerlink" title="Filter 过滤器"></a>Filter 过滤器</h2><p>Filter 更详细的拦截其实是这样：<br>最外层那个圈，可以理解成 ServletContext，FORWARD/INCLUDE 这些都是内部请求。如果在 web.xml 中配置 Filter 时 4 种拦截方式全配上，那么服务器内部的分发跳转都会被过滤。下图中灰色的墙就是 fliter。红色字代表各种请求方式，FORWARD 和 INCLUDE 的位置相同。<br><img src="/images/web/servlet-3.png"></p>
<h2 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h2><p>对于静态资源，Tomcat 最后会交由一个叫做 DefaultServlet 的类来处理<br>对于 Servlet ，Tomcat 最后会交由一个叫做 InvokerServlet 的类来处理<br>对于 JSP，Tomcat 最后会交由一个叫做 JspServlet 的类来处理<br><img src="/images/web/servlet-5.png"></p>
<h2 id="DispatcherServlet-与-SpringMVC"><a href="#DispatcherServlet-与-SpringMVC" class="headerlink" title="DispatcherServlet 与 SpringMVC"></a>DispatcherServlet 与 SpringMVC</h2><p>tomcat 是一个 Servlet 容器，这个容器内可以存在多个 servlet，处理不同的请求。<br>加入 springmvc，它提供了一个 Servlet，可以处理.do 结尾的请求，还有静态资源的请求和其它请求。如果，我们为 springmvc 在 web.xml 配置的映射 url 为/*则代表所有请求都要走 springmvc，tomcat 中的 DefaultServlet 和 JSPServlet 都无法得到请求。因为这个两个 servlet 是在 tomcat 的 conf/web.xml 中配置的，这个 web.xml 的配置会被各个应用自己的 web.xml 覆盖，最终 tomcat 按照应用定义的 web.xml 来做映射。<br>SpringMVC 的核心控制器叫 DispatcherServlet，映射原理和我们上面山寨版的一样，因为本质还是个 Servlet。但 SpringMVC 提供了一个标签，解决上面/无法读取静态资源的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 静态资源处理  css js imgs --&gt;</span><br><span class="line">&lt;mvc:resources location&#x3D;&quot;&#x2F;resources&#x2F;**&quot; mapping&#x3D;&quot;&#x2F;resources&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>其他的我也不说了，一张图，大家体会一下 DispatcherServlet 与 SpringMVC 到底是什么关系：<br><img src="/images/web/servlet-6.jpg"><br>DispatcherServlet 确实是一个 Servlet，但它只是入口，SpringMVC 要比想象的庞大。DispatcherServlet 只是 Springmvc 的一个入口，Springmvc 内部是十分复杂的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/Servlet%E5%AF%B9%E6%AF%94CGI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/27/Servlet%E5%AF%B9%E6%AF%94CGI/" class="post-title-link" itemprop="url">Servlet与CGI</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-27 12:01:22 / Modified: 15:32:24" itemprop="dateCreated datePublished" datetime="2020-12-27T12:01:22+08:00">2020-12-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="对比-Servlt-和-CGI"><a href="#对比-Servlt-和-CGI" class="headerlink" title="对比 Servlt 和 CGI"></a>对比 Servlt 和 CGI</h1><p>java 的 servlet 实现是自己规定了一套协议，与 CGI 和 fastcgi 协议不同。<br>Servlet 与 CGI 的区别<br>对比一：当用户浏览器发出一个 Http/CGI 的请求，或者说调用一个 CGI 程序的时候，服务器端就要新启用一个进程(而且是每次都要调用)，调用 CGI 程序越多(特别是访问量高的时候)，就要消耗系统越多的处理时间，只剩下越来越少的系统资源，对于用户来说，只能是漫长的等待服务器端的返回页面了，这对于电子商务激烈发展的今天来说，不能不说是一种技术上的遗憾。</p>
<p>而 Servlet 充分发挥了服务器端的资源并高效的利用。每次调用 Servlet 时并不是新启用一个进程，而是在一个 Web 服务器的进程中共享和分离线程，而线程最大的好处在于可以共享一个数据源，使系统资源被有效利用。</p>
<p>对比二：传统的 CGI 程序，不具备平台无关性特征，系统环境发生变化，CGI 程序就要瘫痪，而 Servlet 具备 Java 的平台无关性，在系统开发过程中保持了系统的可扩展性、高效性。</p>
<p>对比三：传统技术中，一般大都为二层的系统架构，即 Web 服务器+数据库服务器，导致网站访问量大的时候，无法克服 CGI 程序与数据库建立连接时速度慢的瓶颈，从而死机、数据库死锁现象频繁发生。而 Servlet 有连接池的概念，它可以利用多线程的优点，在系统缓存中事先建立好若干与数据库的连接，到时候若想和数据库打交道可以随时跟系统”要”一个连接即可，反应速度可想而知。</p>
<p>Java Servlet 为什么不做成 FastCGI 模式？</p>
<p>1、JVM 多线程架构健壮性非常强</p>
<p>理论上多进程确实健壮性更强，但实际上，JVM 进程远比普通 C/C++进程坚固。</p>
<p>用 C/C++写程序，随便一个空指针、内存越界、内存泄漏就可能意外终止进程，更遑论很多 C/C++程序处理严重错误的方式都是很粗暴的 exit 或者 panic。</p>
<p>而用 Java 写代码，要想不小心终止进程很难。异常机制可以保证几乎没有任何 Java 代码能够直接干掉一个线程或进程，Java 程序的线程几乎跟普通 C/C++的进程一样脆弱／坚固。</p>
<p>2、Tomcat 静态文件性能并不差<br>别的 Servlet 容器不清楚，但是得益于独立的 connector 设计，较新版本的 Tomcat 有了 NIO、APR 等技术的加持，静态文件性能不会比 apache httpd 差到哪儿去。</p>
<p>“很多网站直接用 servlet 容器当 web 服务器”，因为这样很简单，而且暂时可能没遇到或不关心性能瓶颈。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/26/Tomcat%E8%BF%B7%E4%BD%A0%E7%89%88%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/26/Tomcat%E8%BF%B7%E4%BD%A0%E7%89%88%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Tomcat迷你版实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-26 23:00:00" itemprop="dateCreated datePublished" datetime="2020-12-26T23:00:00+08:00">2020-12-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-27 14:50:35" itemprop="dateModified" datetime="2020-12-27T14:50:35+08:00">2020-12-27</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Tomcat 是非常流行的 Web Server，它还是一个满足 Servlet 规范的容器。那么想一想，Tomcat 和我们的 Web 应用是什么关系？</p>
<p>从感性上来说，我们一般需要把 Web 应用打成 WAR 包部署到 Tomcat 中，在我们的 Web 应用中，我们要指明 URL 被哪个类的哪个方法所处理「不论是原始的 Servlet 开发，还是现在流行的 Spring MVC 都必须指明」。</p>
<p>由于我们的 Web 应用是运行在 Tomcat 中，请求必定是先到达 Tomcat 的。Tomcat 对于请求实际上会进行如下的处理。</p>
<p>第一，提供 Socket 服务</p>
<p>Tomcat 的启动，必然是 Socket 服务，只不过它支持 HTTP 协议而已！</p>
<p>这里其实可以扩展思考下，Tomcat 既然是基于 Socket，那么是基于 BIO or NIO or AIO 呢？</p>
<p>第二，进行请求的分发</p>
<p>要知道一个 Tomcat 可以为多个 Web 应用提供服务，很显然，Tomcat 可以把 URL 下发到不同的 Web 应用。</p>
<p>第三，需要把请求和响应封装成 request/response</p>
<p>我们在 Web 应用这一层，可从来没有封装过 request/response 的，我们都是直接使用的，这就是因为 Tomcat 已经为你做好了！</p>
<p>话不多说，先来看一眼工程截图。<br><img src="/images/tomcat/tomcat1.png"></p>
<h1 id="一、封装请求对象"><a href="#一、封装请求对象" class="headerlink" title="一、封装请求对象"></a>一、封装请求对象</h1><p><img src="/images/tomcat/tomcat2.png"><br>这里可以清楚的看到，通过输入流，对 HTTP 协议进行解析，拿到了 HTTP 请求头的方法以及 URL。</p>
<h1 id="二、封装响应对象"><a href="#二、封装响应对象" class="headerlink" title="二、封装响应对象"></a>二、封装响应对象</h1><p><img src="/images/tomcat/tomcat3.png"><br>基于 HTTP 协议的格式进行输出写入。</p>
<h1 id="三、Servlet-请求处理基类"><a href="#三、Servlet-请求处理基类" class="headerlink" title="三、Servlet 请求处理基类"></a>三、Servlet 请求处理基类</h1><p><img src="/images/tomcat/tomcat4.png"><br>前文说 Tomcat 是满足 Servlet 规范的容器，那么自然 Tomcat 需要提供 API。这里看到了 Servlet 常见的 doGet/doPost/service 方法。</p>
<p>#　四、Servlet 实现类<br><img src="/images/tomcat/tomcat5.png"><br><img src="/images/tomcat/tomcat6.png"><br>提供这 2 个具体的 Servlet 实现，只是为了后续的测试！</p>
<h1 id="五、Servlet-配置"><a href="#五、Servlet-配置" class="headerlink" title="五、Servlet 配置"></a>五、Servlet 配置</h1><p><img src="/images/tomcat/tomcat7.png"><br><img src="/images/tomcat/tomcat8.png"><br>你应该有些感觉了吧？在 servlet 开发中，会在 web.xml 中通过<servlet>和<servlet-mapping>来进行指定哪个 URL 交给哪个 servlet 进行处理。</servlet-mapping></servlet></p>
<h1 id="六、启动类"><a href="#六、启动类" class="headerlink" title="六、启动类"></a>六、启动类</h1><p><img src="/images/tomcat/tomcat9.png"><br><img src="/images/tomcat/tomcat10.png"><br><img src="/images/tomcat/tomcat11.png"><br>这里，你能够看到 Tomcat 的处理流程，即把 URL 对应处理的 Servlet 关系形成，解析 HTTP 协议，封装请求/响应对象，利用反射实例化具体的 Servlet 进行处理即可。</p>
<h1 id="七、测试"><a href="#七、测试" class="headerlink" title="七、测试"></a>七、测试</h1><p><img src="/images/tomcat/tomcat12.png"><br>实现一个简易版的 Tomcat 就这么 7 大步搞定，大家都来动手实现一下吧，代码最好不要复制，自己动手一个个敲，这样实现之后，对 Tomcat 就没那么陌生了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/26/Play%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/26/Play%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">Play框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-26 21:00:00 / Modified: 22:09:50" itemprop="dateCreated datePublished" datetime="2020-12-26T21:00:00+08:00">2020-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Play 框架架构<br>当请求从浏览器发到服务端时，会有 Routes 来处理，如我们请求 /use/1 的 URL 时。这个请求将在 Routes 找到对应的函数来处理，在 Django 中处理请求的函数叫做 URL Dispatcher。</p>
<p><img src="/images/web/play01.png"><br>这里的路由规则分为了两个部分:请求动态数据或静态资源。<br>浏览器一般先请求获得 html 页面，然后 html 内容如果有 ajax 则会再发送请求过来，请求动态数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Routes</span><br><span class="line"># This file defines all application routes (Higher priority routes first)</span><br><span class="line"># ~~~~</span><br><span class="line"></span><br><span class="line"># Home page</span><br><span class="line">GET         &#x2F;                    controllers.ApplicationController.index</span><br><span class="line">POST        &#x2F;user                controllers.ApplicationController.addUser</span><br><span class="line">GET         &#x2F;delete&#x2F;:id          controllers.ApplicationController.deleteUser(id : Long)</span><br><span class="line">GET         &#x2F;user&#x2F;:id            controllers.ApplicationController.getUser(id : Long)</span><br><span class="line">GET         &#x2F;api&#x2F;user&#x2F;:id        controllers.ApiController.getUser(id : Long)</span><br><span class="line">POST        &#x2F;api&#x2F;user            controllers.ApiController.createUser</span><br><span class="line"></span><br><span class="line"># Map static resources from the &#x2F;public folder to the &#x2F;assets URL path</span><br><span class="line">GET         &#x2F;assets&#x2F;*file        controllers.Assets.versioned(path&#x3D;&quot;&#x2F;public&quot;, file: Asset)</span><br></pre></td></tr></table></figure>

<p>随后在我们的 ApiController 中会有一个对应的 getUser 的方法来处理，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ApiController extends Controller &#123;</span><br><span class="line">  def getUser(id: Long) &#x3D; Action.async &#123; implicit request &#x3D;&gt;</span><br><span class="line">    UserService.getUser(id).map &#123;</span><br><span class="line">      case None &#x3D;&gt; NotFound(Json.obj(&quot;error&quot; -&gt; &quot;Not Found&quot;))</span><br><span class="line">      case Some(user) &#x3D;&gt; Ok(Json.toJson(user))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后还是相应的 UserService 去取相应的用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import models.&#123;User, Users&#125;</span><br><span class="line">import scala.concurrent.Future</span><br><span class="line"></span><br><span class="line">object UserService &#123;</span><br><span class="line"></span><br><span class="line">  def addUser(user: User): Future[String] &#x3D; &#123;</span><br><span class="line">    Users.add(user)</span><br><span class="line">  &#125;</span><br><span class="line">  def getUser(id: Long): Future[Option[User]] &#x3D; &#123;</span><br><span class="line">    Users.get(id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后便会执行到 model 层:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">object Users &#123;</span><br><span class="line"></span><br><span class="line">  val dbConfig &#x3D; DatabaseConfigProvider.get[JdbcProfile](Play.current)</span><br><span class="line"></span><br><span class="line">  val users &#x3D; TableQuery[UserTableDef]</span><br><span class="line"></span><br><span class="line">  def add(user: User): Future[String] &#x3D; &#123;</span><br><span class="line">    dbConfig.db.run(users +&#x3D; user).map(res &#x3D;&gt; user.toString()).recover &#123;</span><br><span class="line">      case ex: Exception &#x3D;&gt; ex.getCause.getMessage</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  def get(id: Long): Future[Option[User]] &#x3D; &#123;</span><br><span class="line">    dbConfig.db.run(users.filter(_.id &#x3D;&#x3D;&#x3D; id).result.headOption)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就取到了这个用户。如果只是从这个过程上来说，我觉得和一般的 MVC 框架并没有太大的区别。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/26/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/26/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">函数式编程与面向对象编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-26 21:00:00 / Modified: 22:51:32" itemprop="dateCreated datePublished" datetime="2020-12-26T21:00:00+08:00">2020-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="编程的本质"><a href="#编程的本质" class="headerlink" title="编程的本质"></a>编程的本质</h1><p>当写过许许多多程序后，接触了那么多编程模式、设计模式、框架、语言、算法、数据结构以后，就会发现编程的本质万变不离其宗就是，操纵一坨数据。当然操纵的方式有许多，存储的方式也五花八门，但是本质不变，就是访问数据（读取以及改变）。</p>
<p>下面谈一谈我对两种编程方式的理解，就是面向对象编程，以及函数式编程。我用 JavaScript 这种神奇的语言来解释，因为 JavaScript 既可以面向对象编程，也可以函数式编程。</p>
<h1 id="数据存放方式"><a href="#数据存放方式" class="headerlink" title="数据存放方式"></a>数据存放方式</h1><p>1、对于 OO（面向对象，下同），数据存放在对象的属性（成员变量）里面，以及静态成员（全局变量）</p>
<p>2、对于函数式，数据存放在闭包（各级作用域）里面，作用域包括全局作用域。</p>
<h1 id="数据访问方式"><a href="#数据访问方式" class="headerlink" title="数据访问方式"></a>数据访问方式</h1><p>数据存放方式决定了访问的方式。</p>
<p>1、对于 OO 来说，访问数据（全局变量除外）需要先获取对象的引用，然后再进行操作（直接访问——公共属性，或者调用成员函数/方法访问——私有属性）</p>
<p>2、对于函数式，访问数据是直接访问（通过函数入参或者作用域链查找）</p>
<p>下面上一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;OO</span><br><span class="line">class Foo &#123;</span><br><span class="line">constructor()&#123;</span><br><span class="line">this.bar &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let foo &#x3D; new Foo()</span><br><span class="line">foo.bar ++</span><br></pre></td></tr></table></figure>

<p>//函数式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let bar &#x3D; 0</span><br><span class="line">function foo()&#123;</span><br><span class="line">bar ++</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>这是随便写了一些没有用代码，只是为了展示两种风格的编程方式。</p>
<p>从中我们可以看出一些东西，OO 是通过持有，以及传递对象的方式去让别的对象来操作数据，而对象也会是其他对象的成员，层层嵌套。当你想要访问某一个数据的时候，就需要顺着对象的引用链条去找，一步步去操作。</p>
<p>函数式传递的则是函数，调用函数即操作数据，传递函数的时候其实隐含着传递了函数创建的时候所附带的作用域，这个在表面上看不出来，在底层是有的。</p>
<p>OO 所谓的对象，本质上就是函数式中的作用域。</p>
<p>为了理解这句话，我们来看高阶函数的本质</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo(x)&#123;</span><br><span class="line">let bar &#x3D; x</span><br><span class="line">return function()&#123;</span><br><span class="line">return bar</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let Bar &#x3D; foo(1)</span><br><span class="line">console.log(Bar())&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>

<p>当调用 foo(1)的时候返回一个函数，这个函数可以访问 foo 函数内部的 bar 变量，这就是高阶函数。如果翻译成 OO 思想大家就知道怎么回事了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">constructor(x)&#123;</span><br><span class="line">this.bar &#x3D; x</span><br><span class="line">&#125;</span><br><span class="line">Bar()&#123;</span><br><span class="line">return this.bar</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let foo &#x3D; new Foo(1)</span><br><span class="line">console.log(foo.Bar())</span><br></pre></td></tr></table></figure>

<p>看上去是不是差不多。其实在 C#中对 lambda 表达式的编译就是这个原理。会内部创建一些类。</p>
<p>当然高阶函数的写法肯定不会这么啰嗦，会写的比较优雅。(这就是本质区别）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let foo &#x3D; bar&#x3D;&gt;()&#x3D;&gt;bar</span><br><span class="line">let Bar &#x3D; foo(1)</span><br><span class="line">console.log(Bar())&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>

<p>所以 OO 编程，是面向作用域编程，而函数式编程，是面向功能编程。</p>
<p>函数式编程有一个巨大的优势，就是作用域链，也就是说函数可以访问的变量范围要远远大于 OO，灵活性就成几何级数上升。换句话也可以说 OO 的约束性更强。</p>
<h1 id="FP-适合数据处理，OOP-适合外包业务领域"><a href="#FP-适合数据处理，OOP-适合外包业务领域" class="headerlink" title="FP 适合数据处理，OOP 适合外包业务领域"></a>FP 适合数据处理，OOP 适合外包业务领域</h1><p>函数式编程（FP）和面向对象编程（OOP）直接相比是一种常见的误解。这种比较应该是 FP 和 OOP 支持者之间互相怼的产物。</p>
<p>事实上，FP 和 OOP 是两种不同的看待事物的方式。FP 强调“everything is lambda”，并且强调在逻辑处理中不变性的重要性。不变到什么地步呢？原教旨主义的 FP 就连普通的循环都不可以写（因为循环都有个变化的 idx 或者条件之类的变量），必须用递归实现。这样做的结果就是把一切“状态”都消除。任何“状态”都是由确定的输入经过确定的一组函数处理得到的最终结果。 FP 适合的领域是处理数据。</p>
<p>OOP 强调“everything is object”，以及 object 之间的消息传递。通过消息传递改变每个 Object 的内部状态。OOP 之父 Alan Kay 表示”OOP is all about messaging”。利用 OOP 建模，都会通过某种消息机制来模拟一些场景的处理。比如交易=下单 Object，支付 Object，积分 Object 等之间进行交互当然，实际的 OOP 的程序运行时为了效率一般会用方法调用，而不是真的传递一个物理消息。OOP 适合的领域是企业 ERP，外包业务等。</p>
<p>如果你看懂了上面两个概念，就会发现他们说的事情压根就不在一个频道里。因此各自的好处也不能证明另一方有缺点。</p>
<p>现在经常看到文章表达 FP 如何如何优于 OOP，大概原因有这么两点：第一点是，OOP 早期不切实际的吹牛皮，吹爆了。很多人谈起 OOP，都会有“用了 OOP，代码耦合就小了，就容易维护了，扩展就方便了，代码就更容易复用了等等“的第一印象。但实际上这并不一定发生。软件设计并非因为 OOP 就直接自动变好了。因此很多程序员在趟坑多年后可能会感觉“我擦，学了这么多年，全是假的“。更进一步的，像 Java 这样的“纯 OOP”语言迫使程序员并不需要 OOP 的情况下也得照着 OOP 的方式去写代码，结果啰嗦又臃肿。所以很多人越来越讨厌 OOP 其实是可以理解的。（比如这篇 Goodbye, Objected Oriented Programming)。现在的 Java 程序大量使用反射、lambda 等技术，已经不是早期那个单纯 OOP 语言了。第二点是现代程序开始往并发发展。而 FP 的不可变，没有副作用等特性恰好让并发编程变得不容易出错。并且配合多种并发模型（如 CSP、Map Reduce、Fork &amp; Join、Promise 等），可以解决很多高并发的问题，显得高、大、上、酷。</p>
<p>但是，我非常赞同《人月神话》的著名论断——没有银弹。不论 OOP 还是 FP，用好了都可以发挥作用，用不好一样吃瘪。</p>
<p>举几个例子，一个业务领域建模，其实模拟的就是现实当中的不同角色的人/机构的工作方式。因为如果是人/机构互相协作，就是通过消息来协作的。比如博士生想发文章，先得自己写，写了老板审阅，完事发给期刊编辑，编辑找同行评议，完事发表，发表的结果会收录到某个文献索引数据库。这个过程就是多个独立的“对象”在相互协作的结果。因此 OOP 在这个层面上对这个流程进行抽象是很合适的。当然你也可以说，这时我用 FP 的各种动作函数的组织来描述这个过程，也是可以的。但是如果比较一下，这个场景用 FP 和 OOP 建模，哪个更容易理解呢？</p>
<p>再比如，对一组数据做加工，先查询，然后聚合，聚合后排序，再 join，再排序，再聚合，再转换（map）得到最终的结果。这个过程，用 FP 的函数就很自然，因为这一看就是 result = func1(func2(func3…funcN(x))))这时用 OOP 呢？给每一个步骤建一个 class？然后把排序、聚合等操作放在 class 里？抽象个基类？或者弄个 XXXUtils 的静态方法集合类？当然都可以做，但是很明显这不是个好的设计。再再比如，一个业务流程，就是一组步骤：第一步如何如何，第二部如何如何……。这时用 FP 和 OOP 都不能很好的表达问题（可能 FP 接近点）。这其实是典型的“指令式编程“。如果业务逻辑如此，那么就照着一步一步做就是最好的，而不是抽取函数和不变状态；或者定义一些根本无意义的 class。</p>
<p>说了这么多，其实希望表达的意思是：到底用哪种编程模式，要看问题本身适合哪个。哪个用起来自然，和问题本身特质搭配，那就用哪个。用对了，事半功倍；用错了，就各种纠结拧巴。你希望你一个东西模拟为 Object，前提是这个东西本身容易抽象成一个 Object；你希望你一个数据可以抽象为一组函数执行的组合，前提是这样理解更自然，更舒服。此外，同一个问题可以拆解为不同的层次，不同的层次可以使用各自适合的方式。比如高层的可以 OOP，具体到某个执行逻辑里可以用 FP 或者指令编程。</p>
<h1 id="对比面向过程，面向对象，函数式编程"><a href="#对比面向过程，面向对象，函数式编程" class="headerlink" title="对比面向过程，面向对象，函数式编程"></a>对比面向过程，面向对象，函数式编程</h1><p>函数式编程、面向对象编程和面向过程编程都是思维方式，具体语言的语法不构成限制。这三者可以当作是一条光谱上不同的颜色，一头是命令式风格，一头是声明式风格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">               ↓&lt;过程式&gt;           ↓&lt;面向对象&gt;       ↓&lt;函数式&gt;</span><br><span class="line">[命令式风格] o----------------------------------------------------&gt; [声明式风格]</span><br></pre></td></tr></table></figure>

<p>箭头从左到右抽象程度逐渐上升。过程式风格有函数的概念，和纯粹的指令相比可以用简短的函数替代一段指令；面向对象风格包装了一层 class 这样的概念，允许打包的一组数据自己持有一些信息，使用者调用方法前不需要知道所有的事情；函数式风格允许把“处理过程”本身当作参数，传入的处理过程的参数就代表具体操作时遇到的实体。<br>函数式编程就是用函数的组合来解决问题，面向对象是建很多对象来互相交互解决问题，面向过程就是下一步下一步下一步。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>输入十个整数，输出大于平均值的数，然后输出排序后的十个数面向过程/<em>C</em>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int input[10];</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">int tmp;</span><br><span class="line">double average;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;input[i]);</span><br><span class="line">  sum +&#x3D; input[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">average &#x3D; sum &#x2F; 10.0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">  if (input[i] &gt; average)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, input[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;_Bubble Sort_&#x2F;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">  for (int j &#x3D; 0; j &lt; 9 - i; j++)</span><br><span class="line">  &#123;</span><br><span class="line">    if (input[j] &gt; input[j + 1])</span><br><span class="line">    &#123;</span><br><span class="line">      tmp &#x3D; input[j];</span><br><span class="line">      input[j] &#x3D; input[j + 1];</span><br><span class="line">      input[j + 1] &#x3D; tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%d\n&quot;, input[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面向对象//C++</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class solve</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    solve() noexcept;</span><br><span class="line">    void sort();</span><br><span class="line">    void show();&#x2F;&#x2F;输出大于均值的数</span><br><span class="line">    void print();&#x2F;&#x2F;打印数组</span><br><span class="line">  private:</span><br><span class="line">    int input[10];</span><br><span class="line">    int sum;</span><br><span class="line">    double average;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;具体实现省略</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  auto test &#x3D; new solve();</span><br><span class="line">  test-&gt;show();</span><br><span class="line">  test-&gt;sort();</span><br><span class="line">  test-&gt;print();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数式编程#Python</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array &#x3D; [int(input()) for i in range(10)]</span><br><span class="line">average &#x3D; sum(array) &#x2F; 10;</span><br><span class="line">print(list(filter(lambda x: x &gt; average, array)))</span><br><span class="line">print(sorted(array))</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/26/Web%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2%E5%8F%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/26/Web%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2%E5%8F%98%E5%8C%96/" class="post-title-link" itemprop="url">Web技术历史变化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-26 21:00:00" itemprop="dateCreated datePublished" datetime="2020-12-26T21:00:00+08:00">2020-12-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-27 11:47:18" itemprop="dateModified" datetime="2020-12-27T11:47:18+08:00">2020-12-27</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、简单明快的早期时代"><a href="#一、简单明快的早期时代" class="headerlink" title="一、简单明快的早期时代"></a>一、简单明快的早期时代</h1><p><img src="/images/web/1.png"><br>可称之为 Web 1.0 时代，非常适合创业型小项目，不分前后端，经常 3-5 人搞定所有开发。页面由 JSP、PHP 等工程师在服务端生成，浏览器负责展现。基本上是服务端给什么浏览器就展现什么，展现的控制在 Web Server 层。</p>
<p>这种模式的好处是：简单明快，本地起一个 Tomcat 或 Apache 就能开发，调试什么的都还好，只要业务不太复杂。</p>
<p>然而业务总会变复杂，这是好事情，否则很可能就意味着创业失败了。业务的复杂会让 Service 越来越多，参与开发的人员也很可能从几个人快速扩招到几十人。在这种情况下，会遇到一些典型问题：</p>
<p>1、Service 越来越多，调用关系变复杂，前端搭建本地环境不再是一件简单的事。考虑团队协作，往往会考虑搭建集中式的开发服务器来解决。这种解决方案对编译型的后端开发来说也许还好，但对前端开发来说并不友好。天哪，我只是想调整下按钮样式，却要本地开发、代码上传、验证生效等好几个步骤。也许习惯了也还好，但开发服务器总是不那么稳定，出问题时往往需要依赖后端开发搞定。看似仅仅是前端开发难以本地化，但这对研发效率的影响其实蛮大。</p>
<p>2、JSP 等代码的可维护性越来越差。JSP 非常强大，可以内嵌 Java 代码。这种强大使得前后端的职责不清晰，JSP 变成了一个灰色地带。经常为了赶项目，为了各种紧急需求，会在 JSP 里揉杂大量业务代码。积攒到一定阶段时，往往会带来大量维护成本。</p>
<p>这个时期，为了提高可维护性，可以通过下面的方式实现前端的组件化：</p>
<p><img src="/images/web/1.1.png"><br>理论上，如果大家都能按照最佳实践去书写代码，那么无论是 JSP 还是 PHP，可维护性都不会差。但可维护性更多是工程含义，有时候需要通过限制带来自由，需要某种约定，使得即便是新手也不会写出太糟糕的代码。</p>
<p>如何让前后端分工更合理高效，如何提高代码的可维护性，在 Web 开发中很重要。下面我们继续来看，技术架构的演变如何解决这两个问题。</p>
<h1 id="二、后端为主的-MVC-时代"><a href="#二、后端为主的-MVC-时代" class="headerlink" title="二、后端为主的 MVC 时代"></a>二、后端为主的 MVC 时代</h1><p>为了降低复杂度，以后端为出发点，有了 Web Server 层的架构升级，比如 Structs、Spring MVC 等，这是后端的 MVC 时代。</p>
<p><img src="/images/web/2.png"><br>代码可维护性得到明显好转，MVC 是个非常好的协作模式，从架构层面让开发者懂得什么代码应该写在什么地方。为了让 View 层更简单干脆，还可以选择 Velocity、Freemaker 等模板，使得模板里写不了 Java 代码。看起来是功能变弱了，但正是这种限制使得前后端分工更清晰。然而依旧并不是那么清晰，这个阶段的典型问题是：</p>
<p>1、前端开发重度依赖开发环境。这种架构下，前后端协作有两种模式：一种是前端写 demo，写好后，让后端去套模板。淘宝早期包括现在依旧有大量业务线是这种模式。好处很明显，demo 可以本地开发，很高效。不足是还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大。另一种协作模式是前端负责浏览器端的所有开发和服务器端的 View 层模板开发，支付宝是这种模式。好处是 UI 相关的代码都是前端去写就好，后端不用太关注，不足就是前端开发重度绑定后端环境，环境成为影响前端开发效率的重要因素。</p>
<p>2、前后端职责依旧纠缠不清。Velocity 模板还是蛮强大的，变量、逻辑、宏等特性，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写出不少业务代码。还有一个很大的灰色地带是 Controller，页面路由等功能本应该是前端最关注的，但却是由后端来实现。Controller 本身与 Model 往往也会纠缠不清，看了让人咬牙的代码经常会出现在 Controller 层。这些问题不能全归结于程序员的素养，否则 JSP 就够了。</p>
<p>经常会有人吐槽 Java，但 Java 在工程化开发方面真的做了大量思考和架构尝试。Java 蛮符合马云的一句话：让平凡人做非凡事。</p>
<h1 id="三、Ajax-带来的-SPA-时代"><a href="#三、Ajax-带来的-SPA-时代" class="headerlink" title="三、Ajax 带来的 SPA 时代"></a>三、Ajax 带来的 SPA 时代</h1><p>历史滚滚往前，2004 年 Gmail 像风一样的女子来到人间，很快 2005 年 Ajax 正式提出，加上 CDN 开始大量用于静态资源存储，于是出现了 JavaScript 王者归来的 SPA （Single Page Application 单页面应用）时代。</p>
<p><img src="/images/web/3.png"><br>这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口。看起来是如此美妙，但回过头来看看的话，这与 JSP 时代区别不大。复杂度从服务端的 JSP 里移到了浏览器的 JavaScript，浏览器端变得很复杂。类似 Spring MVC，这个时代开始出现浏览器端的分层架构：</p>
<p><img src="/images/web/3.1.png"><br>对于 SPA 应用，有几个很重要的挑战：</p>
<p>1、前后端接口的约定。如果后端的接口一塌糊涂，如果后端的业务模型不够稳定，那么前端开发会很痛苦。这一块在业界有 API Blueprint 等方案来约定和沉淀接口，在阿里，不少团队也有类似尝试，通过接口规则、接口平台等方式来做。有了和后端一起沉淀的接口规则，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发。相信这一块会越做越好。</p>
<p>2、前端开发的复杂度控制。SPA 应用大多以功能交互型为主，JavaScript 代码过十万行很正常。大量 JS 代码的组织，与 View 层的绑定等，都不是容易的事情。典型的解决方案是业界的 Backbone，但 Backbone 做的事还很有限，依旧存在大量空白区域需要挑战。</p>
<p>SPA 让前端看到了一丝绿色，但依旧是在荒漠中行走。</p>
<h1 id="四、前端为主的-MV-时代"><a href="#四、前端为主的-MV-时代" class="headerlink" title="四、前端为主的 MV* 时代"></a>四、前端为主的 MV* 时代</h1><p>为了降低前端开发复杂度，除了 Backbone，还有大量框架涌现，比如 EmberJS、KnockoutJS、AngularJS 等等。这些框架总的原则是先按类型分层，比如 Templates、Controllers、Models，然后再在层内做切分，如下图：</p>
<p><img src="/images/web/4.png"><br>好处很明显：</p>
<p>1、前后端职责很清晰。前端工作在浏览器端，后端工作在服务端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 RESTful 等接口。</p>
<p>2、前端开发的复杂度可控。前端代码很重，但合理的分层，让前端代码能各司其职。这一块蛮有意思的，简单如模板特性的选择，就有很多很多讲究。并非越强大越好，限制什么，留下哪些自由，代码应该如何组织，所有这一切设计，得花一本的厚度去说明。</p>
<p>3、部署相对独立，产品体验可以快速改进。</p>
<p>但依旧有不足之处：</p>
<p>代码不能复用。比如后端依旧需要对数据做各种校验，校验逻辑无法复用浏览器端的代码。如果可以复用，那么后端的数据校验可以相对简单化。<br>全异步，对 SEO 不利。往往还需要服务端做同步渲染的降级方案。<br>性能并非最佳，特别是移动互联网环境下。<br>SPA 不能满足所有需求，依旧存在大量多页面应用。URL Design 需要后端配合，前端无法完全掌控。<br>五、Node 带来的全栈时代<br>前端为主的 MV* 模式解决了很多很多问题，但如上所述，依旧存在不少不足之处。随着 Node.js 的兴起，JavaScript 开始有能力运行在服务端。这意味着可以有一种新的研发模式：</p>
<p><img src="/images/web/5.png"><br>在这种研发模式下，前后端的职责很清晰。对前端来说，两个 UI 层各司其职：</p>
<p>1、Front-end UI layer 处理浏览器层的展现逻辑。通过 CSS 渲染样式，通过 JavaScript 添加交互功能，HTML 的生成也可以放在这层，具体看应用场景。</p>
<p>2、Back-end UI layer 处理路由、模板、数据获取、cookie 等。通过路由，前端终于可以自主把控 URL Design，这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以摆脱对展现的强关注，转而可以专心于业务逻辑层的开发。</p>
<p>通过 Node，Web Server 层也是 JavaScript 代码，这意味着部分代码可前后复用，需要 SEO 的场景可以在服务端同步渲染，由于异步请求太多导致的性能问题也可以通过服务端来缓解。前一种模式的不足，通过这种模式几乎都能完美解决掉。</p>
<p>与 JSP 模式相比，全栈模式看起来是一种回归，也的确是一种向原始开发模式的回归，不过是一种螺旋上升式的回归。</p>
<h1 id="基于-Node-的全栈模式，依旧面临很多挑战："><a href="#基于-Node-的全栈模式，依旧面临很多挑战：" class="headerlink" title="基于 Node 的全栈模式，依旧面临很多挑战："></a>基于 Node 的全栈模式，依旧面临很多挑战：</h1><p>需要前端对服务端编程有更进一步的认识。比如 network/tcp、PE 等知识的掌握。<br>Node 层与 Java 层的高效通信。Node 模式下，都在服务器端，RESTful HTTP 通信未必高效，通过 SOAP 等方式通信更高效。一切需要在验证中前行。<br>对部署、运维层面的熟练了解，需要更多知识点和实操经验。<br>大量历史遗留问题如何过渡。这可能是最大最大的阻力。<br>六、小结<br>回顾历史总是让人感慨，展望未来则让人兴奋。上面讲到的研发模式，除了最后一种还在探索期，其他各种在各大公司都已有大量实践。几点小结：</p>
<p>模式没有好坏高下之分，只有合不合适。<br>Ajax 给前端开发带来了一次质的飞跃，Node 很可能是第二次。<br>SoC（关注度分离） 是一条伟大的原则。上面种种模式，都是让前后端的职责更清晰，分工更合理高效。<br>还有个原则，让合适的人做合适的事。比如 Web Server 层的 UI Layer 开发，前端是更合适的人选。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/21/ANTLR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/21/ANTLR/" class="post-title-link" itemprop="url">Antlr相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-21 21:00:00" itemprop="dateCreated datePublished" datetime="2020-12-21T21:00:00+08:00">2020-12-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-26 15:24:21" itemprop="dateModified" datetime="2020-12-26T15:24:21+08:00">2020-12-26</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="实例入门"><a href="#实例入门" class="headerlink" title="实例入门"></a>实例入门</h1><p>在安装完 antlr 之后，可以编写简单的 g4 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grammar Hello;</span><br><span class="line">r:&#39;hello&#39; ID ;</span><br><span class="line">ID:[a-z]+ ;</span><br><span class="line">WS:[\t\r\n]+ -&gt; skip;</span><br></pre></td></tr></table></figure>

<p>运行如下命令</p>
<ul>
<li><code>antlr Hello.g4</code></li>
<li><code>javac *.java</code></li>
<li><code>alias grun=‘java org.antlr.v4.runtime.misc.TestRig’</code> TestRig 是一个调试工具，使用 alias 给它起了一个别名。直接执行<code>grun</code>可以得到帮助信息。</li>
<li><code>grun Hello r -tokens</code></li>
<li><code>hello parrt</code></li>
<li><code>EOF</code></li>
</ul>
<p>得到如下结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[@0,0:4&#x3D;&#39;hello&#39;,&lt;&#39;hello&#39;&gt;,1:0]</span><br><span class="line">[@1,6:10&#x3D;&#39;parrt&#39;,&lt;ID&gt;,1:6]</span><br><span class="line">[@2,12:11&#x3D;&#39;&lt;EOF&gt;&#39;,&lt;EOF&gt;,2:0]</span><br></pre></td></tr></table></figure>

<p>解析结果：比如 parrt。@1 表明该词法符号在第 2 个位置，parrt 位于第 6 个到第 10 个位置之间，词法符号类型是 ID，位于输入文本的第 1 行，第 6 个位置处。</p>
<h1 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h1><p>Antlr 依据我们定义的语法规则，产生一个递归下降的语法分析器。下降过程就是从语法分析树的根节点开始，朝着叶节点进行解析的过程。递归下降的语法分析其实际是若干方法的结合，每个方法对应一条规则。递归下降属于自上而下的语法分析器的一种实现。<br>首先调用的规则，即语义符号的起始点，就会成为语法分析树的根节点。比如：调用上面的 r()方法，作为起始点。<br>语法分析数的构造过程：识别匹配的规则，将对应规则的方法映射到语法分析树中。<br>一般规则分为：单一分支，多分支。例如：多个规则 assign，ifstat<br>单一分支，如：<code>stat: assign;</code><br>多分支，如:<code>stat: assign|ifstat;</code></p>
<h2 id="顺序解析"><a href="#顺序解析" class="headerlink" title="顺序解析"></a>顺序解析</h2><p>单一分支，只需要顺序匹配词汇符号。</p>
<h2 id="多分支解析"><a href="#多分支解析" class="headerlink" title="多分支解析"></a>多分支解析</h2><p>多分支，需要检查下一个词法符号或者多个词法符号，来决定选择哪个备选分支。这个过程成为预测或语法分析决策。<br>如果在预测过程中，发现多个分支都匹配的话，则出现了规则的定义出现了歧义，需要解决。</p>
<h2 id="歧义"><a href="#歧义" class="headerlink" title="歧义"></a>歧义</h2><p>例如下面这个语法就存在歧义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stat: expr &#39;;&#39;</span><br><span class="line">    | ID &#39;(&#39; &#39;)&#39; &#39;;&#39;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expr: ID &#39;(&#39; &#39;)&#39;</span><br><span class="line">    | INT</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>一般情况下要确保语法分析器能够选择唯一匹配的备选分支。不过当存在多个备选分支时，ANTLR 会选取备选分支中的第一条。比如本例中就会选择<code>expr &#39;;&#39;</code><br>如下存在词法歧义,begin 是一个关键字，同时也是一个标识符。<br>词法分析器会匹配最长字符串，如果输入文本 beginner 只会匹配上例中的 ID 这条词法规则。ANTLR 词法分析器不会把它匹配为关键字 BEGIN 后跟着标识符 ner</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BEGIN : &#39;begin&#39; ;</span><br><span class="line">ID    : [a-z]+ ;</span><br></pre></td></tr></table></figure>

<h2 id="语法分析树"><a href="#语法分析树" class="headerlink" title="语法分析树"></a>语法分析树</h2><p>语法分析树的建造过程：词法分析器处理字符序列并将生成的词法符号提供给语法分析器，语法分析器随即根据这些细信息来检查语法的正确性并建造出一颗语法分析树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharStream-&gt;(Lexer)-&gt;TokenStream-&gt;(Parser)-&gt;ParseTree(RuleNode子类+TerminalNode)</span><br></pre></td></tr></table></figure>

<p><img src="/images/antlr/2-2.png"><br><img src="/images/antlr/2-3.png"></p>
<p>ANTLR 使用共享数据结构节约内存，具体办法是：语法分析树中的叶子节点仅仅是盛放词法符号流中的词法符号的容器。每个词法符号都记录了自己在字符序列中的开始位置和结束位置，而非保存子字符串的拷贝。<br>ParseTree 有两个子类：RuleNode 的子类（非叶子） 和 TerminalNode（叶子）。 RuleNode 的子类包括：StatContext 和 ExprContext.Context 对象知道自己识别的词组中，开始和结束位置处的词法符号，同时提供访问该词组全部元素的方法比如 statContext 类有 ID（）和 expr()方法。有了这些方法，我们就可以遍历并操作树中节点。实际上遍历树的机制都是由 ANTLR 生成的代码</p>
<h2 id="语法分析树的访问-监听器、访问器"><a href="#语法分析树的访问-监听器、访问器" class="headerlink" title="语法分析树的访问-监听器、访问器"></a>语法分析树的访问-监听器、访问器</h2><p>为了构建一个语言类应用程序，语法分析器需要在遇到特定的输入语句、词组或者词法符号时触发特定的行为。这样的词组-&gt;行为的集合构成了我们的语言类应用程序，或者，至少担任了语法和外围程序间接口的角色。<br>监听器和访问器的区别在于，监听器方法不负责显示调用子节点的访问方法(visit())。访问器必须显式触发对子节点的访问，树的遍历过程才能正常进行，所以访问器可以控制访问的顺序以及节点被访问的次数。</p>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>ANTLR 提供了 ParseTree-Walker 类，自动遍历树然后生成事件并调用监听器。<br>每个语法文件都会生成一个 ParseTreeLisener 的子类，里面每个规则都有对应的 enter 方法和 exit 方法()，这些方法也称为”事件方法”。这些方法的入参是 ×××Context，提供该方法所需要的所有信息。监听器的操作逻辑在这些 enter 和 exit 方法内添加。下图显示了 ParseTreeWalker 对监听器方法的完整的调用顺序。<br><img src="/images/antlr/2-5.png"></p>
<h3 id="访问器"><a href="#访问器" class="headerlink" title="访问器"></a>访问器</h3><p>有时候我们希望手动控制遍历数的过程，通过显示的方法调用来访问子节点。在命令行中加入-visitor 选项可以指示 ANTLR 为一个语法生成访问器接口，语法中的每条规则对应接口中的一个 visit 方法。ANTRL 提供了访问器接口和一个默认实现类，这样我们自己只需要覆盖接口中我们感兴趣的方法。<br><img src="/images/antlr/2-6.png"></p>
<p>调用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ParseTree tree &#x3D; ...;&#x2F;&#x2F;语法分析数</span><br><span class="line">MyVisitor v &#x3D; new MyVisitor();&#x2F;&#x2F;访问器接口的实现类</span><br><span class="line">v.visit(tree);&#x2F;&#x2F;visitor访问tree</span><br></pre></td></tr></table></figure>

<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h3><p>文件 ArrayInit.g4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 语法文件通常以grammar关键字开头</span><br><span class="line"> *  这是一个名为ArrayInit的语法，它必须和文件名ArrayInit.g4相匹配</span><br><span class="line"> *&#x2F;</span><br><span class="line">grammar ArrayInit;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;一条名为init的规则，它匹配一对花括号中的、逗号分隔的value</span><br><span class="line">init: &#39;&#123;&#39; value (&#39;,&#39; value)* &#39;)&#39;; &#x2F;&#x2F;必须匹配至少一个value。其中*号用来修饰小括号里的内容，表示任意个。</span><br><span class="line">&#x2F;&#x2F; 一个value可以是嵌套的花括号结构，也可以是一个简单的整数，即INT词法符号</span><br><span class="line">value: init</span><br><span class="line">     | INIT</span><br><span class="line">     ;</span><br><span class="line">&#x2F;&#x2F;语法分析器的规则必须以小写字母开头，词法分析器的规则必须用大写字母开头</span><br><span class="line">INT： [0-9]+;  &#x2F;&#x2F;定义词法符号INT, 它由一个或多个数字组成</span><br><span class="line">WS: [\t\r\n]+ -&gt; skip;     &#x2F;&#x2F;定义词法规则“空白符号”，丢弃之。-&gt; skip表示跳过丢弃的意思。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ANTLR 对 g4 文件解析后，会生成如下文件:ArrayInitParser.java, ArrayInitLexer.java,ArrayInit.tokens,ArrayInitLexer.tokens,ArrayInitListener.java:ArrayBaseListener.java.<br>1 ArrayInitParser.java:对应语法 ArrayInit，每条规则对应里面一个方法。<br>2 ArrayInitLexer.java:用于识别词法规则和文法规则。它是通过 ANTLR 分析词法规则 INT 和 WS，以及语法中的字面值‘{’ ‘}‘ ‘,’生成的。<br>3 ArrrayInit.tokens: ANTLR 会给每个我们定义的词法付豪指定一个数字形式的类型，然后将他们的对应关系存储于该文件中。<br>4 ArrayInitListener.java 和 ArrayBaseListener.java: 在遍历 AST 时,遍历器能够触发一系列事件，并通知我们提供的监听器对象。ArrayInitListener 接口给出了这些回调方法的定义，ArrayBaseListener 是该接口的默认实现类，为其中的每个方法提供了一个空实现。</p>
<h3 id="ANTLR-语法基本标记"><a href="#ANTLR-语法基本标记" class="headerlink" title="ANTLR 语法基本标记"></a>ANTLR 语法基本标记</h3><ul>
<li>语法包含一系列描述语言结构的规则。这些规则既包括类似 stat 和 expr 的描述语法结构的规则，也包括描述标识符和整数之类的词汇符号的规则</li>
<li>语法分析器的规则以小写字母开头</li>
<li>词法分析器的规则以大写字母开头</li>
<li>我们使用|来分隔同一个语言规则的若干备选分支，使用圆括号把一些符号组合成自规则。例如，子规则(‘*‘|’/‘)匹配一个乘法符号或者触发符号。</li>
</ul>
<h3 id="左递归规则"><a href="#左递归规则" class="headerlink" title="左递归规则"></a>左递归规则</h3><p>含义：在某个备选分支的其实位置调用了自身。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr: INT|ID|&#39;(&#39;expr&#39;)&#39;</span><br></pre></td></tr></table></figure>

<h2 id="ANTLR-解析过程的异常处理"><a href="#ANTLR-解析过程的异常处理" class="headerlink" title="ANTLR 解析过程的异常处理"></a>ANTLR 解析过程的异常处理</h2><p>ANTLR 语法分析器能够自动报告语法错误并从错误中恢复继续工作。比如前一个错误的表达式，则输出错误信息。然后继续正确地解析第二个表达式。<br>ANTLR 的错误处理机制有很高的灵活性。我们可以修改输出的错误信息，捕获识别过程中的异常，甚至改变基本的异常处理策略。</p>
<h2 id="在语法和词法文件中添加动作"><a href="#在语法和词法文件中添加动作" class="headerlink" title="在语法和词法文件中添加动作"></a>在语法和词法文件中添加动作</h2><h3 id="定制语法分析"><a href="#定制语法分析" class="headerlink" title="定制语法分析"></a>定制语法分析</h3><ul>
<li>在语法中嵌入任意动作<br>我们创建一个构造器，这样我们就能传入希望提取的列号；另外，我们需要在 row 规则的”(…)+”循环中放置一些动作。<br>下面的例子，是将输入文本中的指定列显示出来。<br>详细的内容，会在第 10 章。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">grammar Rows;</span><br><span class="line"></span><br><span class="line">@parser::members &#123; &#x2F;&#x2F; add members to generated RowsParser</span><br><span class="line">    int col;</span><br><span class="line">    public RowsParser(TokenStream input, int col) &#123; &#x2F;&#x2F; custom constructor</span><br><span class="line">        this(input);</span><br><span class="line">        this.col &#x3D; col;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file: (row NL)+ ;</span><br><span class="line"></span><br><span class="line">row</span><br><span class="line">locals [int i&#x3D;0]</span><br><span class="line">    : (   STUFF</span><br><span class="line">          &#123;</span><br><span class="line">          $i++;</span><br><span class="line">          if ( $i &#x3D;&#x3D; col ) System.out.println($STUFF.text);</span><br><span class="line">          &#125;</span><br><span class="line">      )+</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">TAB  :  &#39;\t&#39; -&gt; skip ;   &#x2F;&#x2F; match but don&#39;t pass to the parser</span><br><span class="line">NL   :  &#39;\r&#39;? &#39;\n&#39; ;     &#x2F;&#x2F; match and pass to the parser</span><br><span class="line">STUFF:  ~[\t\r\n]+ ;     &#x2F;&#x2F; match any chars except tab, newline</span><br></pre></td></tr></table></figure>

<ul>
<li>使用语义判定改变语法分析过程(第 11 章)<br>下面的语法用来处理一组整数”2 9 10 3 1 2 3”。第一个数字 2 代表接下来匹配两个数组 9 和 10。紧接着数字 3 告诉我们匹配接下来的三个数字。<br>我们的目标是创建一份名为 Data 的语法，将 9 和 10 分为一组，然后 1,2,3 分为一组。<br>Data 语法的关键在于一段动作，它的值是布尔类型的，称为一个语义判定:{$i&lt;=$n&gt;}?。它的值在匹配到 n 个输入整数之前保持为 true,其中 n 是 sequence<br>语法中的参数。当语义判定的值为 false 时，对应的备选分支就从语法中“消失”了，因此，它也就从生成的语法分析器中“消失”了。在本例中，语义判定的值为 false 使得”(…)*“循环终止，从 sequence 规则返回。<br><img src="/images/antlr/4-4.png"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">grammar Data;</span><br><span class="line"></span><br><span class="line">file : group+ ;</span><br><span class="line"></span><br><span class="line">group: INT sequence[$INT.int] ;</span><br><span class="line"></span><br><span class="line">sequence[int n]</span><br><span class="line">locals [int i &#x3D; 1;]</span><br><span class="line">     : ( &#123;$i&lt;&#x3D;$n&#125;? INT &#123;$i++;&#125; )* &#x2F;&#x2F; match n integers</span><br><span class="line">     ;</span><br><span class="line"></span><br><span class="line">INT :   [0-9]+ ;             &#x2F;&#x2F; match integers</span><br><span class="line">WS  :   [ \t\n\r]+ -&gt; skip ; &#x2F;&#x2F; toss out all whitespace</span><br></pre></td></tr></table></figure>

<h3 id="定制词法分析"><a href="#定制词法分析" class="headerlink" title="定制词法分析"></a>定制词法分析</h3><ul>
<li>孤岛语法:处理想吐文件中的不同格式<br>mode INSIDE 定义模式，INSIDE 模式用于识别 XML 标签，默认模式用于识别标签之外的文本。<br>-&gt;定义了动作进入到 INSIDE 模式下<br>-&gt;定义了动作 popMode，从 INSIDE 模式下退出。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">lexer grammar XMLLexer;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Default &quot;mode&quot;: Everything OUTSIDE of a tag</span><br><span class="line">OPEN        :   &#39;&lt;&#39;                 -&gt; pushMode(INSIDE) ;</span><br><span class="line">COMMENT     :   &#39;&lt;!--&#39; .*? &#39;--&gt;&#39;    -&gt; skip ;</span><br><span class="line">EntityRef   :   &#39;&amp;&#39; [a-z]+ &#39;;&#39; ;</span><br><span class="line">TEXT        :   ~(&#39;&lt;&#39;|&#39;&amp;&#39;)+ ;           &#x2F;&#x2F; match any 16 bit char minus &lt; and &amp;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------------- Everything INSIDE of a tag ---------------------</span><br><span class="line">mode INSIDE;</span><br><span class="line"></span><br><span class="line">CLOSE       :   &#39;&gt;&#39;                 -&gt; popMode ; &#x2F;&#x2F; back to default mode</span><br><span class="line">SLASH_CLOSE :   &#39;&#x2F;&gt;&#39;                -&gt; popMode ;</span><br><span class="line">EQUALS      :   &#39;&#x3D;&#39; ;</span><br><span class="line">STRING      :   &#39;&quot;&#39; .*? &#39;&quot;&#39; ;</span><br><span class="line">SlashName   :   &#39;&#x2F;&#39; Name ;</span><br><span class="line">Name        :   ALPHA (ALPHA|DIGIT)* ;</span><br><span class="line">S           :   [ \t\r\n]           -&gt; skip ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">ALPHA       :   [a-zA-Z] ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">DIGIT       :   [0-9] ;</span><br></pre></td></tr></table></figure>

<ul>
<li>重写输入流<br>TokenStreamRewriter 对象可以改写输入的 TokenStream。关键之处，TokenStreamRewriter 对象实际上修改的是词法符号流的“视图”而非词法符号<br>流本身。它认为所有对修改方法的调用都只是一个“指令”，然后将这些修改放入一个队列；在未来词法符号流被重新渲染为文本时，这些修改才会被执行。<br>在每次我们调用 getText()的时候，rewriter 对象都会执行上述队列中的指令。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class InsertSerialIDListener extends JavaBaseListener &#123;</span><br><span class="line">    TokenStreamRewriter rewriter;</span><br><span class="line">    public InsertSerialIDListener(TokenStream tokens) &#123;</span><br><span class="line">        rewriter &#x3D; new TokenStreamRewriter(tokens);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void enterClassBody(JavaParser.ClassBodyContext ctx) &#123;</span><br><span class="line">        String field &#x3D; &quot;\n\tpublic static final long serialVersionUID &#x3D; 1L;&quot;;</span><br><span class="line">        rewriter.insertAfter(ctx.start, field);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将词法符号送入不同通道<br>忽略却保留注释和空白字符的秘诀是将这些词法符号送入一个“隐藏通道”。语法分析器只处理一个通道，因此我们可以将希望保留的词法符号送入其他通道内。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COMMENT</span><br><span class="line">    :   &#39;&#x2F;*&#39; .*? &#39;*&#x2F;&#39;    -&gt; channel(HIDDEN) &#x2F;&#x2F; match anything between &#x2F;* and *&#x2F;</span><br><span class="line">    ;</span><br><span class="line">WS  :   [ \r\t\u000C\n]+ -&gt; channel(HIDDEN)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<h2 id="将生成的语法分析器与-Java-程序集成，并使用监听器遍历处理"><a href="#将生成的语法分析器与-Java-程序集成，并使用监听器遍历处理" class="headerlink" title="将生成的语法分析器与 Java 程序集成，并使用监听器遍历处理"></a>将生成的语法分析器与 Java 程序集成，并使用监听器遍历处理</h2><h3 id="例子-1-1"><a href="#例子-1-1" class="headerlink" title="例子 1"></a>例子 1</h3><p>Test.java<br>此例子的目标是将 Java 中，类似{99, 3, 451}的 short 数组翻译成”\u0063\u0003\u01c3”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import org.antlr.v4.runtime.*;</span><br><span class="line">import org.antlr.v4.runtime.tree.*;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">    public static void amin(String[] args) throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;新建一个CharStream，从标准输入读取数据</span><br><span class="line">        ANTLRInputStream input &#x3D; new ANTLRInputStream(System.in);</span><br><span class="line">        &#x2F;&#x2F;新建一个词法分析器，处理输入的CharStream</span><br><span class="line">        ArrayInitLexer lexer - new ArrayInitLexer(input);</span><br><span class="line">        &#x2F;&#x2F;新建一个词法符号的缓冲区，用于存储词法分析器将生成的词法符号</span><br><span class="line">        CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">        &#x2F;&#x2F;新建一个语法分析器，处理词法符号缓冲区中的内容</span><br><span class="line">        ArrayInitParser parser &#x3D; new ArrayInitParser(tokens);</span><br><span class="line">        ParseTree tree &#x3D; parser.init(); &#x2F;&#x2F;针对init规则，开始语法分析。因为init规则是这些规则中根规则，所以适合从init开始分析</span><br><span class="line">        &#x2F;*System.out.println(tree.toStringTree(parser));&#x2F;&#x2F;用LISP风格打印生成的树*&#x2F;</span><br><span class="line">        &#x2F;&#x2F;新建一个通用的、能够触发回调函数的语法分析树遍历器</span><br><span class="line">        ParseTreeWalker walker &#x3D; new ParseTreeWalker();</span><br><span class="line">        &#x2F;&#x2F;遍历语法分析过程中生成的语法分析树，触发回调</span><br><span class="line">        walker.walk(new ShortToUnicodeString(), tree);</span><br><span class="line">        System.out.println();&#x2F;&#x2F;翻译完成后，打印一个\n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ShortToUnicodeString.java<br>当遍历 AST 的时候，会对监听器里的方法进行回调。ArrayInitBaseListener 实现了 ArrayInitListener 接口的每个方法，我们只需要继承 ArrayInitBaseListener 并重写自己感兴趣的方法，就可以达到目的。ShortToUnicodeString 中的方法将翻译输入数据的一部分并将结果打印出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将类似&#123;1,2,3&#125;的short数组初始化语句翻译为&quot;\u0001\u0002\u0003&quot;</span><br><span class="line">public class ShortToUnicodeString extends ArrayInitBaseListener &#123;</span><br><span class="line">    &#x2F;&#x2F;将&#123;翻译为&quot;</span><br><span class="line">    @Override</span><br><span class="line">    public void enterInit(ArrayInitParser.InitContext ctx)&#123;</span><br><span class="line">        System.out.print(&#39;&quot;&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;将&#125;翻译为&quot;</span><br><span class="line">    @Override</span><br><span class="line">    public void exitInit(ArrayInitParser.InitContext ctx)&#123;</span><br><span class="line">        System.out.print(&#39;&quot;&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;将每个整数翻译为四位的十六进制形式，然后加前缀\u</span><br><span class="line">    @Override</span><br><span class="line">    public void enterValue(ArrrayInitParser.ValueContext ctx) &#123;</span><br><span class="line">        &#x2F;&#x2F;假定不存在嵌套结构</span><br><span class="line">        int value &#x3D; Integer.valueOf(ctx.INT().getText());&#x2F;&#x2F;ctx是value的上下文对象，它获取INT词法符号对应的整数值。</span><br><span class="line">        System.out.printf(&quot;\\u%04x&quot;, value);&#x2F;&#x2F;输出16进制数，总共占4为，前面的空位补0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h3><p>LibExpr.g4<br>此例子用来展示，将语法词法规则分布到多个不同文件中。<br>使用 import 功能，可以将一个大的语法文件分隔成小的，然后 import 导入连到一起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">grammar LibExpr;         &#x2F;&#x2F; Rename to distinguish from original</span><br><span class="line">import CommonLexerRules; &#x2F;&#x2F; includes all rules from CommonLexerRules.g4</span><br><span class="line">&#x2F;** The start rule; begin parsing here. *&#x2F;</span><br><span class="line">prog:   stat+ ;</span><br><span class="line"></span><br><span class="line">stat:   expr NEWLINE</span><br><span class="line">    |   ID &#39;&#x3D;&#39; expr NEWLINE</span><br><span class="line">    |   NEWLINE</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expr:   expr (&#39;*&#39;|&#39;&#x2F;&#39;) expr &#x2F;&#x2F;左递归</span><br><span class="line">    |   expr (&#39;+&#39;|&#39;-&#39;) expr</span><br><span class="line">    |   INT</span><br><span class="line">    |   ID</span><br><span class="line">    |   &#39;(&#39; expr &#39;)&#39;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>CommonLexerRules.g4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lexer grammar CommonLexerRules; &#x2F;&#x2F; note &quot;lexer grammar&quot;</span><br><span class="line"></span><br><span class="line">ID  :   [a-zA-Z]+ ;      &#x2F;&#x2F; match identifiers</span><br><span class="line">INT :   [0-9]+ ;         &#x2F;&#x2F; match integers</span><br><span class="line">NEWLINE:&#39;\r&#39;? &#39;\n&#39; ;     &#x2F;&#x2F; return newlines to parser (end-statement signal)</span><br><span class="line">WS  :   [ \t]+ -&gt; skip ; &#x2F;&#x2F; toss out whitespace. &#39;-&gt; skip&#39;是丢弃操作。</span><br></pre></td></tr></table></figure>

<p>ExprJoyRide.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import org.antlr.v4.runtime.*;</span><br><span class="line">import org.antlr.v4.runtime.tree.*;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">public class ExprJoyRide &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;新建输入流</span><br><span class="line">        String inputFile &#x3D; null;</span><br><span class="line">        if ( args.length&gt;0 ) inputFile &#x3D; args[0];</span><br><span class="line">        InputStream is &#x3D; System.in;</span><br><span class="line">        if ( inputFile!&#x3D;null ) is &#x3D; new FileInputStream(inputFile);</span><br><span class="line">        ANTLRInputStream input &#x3D; new ANTLRInputStream(is);</span><br><span class="line">        &#x2F;&#x2F;新建词法分析器和语法分析器</span><br><span class="line">        ExprLexer lexer &#x3D; new ExprLexer(input);</span><br><span class="line">        CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">        ExprParser parser &#x3D; new ExprParser(tokens);</span><br><span class="line">        &#x2F;&#x2F;启动语法分析器开始解析</span><br><span class="line">        ParseTree tree &#x3D; parser.prog();</span><br><span class="line">        &#x2F;&#x2F;用文本形式将该规则方法prog()返回的语法分析树打印出来</span><br><span class="line">        System.out.println(tree.toStringTree(parser));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例子-3-访问器"><a href="#例子-3-访问器" class="headerlink" title="例子 3 访问器"></a>例子 3 访问器</h3><p>LabeledExpr.g4<br>为每个备选分支定义一个标签，标签以#开头。这样 ANTLR 会为每个备选分支生成不同的访问器方法。这样我们就可以对每种输入都获得一个不同的事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">grammar LabeledExpr; &#x2F;&#x2F; rename to distinguish from Expr.g4</span><br><span class="line"></span><br><span class="line">prog:   stat+ ;</span><br><span class="line"></span><br><span class="line">stat:   expr NEWLINE                # printExpr</span><br><span class="line">    |   ID &#39;&#x3D;&#39; expr NEWLINE         # assign</span><br><span class="line">    |   NEWLINE                     # blank</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expr:   expr op&#x3D;(&#39;*&#39;|&#39;&#x2F;&#39;) expr      # MulDiv</span><br><span class="line">    |   expr op&#x3D;(&#39;+&#39;|&#39;-&#39;) expr      # AddSub</span><br><span class="line">    |   INT                         # int</span><br><span class="line">    |   ID                          # id</span><br><span class="line">    |   &#39;(&#39; expr &#39;)&#39;                # parens</span><br><span class="line">    ;</span><br><span class="line">&#x2F;&#x2F;接下来我们为运算符词法付豪定义一些名字，这样在随后的访问器中，我们就可以将这些词法符号的名字当做JAVA常量来引用。</span><br><span class="line">MUL :   &#39;*&#39; ; &#x2F;&#x2F; assigns token name to &#39;*&#39; used above in grammar</span><br><span class="line">DIV :   &#39;&#x2F;&#39; ;</span><br><span class="line">ADD :   &#39;+&#39; ;</span><br><span class="line">SUB :   &#39;-&#39; ;</span><br><span class="line">ID  :   [a-zA-Z]+ ;      &#x2F;&#x2F; match identifiers</span><br><span class="line">INT :   [0-9]+ ;         &#x2F;&#x2F; match integers</span><br><span class="line">NEWLINE:&#39;\r&#39;? &#39;\n&#39; ;     &#x2F;&#x2F; return newlines to parser (is end-statement signal)</span><br><span class="line">WS  :   [ \t]+ -&gt; skip ; &#x2F;&#x2F; toss out whitespace</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Calc &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        String inputFile &#x3D; null;</span><br><span class="line">        if ( args.length&gt;0 ) inputFile &#x3D; args[0];</span><br><span class="line">        InputStream is &#x3D; System.in;</span><br><span class="line">        if ( inputFile!&#x3D;null ) is &#x3D; new FileInputStream(inputFile);</span><br><span class="line">        ANTLRInputStream input &#x3D; new ANTLRInputStream(is);</span><br><span class="line">        LabeledExprLexer lexer &#x3D; new LabeledExprLexer(input);</span><br><span class="line">        CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">        LabeledExprParser parser &#x3D; new LabeledExprParser(tokens);</span><br><span class="line">        ParseTree tree &#x3D; parser.prog(); &#x2F;&#x2F; parse</span><br><span class="line">        &#x2F;&#x2F;实例化一个自定义的访问器，然后访问tree</span><br><span class="line">        EvalVisitor eval &#x3D; new EvalVisitor();</span><br><span class="line">        eval.visit(tree);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用如下命令可以生成 visitor<br><code>antlr4 -no-listener -visitor LabeledExpr.g4</code><br>可以生成，LabeledExprBaseVisitor.java,LabeledExprParse.java,LabeledExprLexer.java,LabeledExprVisitor.java。<br>LabeledExprVisitor 是接口，LabeledExprBaseVisitor 是默认实现类。我们可以继承 LabeledExprBaseVisitor 然后重写里面的函数来实现自定义的逻辑。<br>EvalVisitor 内重写的方法对应备选分支的标签。里面引用的 JAVA 常量如：MUL，DIV 等。也是在语法文件中定义的词法符号名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class EvalVisitor extends LabeledExprBaseVisitor&lt;Integer&gt; &#123;</span><br><span class="line">    &#x2F;** &quot;memory&quot; for our calculator; variable&#x2F;value pairs go here *&#x2F;</span><br><span class="line">    Map&lt;String, Integer&gt; memory &#x3D; new HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;** ID &#39;&#x3D;&#39; expr NEWLINE *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitAssign(LabeledExprParser.AssignContext ctx) &#123;</span><br><span class="line">        String id &#x3D; ctx.ID().getText();  &#x2F;&#x2F; id is left-hand side of &#39;&#x3D;&#39;</span><br><span class="line">        int value &#x3D; visit(ctx.expr());   &#x2F;&#x2F; compute value of expression on right</span><br><span class="line">        memory.put(id, value);           &#x2F;&#x2F; store it in our memory</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** expr NEWLINE *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitPrintExpr(LabeledExprParser.PrintExprContext ctx) &#123;</span><br><span class="line">        Integer value &#x3D; visit(ctx.expr()); &#x2F;&#x2F; evaluate the expr child</span><br><span class="line">        System.out.println(value);         &#x2F;&#x2F; print the result</span><br><span class="line">        return 0;                          &#x2F;&#x2F; return dummy value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** INT *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitInt(LabeledExprParser.IntContext ctx) &#123;</span><br><span class="line">        return Integer.valueOf(ctx.INT().getText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** ID *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitId(LabeledExprParser.IdContext ctx) &#123;</span><br><span class="line">        String id &#x3D; ctx.ID().getText();</span><br><span class="line">        if ( memory.containsKey(id) ) return memory.get(id);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** expr op&#x3D;(&#39;*&#39;|&#39;&#x2F;&#39;) expr *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitMulDiv(LabeledExprParser.MulDivContext ctx) &#123;</span><br><span class="line">        int left &#x3D; visit(ctx.expr(0));  &#x2F;&#x2F; get value of left subexpression</span><br><span class="line">        int right &#x3D; visit(ctx.expr(1)); &#x2F;&#x2F; get value of right subexpression</span><br><span class="line">        if ( ctx.op.getType() &#x3D;&#x3D; LabeledExprParser.MUL ) return left * right;</span><br><span class="line">        return left &#x2F; right; &#x2F;&#x2F; must be DIV</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** expr op&#x3D;(&#39;+&#39;|&#39;-&#39;) expr *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitAddSub(LabeledExprParser.AddSubContext ctx) &#123;</span><br><span class="line">        int left &#x3D; visit(ctx.expr(0));  &#x2F;&#x2F; get value of left subexpression</span><br><span class="line">        int right &#x3D; visit(ctx.expr(1)); &#x2F;&#x2F; get value of right subexpression</span><br><span class="line">        if ( ctx.op.getType() &#x3D;&#x3D; LabeledExprParser.ADD ) return left + right;</span><br><span class="line">        return left - right; &#x2F;&#x2F; must be SUB</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** &#39;(&#39; expr &#39;)&#39; *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer visitParens(LabeledExprParser.ParensContext ctx) &#123;</span><br><span class="line">        return visit(ctx.expr()); &#x2F;&#x2F; return child expr&#39;s value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子 4"></a>例子 4</h3><p>使用监听器来对 java 语法进行分析，根据实现类可以生成对应的接口定义，并保留注释<br>Java.g4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">classDeclaration</span><br><span class="line">    :   &#39;class&#39; Identifier typeParameters? (&#39;extends&#39; type)?</span><br><span class="line">        (&#39;implements&#39; typeList)?</span><br><span class="line">        classBody</span><br><span class="line">    ;</span><br><span class="line">methodDeclaration</span><br><span class="line">    :   type Identifier formalParameters (&#39;[&#39; &#39;]&#39;)* methodDeclarationRest</span><br><span class="line">    |   &#39;void&#39; Identifier formalParameters methodDeclarationRest</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>ExtractInterfaceListener.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ExtractInterfaceListener extends JavaBaseListener &#123;</span><br><span class="line">    JavaParser parser;</span><br><span class="line">    public ExtractInterfaceListener(JavaParser parser) &#123;this.parser &#x3D; parser;&#125;</span><br><span class="line">    &#x2F;** Listen to matches of classDeclaration *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void enterClassDeclaration(JavaParser.ClassDeclarationContext ctx)&#123;</span><br><span class="line">        System.out.println(&quot;interface I&quot;+ctx.Identifier()+&quot; &#123;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void exitClassDeclaration(JavaParser.ClassDeclarationContext ctx) &#123;</span><br><span class="line">        System.out.println(&quot;&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Listen to matches of methodDeclaration *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void enterMethodDeclaration(</span><br><span class="line">        JavaParser.MethodDeclarationContext ctx</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; need parser to get tokens</span><br><span class="line">        TokenStream tokens &#x3D; parser.getTokenStream();</span><br><span class="line">        String type &#x3D; &quot;void&quot;;&#x2F;&#x2F;type为方法的返回类型</span><br><span class="line">        if ( ctx.type()!&#x3D;null ) &#123;</span><br><span class="line">            type &#x3D; tokens.getText(ctx.type());</span><br><span class="line">        &#125;</span><br><span class="line">        String args &#x3D; tokens.getText(ctx.formalParameters());&#x2F;&#x2F;args是入参</span><br><span class="line">        System.out.println(&quot;\t&quot;+type+&quot; &quot;+ctx.Identifier()+args+&quot;;&quot;);&#x2F;&#x2F;ctx.Identifier()是方法名</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ExtractInterfaceTool.java<br>将自定义的监听器集成到程序里，并遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ExtractInterfaceTool &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        String inputFile &#x3D; null;</span><br><span class="line">        if ( args.length&gt;0 ) inputFile &#x3D; args[0];</span><br><span class="line">        InputStream is &#x3D; System.in;</span><br><span class="line">        if ( inputFile!&#x3D;null ) &#123;</span><br><span class="line">            is &#x3D; new FileInputStream(inputFile);</span><br><span class="line">        &#125;</span><br><span class="line">        ANTLRInputStream input &#x3D; new ANTLRInputStream(is);</span><br><span class="line"></span><br><span class="line">        JavaLexer lexer &#x3D; new JavaLexer(input);</span><br><span class="line">        CommonTokenStream tokens &#x3D; new CommonTokenStream(lexer);</span><br><span class="line">        JavaParser parser &#x3D; new JavaParser(tokens);</span><br><span class="line">        ParseTree tree &#x3D; parser.compilationUnit(); &#x2F;&#x2F; parse。开始语法分析的过程</span><br><span class="line"></span><br><span class="line">        ParseTreeWalker walker &#x3D; new ParseTreeWalker(); &#x2F;&#x2F; create standard walker，新建一个标准的遍历器</span><br><span class="line">        ExtractInterfaceListener extractor &#x3D; new ExtractInterfaceListener(parser);</span><br><span class="line">        walker.walk(extractor, tree); &#x2F;&#x2F; initiate walk of tree with listener，使用监听器初始化对语法分析树的遍历</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/13/%E6%B1%87%E7%BC%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/13/%E6%B1%87%E7%BC%96/" class="post-title-link" itemprop="url">汇编</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-13 16:00:00 / Modified: 15:15:19" itemprop="dateCreated datePublished" datetime="2020-12-13T16:00:00+08:00">2020-12-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="“被调用者保存”和“调用者保存”寄存器"><a href="#“被调用者保存”和“调用者保存”寄存器" class="headerlink" title="“被调用者保存”和“调用者保存”寄存器"></a>“被调用者保存”和“调用者保存”寄存器</h2><p>编译器的设计中有个概念叫做“被调用者保存”和“调用者保存”，可以近似的按子函数保存和父函数保存对应来理解，这一概念的出现完全是由于寄存器资源个数有限造成的。当父函数在调用子函数时，由于子函数可能访问到父函数用于保存数值的寄存器，为了互不干扰和造成覆盖，编译器就制定了相应的规则，%eax、%edx 和%ecx 被划分为“调用者保存”寄存器，顾名思义，这些寄存器上面存储的值，需要调用者（父函数）自己想办法先备份好，否则过会子函数直接使用这些寄存器时将无情的覆盖。如何备份？当然是事先压入栈中，等子函数调用完，再通过出栈恢复这些寄存器原本在父函数运行时的旧值；另外三个寄存器%ebx、%esi、%edi 被划分为“被调用者保存”寄存器，同样的，这些寄存器上有值，在使用前需要被调用者（子函数）自己想办法帮调用者（父函数）进行备份，具体方法就是子函数在覆盖他们之前，先进行入栈备份，等子函数返回时，再出栈还原父函数运行时这些寄存器上的旧值。</p>
<h2 id="七种寻址方式"><a href="#七种寻址方式" class="headerlink" title="七种寻址方式"></a>七种寻址方式</h2><h3 id="1-立即寻址方式"><a href="#1-立即寻址方式" class="headerlink" title="1 立即寻址方式"></a>1 立即寻址方式</h3><p>操作数作为指令的一部分而直接写在指令中，这种操作数称为立即数，这种寻址方式也就称为立即数寻址方式。</p>
<p>立即数可以是 8 位、16 位或 32 位，该数值紧跟在操作码之后。如果立即数为 16 位或 32 位，那么，它将按“高高低低”的原则进行存储。例如：</p>
<p>MOV AH, 80H 　　　 ADD AX, 1234H 　　　 MOV ECX, 123456H<br>MOV B1, 12H 　　　 MOV W1, 3456H 　　 ADD D1, 32123456H</p>
<p>其中：B1、W1 和 D1 分别是字节、字和双字单元。</p>
<p>以上指令中的第二操作数都是立即数，在汇编语言中，规定：立即数不能作为指令中的第二操作数。该规定与高级语言中“赋值语句的左边不能是常量”的规定相一致。</p>
<p>立即数寻址方式通常用于对通用寄存器或内存单元赋初值。图是指令“MOV AX, 4576H”存储形式和执行示意图。</p>
<h3 id="2-寄存器寻址方式"><a href="#2-寄存器寻址方式" class="headerlink" title="2 寄存器寻址方式"></a>2 寄存器寻址方式</h3><p>指令所要的操作数已存储在某寄存器中，或把目标操作数存入寄存器。把在指令中指出所使用寄存器(即：寄存器的助忆符)的寻址方式称为寄存器寻址方式。<br>指令中可以引用的寄存器及其符号名称如下：<br>　　 8 位寄存器有：AH、AL、BH、BL、CH、CL、DH 和 DL 等；<br>　　 16 位寄存器有：AX、BX、CX、DX、SI、DI、SP、BP 和段寄存器等；<br>　　 32 位寄存器有：EAX、EBX、ECX、EDX、ESI、EDI、ESP 和 EBP 等。<br>寄存器寻址方式是一种简单快捷的寻址方式，源和目的操作数都可以是寄存器。</p>
<p>1、源操作数是寄存器寻址方式<br>　　如：ADD VARD, EAX 　　 ADD VARW, AX 　　　 MOV VARB, BH 等。<br>　　其中：VARD、VARW 和 VARB 是双字，字和字节类型的内存变量。在第 4 章将会学到如何定义它们。</p>
<p>2、目的操作数是寄存器寻址方式<br>　　如：ADD BH, 78h 　　　　 ADD AX, 1234h 　　　 MOV EBX, 12345678H 等。</p>
<p>3、源和目的操作数都是寄存器寻址方式<br>　　如：MOV EAX, EBX 　　　 MOV AX, BX 　　　　 MOV DH, BL 等。</p>
<p>由于指令所需的操作数已存储在寄存器中，或操作的结果存入寄存器，这样，在指令执行过程中，会减少读/写存储器单元的次数，所以，使用寄存器寻址方式的指令具有较快的执行速度。通常情况下，我们提倡在编写汇编语言程序时，应尽可能地使用寄存器寻址方式，但也不要把它绝对化。</p>
<h3 id="3-七种寻址方式-直接寻址方式"><a href="#3-七种寻址方式-直接寻址方式" class="headerlink" title="3 七种寻址方式(直接寻址方式)"></a>3 七种寻址方式(直接寻址方式)</h3><p>指令所要的操作数存放在内存中，在指令中直接给出该操作数的有效地址，这种寻址方式为直接寻址方式。</p>
<p>在通常情况下，操作数存放在数据段中，所以，其物理地址将由数据段寄存器 DS 和指令中给出的有效地址直接形成，但如果使用段超越前缀，那么，操作数可存放在其它段。</p>
<p>例：假设有指令：MOV BX, [1234H]，在执行时，(DS)=2000H，内存单元 21234H 的值为 5213H。问该指令执行后，BX 的值是什么？</p>
<p>解：根据直接寻址方式的寻址规则，把该指令的具体执行过程用下图来表示。</p>
<p>从图中，可看出执行该指令要分三部分：</p>
<p>由于 1234H 是一个直接地址，它紧跟在指令的操作码之后，随取指令而被读出；</p>
<p>访问数据段的段寄存器是 DS，所以，用 DS 的值和偏移量 1234H 相加，得存储单元的物理地址：21234H；</p>
<p>取单元 21234H 的值 5213H，并按“高高低低”的原则存入寄存器 BX 中。</p>
<p>所以，在执行该指令后，BX 的值就为 5213H。</p>
<p>由于数据段的段寄存器默认为 DS，如果要指定访问其它段内的数据，可在指令中用段前缀的方式显式地书写出来。</p>
<p>下面指令的目标操作数就是带有段前缀的直接寻址方式。</p>
<p>MOV 　 ES:[1000H], AX</p>
<p>直接寻址方式常用于处理内存单元的数据，其操作数是内存变量的值，该寻址方式可在 64K 字节的段内进行寻址。</p>
<p>注意：立即寻址方式和直接寻址方式的书写格式的不同，直接寻址的地址要写在括号“[”，“]”内。在程序中，直接地址通常用内存变量名来表示，如：MOV BX, VARW，其中，VARW 是内存字变量。</p>
<p>试比较下列指令中源操作数的寻址方式(VARW 是内存字变量)：<br>　　 MOV 　 AX, 1234H MOV 　 AX, [1234H] ;前者是立即寻址，后者是直接寻址<br>　　 MOV 　 AX, VARW MOV 　 AX, [VARW] ;两者是等效的，均为直接寻址</p>
<h3 id="4-七种寻址方式-寄存器间接寻址方式"><a href="#4-七种寻址方式-寄存器间接寻址方式" class="headerlink" title="4 七种寻址方式(寄存器间接寻址方式)"></a>4 七种寻址方式(寄存器间接寻址方式)</h3><p>操作数在存储器中，操作数的有效地址用 SI、DI、BX 和 BP 等四个寄存器之一来指定，称这种寻址方式为寄存器间接寻址方式。该寻址方式物理地址的计算方法如下：</p>
<p>寄存器间接寻址方式读取存储单元的原理如图所示。</p>
<p>在不使用段超越前缀的情况下，有下列规定：</p>
<p>若有效地址用 SI、DI 和 BX 等之一来指定，则其缺省的段寄存器为 DS；<br>若有效地址用 BP 来指定，则其缺省的段寄存器为 SS(即：堆栈段)。</p>
<p>例:假设有指令：MOV BX,[DI]，在执行时，(DS)=1000H，(DI)=2345H，存储单元 12345H 的内容是 4354H。问执行指令后，BX 的值是什么？</p>
<p>解：根据寄存器间接寻址方式的规则，在执行本例指令时，寄存器 DI 的值不是操作数，而是操作数的地址。该操作数的物理地址应由 DS 和 DI 的值形成，即：</p>
<p>PA=(DS)<em>16+DI=1000H</em>16+2345H=12345H。</p>
<p>所以，该指令的执行效果是：把从物理地址为 12345H 开始的一个字的值传送给 BX。</p>
<p>其执行过程如图所示。</p>
<h3 id="5-七种寻址方式（寄存器相对寻址方式）"><a href="#5-七种寻址方式（寄存器相对寻址方式）" class="headerlink" title="5 七种寻址方式（寄存器相对寻址方式）"></a>5 七种寻址方式（寄存器相对寻址方式）</h3><p>操作数在存储器中，其有效地址是一个基址寄存器(BX、BP)或变址寄存器(SI、D</p>
<p>I)的内容和指令中的 8 位/16 位偏移量之和。其有效地址的计算公式如公式所示。</p>
<p>在不使用段超越前缀的情况下，有下列规定：</p>
<pre><code>若有效地址用SI、DI和BX等之一来指定，则其缺省的段寄存器为DS；

若有效地址用BP来指定，则其缺省的段寄存器为SS。</code></pre>
<p>指令中给出的 8 位/16 位偏移量用补码表示。在计算有效地址时，如果偏移量是 8 位，则进行符号扩展成 16 位。当所得的有效地址超过 0FFFFH，则取其 64K 的模。</p>
<p>例:假设指令：MOV BX, [SI+100H]，在执行它时，(DS)=1000H，(SI)=2345H，内存单元 12445H 的内容为 2715H，问该指令执行后，BX 的值是什么？</p>
<p>解：根据寄存器相对寻址方式的规则，在执行本例指令时，源操作数的有效地址 EA 为：</p>
<p>EA=(SI)+100H=2345H+100H=2445H</p>
<p>该操作数的物理地址应由 DS 和 EA 的值形成，即：</p>
<p>PA=(DS)<em>16+EA=1000H</em>16+2445H=12445H。</p>
<p>所以，该指令的执行效果是：把从物理地址为 12445H 开始的一个字的值传送给 BX。</p>
<p>其执行过程如图所示。</p>
<h3 id="6-七种寻址方式-基址加变址寻址方式"><a href="#6-七种寻址方式-基址加变址寻址方式" class="headerlink" title="6 七种寻址方式(基址加变址寻址方式)"></a>6 七种寻址方式(基址加变址寻址方式)</h3><p>操作数在存储器中，其有效地址是一个基址寄存器(BX、BP)和一个变址寄存器(SI、DI)的内容之和。其有效地址的计算公式如公式所示。</p>
<p>在不使用段超越前缀的情况下，规定：如果有效地址中含有 BP，则缺省的段寄存器为 SS；否则，缺省的段寄存器为 DS。</p>
<p>例:假设指令：MOV BX, [BX+SI]，在执行时，(DS)=1000H，(BX)=2100H，(SI)=0011H，内存单元 12111H 的内容为 1234H。问该指令执行后，BX 的值是什么？</p>
<p>解：根据基址加变址寻址方式的规则，在执行本例指令时，源操作数的有效地址 EA 为：</p>
<p>EA=(BX)+(SI)=2100H+0011H=2111H</p>
<p>该操作数的物理地址应由 DS 和 EA 的值形成，即：</p>
<p>PA=(DS)<em>16+EA=1000H</em>16+2111H=12111H</p>
<p>所以，该指令的执行效果是：把从物理地址为 12111H 开始的一个字的值传送给 BX。</p>
<p>其执行过程如图所示。</p>
<h3 id="7-七种寻址方式-相对基址加变址寻址方式"><a href="#7-七种寻址方式-相对基址加变址寻址方式" class="headerlink" title="7 七种寻址方式(相对基址加变址寻址方式)"></a>7 七种寻址方式(相对基址加变址寻址方式)</h3><p>操作数在存储器中，其有效地址是一个基址寄存器(BX、BP)的值、一个变址寄存器(SI、DI)的值和指令中的 8 位/16 位偏移量之和。其有效地址的计算公式如公式所示。</p>
<p>在不使用段超越前缀的情况下，规定：如果有效地址中含有 BP，则其缺省的段寄存器为 SS；否则，其缺省的段寄存器为 DS。</p>
<p>指令中给出的 8 位/16 位偏移量用补码表示。在计算有效地址时，如果偏移量是 8 位，则进行符号扩展成 16 位。当所得的有效地址超过 0FFFFH，则取其 64K 的模。</p>
<p>例:假设指令：MOV AX, [BX+SI+200H]，在执行时，(DS)=1000H，(BX)=2100H，(SI)=0010H，内存单元 12310H 的内容为 1234H。问该指令执行后，AX 的值是什么？</p>
<p>解：根据相对基址加变址寻址方式的规则，在执行本例指令时，源操作数的有效地址 EA 为：</p>
<p>EA=(BX)+(SI)+200H=2100H+0010H+200H=2310H</p>
<p>该操作数的物理地址应由 DS 和 EA 的值形成，即：</p>
<p>PA=(DS)<em>16+EA=1000H</em>16+2310H=12310H</p>
<p>所以，该指令的执行效果是：把从物理地址为 12310H 开始的一个字的值传送给 AX。其执行过程如图所示。</p>
<p>从相对基址加变址这种寻址方式来看，由于它的可变因素较多，看起来就显得复杂些，但正因为其可变因素多，它的灵活性也就很高。比如：</p>
<p>用 D1[i]来访问一维数组 D1 的第 i 个元素，它的寻址有一个自由度，用 D2[i][j]来访问二维数组 D2 的第 i 行、第 j 列的元素，其寻址有二个自由度。多一个可变的量，其寻址方式的灵活度也就相应提高了。</p>
<p>相对基址加变址寻址方式有多种等价的书写方式，下面的书写格式都是正确的，并且其寻址含义也是一致的。</p>
<p>MOV 　 AX, [BX+SI+1000H]　　　 MOV 　 AX, 1000H[BX+SI]<br>MOV 　 AX, 1000H[BX][si]　　　 MOV 　 AX, 1000H[SI][bx]</p>
<p>但书写格式 BX [1000+SI]和 SI[1000H+BX]等是错误的，即所用寄存器不能在“[“，”]”之外，该限制对寄存器相对寻址方式的书写也同样起作用。</p>
<p>相对基址加变址寻址方式是以上 7 种寻址方式中最复杂的一种寻址方式，它可变形为其它类型的存储器寻址方式。下表列举出该寻址方式与其它寻址方式之间的变形关系。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
