<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/page/3/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'default'
  };
</script>
<title>Hexo</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/29/gRPC%E5%92%8CProtobuf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/29/gRPC%E5%92%8CProtobuf/" class="post-title-link" itemprop="url">gRPC和Protobuf</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-29 21:00:00" itemprop="dateCreated datePublished" datetime="2020-12-29T21:00:00+08:00">2020-12-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-31 14:06:44" itemprop="dateModified" datetime="2020-12-31T14:06:44+08:00">2020-12-31</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="gRPC-是什么？"><a href="#gRPC-是什么？" class="headerlink" title="gRPC 是什么？"></a>gRPC 是什么？</h1><p>参考 <a target="_blank" rel="noopener" href="http://doc.oschina.net/grpc?t=58008">http://doc.oschina.net/grpc?t=58008</a><br>在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。<br><img src="/images/grpc-protobuf/grpc1.png"><br>gRPC 客户端和服务端可以在多种环境中运行和交互 - 从 google 内部的服务器到你自己的笔记本，并且可以用任何 gRPC 支持的语言来编写。所以，你可以很容易地用 Java 创建一个 gRPC 服务端，用 Go、Python、Ruby 来创建客户端。</p>
<h1 id="使用-protocol-buffers"><a href="#使用-protocol-buffers" class="headerlink" title="使用 protocol buffers"></a>使用 protocol buffers</h1><p>gRPC 默认使用 protocol buffers，这是 Google 开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如 JSON）。正如你将在下方例子里所看到的，你用 proto files 创建 gRPC 服务，用 protocol buffers 消息类型来定义方法参数和返回类型。</p>
<h2 id="protobuf-定义服务，JAVA-实现"><a href="#protobuf-定义服务，JAVA-实现" class="headerlink" title="protobuf 定义服务，JAVA 实现"></a>protobuf 定义服务，JAVA 实现</h2><p>protobuf 的详细用法<a target="_blank" rel="noopener" href="https://blog.51cto.com/9291927/2331980">https://blog.51cto.com/9291927/2331980</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option java_package &#x3D; &quot;io.grpc.examples&quot;;</span><br><span class="line"></span><br><span class="line">package helloworld;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The greeter service definition.</span><br><span class="line">service Greeter &#123;</span><br><span class="line">  &#x2F;&#x2F; Sends a greeting</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The request message containing the user&#39;s name.</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The response message containing the greetings</span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  string message &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编译-protobuf-生成服务端接口和客户端存根"><a href="#编译-protobuf-生成服务端接口和客户端存根" class="headerlink" title="编译 protobuf 生成服务端接口和客户端存根"></a>编译 protobuf 生成服务端接口和客户端存根</h3><p>一旦定义好服务，我们可以使用 protocol buffer 编译器 protoc 来生成创建应用所需的特定客户端和服务端的代码 - 你可以生成任意 gRPC 支持的语言的代码，当然 PHP 和 Objective-C 仅支持创建客户端代码。生成的代码同时包括客户端的存根和服务端要实现的抽象接口，均包含 Greeter 所定义的方法。<br>以下类包含所有我们需要创建这个例子所有的代码：</p>
<ul>
<li>HelloRequest.java， HelloResponse.java 和其他文件包含所有 protocol buffer 用来填充、序列化和提取 HelloRequest 和 HelloReply 消息类型的代码。</li>
<li>GreeterGrpc.java， 包含 (还有其他有用的代码)：<br>Greeter 服务端需要实现的接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static interface Greeter &#123;</span><br><span class="line">    public void sayHello(Helloworld.HelloRequest request,</span><br><span class="line">    StreamObserver&lt;HelloReply&gt; responseObserver);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>客户端用来与 Greeter 服务端进行对话的 存根 类。就像你所看到的，异步存根也实现了 Greeter 接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static class GreeterStub extends AbstractStub&lt;GreeterStub&gt;</span><br><span class="line">    implements Greeter &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="写一个服务器"><a href="#写一个服务器" class="headerlink" title="写一个服务器"></a>写一个服务器</h3><p>现在让我们写点代码！首先我们将创建一个服务应用来实现服务</p>
<h4 id="服务实现"><a href="#服务实现" class="headerlink" title="服务实现"></a>服务实现</h4><p>GreeterImpl.java 准确地实现了 Greeter 服务所需要的行为。<br>正如你所见，GreeterImpl 类通过实现 sayHello 方法，实现了从 IDL 生成的 GreeterGrpc.Greeter 接口 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public  static GreeterImpl impliment Greeter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello(HelloRequest req, StreamObserver&lt;HelloReply&gt; responseObserver) &#123;</span><br><span class="line">    HelloReply reply &#x3D; HelloReply.newBuilder().setMessage(&quot;Hello &quot; + req.getName()).build();</span><br><span class="line">    responseObserver.onNext(reply);</span><br><span class="line">    responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sayHello 有两个参数：</p>
<ul>
<li>HelloRequest，请求。</li>
<li>StreamObserver<HelloReply>： 应答观察者，一个特殊的接口，服务器用应答来调用它。</HelloReply></li>
</ul>
<p>为了返回给客户端应答并且完成调用：</p>
<ul>
<li>用我们的激动人心的消息构建并填充一个在我们接口定义的 HelloReply 应答对象。</li>
<li>将 HelloReply 返回给客户端，然后表明我们已经完成了对 RPC 的处理。</li>
</ul>
<h4 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h4><p>需要提供一个 gRPC 服务的另一个主要功能是让这个服务实在在网络上可用。<br>HelloWorldServer.java 提供了以下代码作为 Java 的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* The port on which the server should run *&#x2F;</span><br><span class="line">private int port &#x3D; 50051;</span><br><span class="line">private Server server;</span><br><span class="line">private void start() throws Exception &#123;</span><br><span class="line">    server &#x3D; ServerBuilder.forPort(port)</span><br><span class="line">        .addService(GreeterGrpc.bindService(new GreeterImpl()))</span><br><span class="line">        .build()</span><br><span class="line">        .start();</span><br><span class="line">    logger.info(&quot;Server started, listening on &quot; + port);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(new Thread() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; Use stderr here since the logger may has been reset by its JVM shutdown hook.</span><br><span class="line">        System.err.println(&quot;*** shutting down gRPC server since JVM is shutting down&quot;);</span><br><span class="line">        HelloWorldServer.this.stop();</span><br><span class="line">        System.err.println(&quot;*** server shut down&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h4><p>客户端的 gRPC 非常简单。在这一步，我们将用生成的代码写一个简单的客户程序来访问我们在上一节里创建的 Greeter 服务器。<br>首先我们看一下我们如何连接 Greeter 服务器。我们需要创建一个 gRPC 频道，指定我们要连接的主机名和服务器端口。然后我们用这个频道创建存根实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final ManagedChannel channel;</span><br><span class="line">private final GreeterGrpc.GreeterBlockingStub blockingStub;</span><br><span class="line">public HelloWorldClient(String host, int port) &#123;</span><br><span class="line">    channel &#x3D; ManagedChannelBuilder.forAddress(host, port)</span><br><span class="line">        .usePlaintext(true)</span><br><span class="line">        .build();</span><br><span class="line">    blockingStub &#x3D; GreeterGrpc.newBlockingStub(channel);</span><br><span class="line">    HelloRequest req &#x3D; HelloRequest.newBuilder().setName(name).build();</span><br><span class="line">    HelloReply reply &#x3D; blockingStub.sayHello(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子里，我们创建了一个阻塞的存根。这意味着 RPC 调用要等待服务器应答，将会返回一个应答或抛出一个异常。 gRPC Java 还可以有其他种类的存根，可以向服务器发出非阻塞的调用，这种情况下应答是异步返回的。</p>
<ul>
<li>我们创建并填充一个 HelloRequest 发送给服务。</li>
<li>我们用请求调用存根的 SayHello()，如果 RPC 成功，会得到一个填充的 HelloReply ，从其中我们可以获得 greeting。</li>
</ul>
<h1 id="gRPC-进阶"><a href="#gRPC-进阶" class="headerlink" title="gRPC 进阶"></a>gRPC 进阶</h1><h2 id="在-protobuf-中定义服务"><a href="#在-protobuf-中定义服务" class="headerlink" title="在 protobuf 中定义服务"></a>在 protobuf 中定义服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option java_multiple_files &#x3D; true;</span><br><span class="line">option java_package &#x3D; &quot;io.grpc.examples.routeguide&quot;; &#x2F;&#x2F;指定java文件中的package包名</span><br><span class="line">option java_outer_classname &#x3D; &quot;RouteGuideProto&quot;;</span><br><span class="line">option objc_class_prefix &#x3D; &quot;RTG&quot;;</span><br><span class="line"></span><br><span class="line">package routeguide;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Interface exported by the server.</span><br><span class="line">service RouteGuide &#123;&#x2F;&#x2F;service用于指定服务，定义rpc方法，指定请求和相应类型</span><br><span class="line">  &#x2F;&#x2F;一个 简单 RPC ， 客户端使用存根发送请求到服务器并等待响应返回，就像平常的函数调用一样。</span><br><span class="line">  rpc GetFeature(Point) returns (Feature) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一个 服务器端流式 RPC ， 客户端发送请求到服务器，拿到一个流去读取返回的消息序列。 客户端读取返回的流，直到里面没有任何消息。从例子中可以看出，通过在 响应 类型前插入 stream 关键字，可以指定一个服务器端的流方法。</span><br><span class="line">  rpc ListFeatures(Rectangle) returns (stream Feature) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一个 客户端流式 RPC ， 客户端写入一个消息序列并将其发送到服务器，同样也是使用流。一旦 客户端完成写入消息，它等待服务器完成读取返回它的响应。通过在 请求 类型前指定 stream 关键字来指定一个客户端的流方法。</span><br><span class="line">  rpc RecordRoute(stream Point) returns (RouteSummary) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一个 双向流式 RPC 是双方使用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务器 可以以任意喜欢的顺序读写：比如， 服务器可以在写入响应前等待接收所有的客户端消息，或者可以交替 的读取和写入消息，或者其他读写的组合。 每个流中的消息顺序被预留。你可以通过在请求和响应前加 stream 关键字去制定方法的类型。</span><br><span class="line">  rpc RouteChat(stream RouteNote) returns (stream RouteNote) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">我们的 .proto 文件也包含了所有请求的 protocol buffer 消息类型定义以及在服务方法中使用的响</span><br><span class="line">应类型——比如，下面的Point消息类型：</span><br><span class="line">&#x2F;&#x2F; Points are represented as latitude-longitude pairs in the E7 representation</span><br><span class="line">&#x2F;&#x2F; (degrees multiplied by 10**7 and rounded to the nearest integer).</span><br><span class="line">&#x2F;&#x2F; Latitudes should be in the range +&#x2F;- 90 degrees and longitude should be in</span><br><span class="line">&#x2F;&#x2F; the range +&#x2F;- 180 degrees (inclusive).</span><br><span class="line">message Point &#123;</span><br><span class="line">  int32 latitude &#x3D; 1;</span><br><span class="line">  int32 longitude &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A latitude-longitude rectangle, represented as two diagonally opposite</span><br><span class="line">&#x2F;&#x2F; points &quot;lo&quot; and &quot;hi&quot;.</span><br><span class="line">message Rectangle &#123;</span><br><span class="line">  &#x2F;&#x2F; One corner of the rectangle.</span><br><span class="line">  Point lo &#x3D; 1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The other corner of the rectangle.</span><br><span class="line">  Point hi &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A feature names something at a given point.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; If a feature could not be named, the name is empty.</span><br><span class="line">message Feature &#123;</span><br><span class="line">  &#x2F;&#x2F; The name of the feature.</span><br><span class="line">  string name &#x3D; 1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The point where the feature is detected.</span><br><span class="line">  Point location &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Not used in the RPC.  Instead, this is here for the form serialized to disk.</span><br><span class="line">message FeatureDatabase &#123;</span><br><span class="line">  repeated Feature feature &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A RouteNote is a message sent while at a given point.</span><br><span class="line">message RouteNote &#123;</span><br><span class="line">  &#x2F;&#x2F; The location from which the message is sent.</span><br><span class="line">  Point location &#x3D; 1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The message to be sent.</span><br><span class="line">  string message &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A RouteSummary is received in response to a RecordRoute rpc.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; It contains the number of individual points received, the number of</span><br><span class="line">&#x2F;&#x2F; detected features, and the total distance covered as the cumulative sum of</span><br><span class="line">&#x2F;&#x2F; the distance between each point.</span><br><span class="line">message RouteSummary &#123;</span><br><span class="line">  &#x2F;&#x2F; The number of points received.</span><br><span class="line">  int32 point_count &#x3D; 1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The number of known features passed while traversing the route.</span><br><span class="line">  int32 feature_count &#x3D; 2;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The distance covered in metres.</span><br><span class="line">  int32 distance &#x3D; 3;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The duration of the traversal in seconds.</span><br><span class="line">  int32 elapsed_time &#x3D; 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成客户端和服务端代码"><a href="#生成客户端和服务端代码" class="headerlink" title="生成客户端和服务端代码"></a>生成客户端和服务端代码</h2><p>接下来我们需要从 .proto 的服务定义中生成 gRPC 客户端和服务器端的接口。我们通过 protocol buffer 的编译器 protoc 以及一个特殊的 gRPC Java 插件来完成。为了生成 gRPC 服务，你必须使用 proto3 编译器。<br>下面的类都是从我们的服务定义中生成：</p>
<ul>
<li>包含了所有填充，序列化以及获取请求和应答的消息类型的 Feature.java，Point.java， Rectangle.java 以及其它类文件。</li>
<li>RouteGuideGrpc.java 文件包含（以及其它一些有用的代码）：<ul>
<li>RouteGuide 服务器要实现的一个接口 RouteGuideGrpc.RouteGuide，其中所有的方法都定 义在 RouteGuide 服务中。</li>
<li>客户端可以用来和 RouteGuide 服务器交互的 存根 类。 异步的存根也实现了 RouteGuide 接口。</li>
</ul>
</li>
</ul>
<h2 id="创建服务器"><a href="#创建服务器" class="headerlink" title="创建服务器"></a>创建服务器</h2><p>让 RouteGuide 服务工作有两个部分：</p>
<ul>
<li>实现我们服务定义的生成的服务接口：做我们的服务的实际的“工作”。</li>
<li>运行一个 gRPC 服务器，监听来自客户端的请求并返回服务的响应。</li>
</ul>
<h3 id="实现-RouteGuide"><a href="#实现-RouteGuide" class="headerlink" title="实现 RouteGuide"></a>实现 RouteGuide</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line">public class RouteGuideServer &#123;</span><br><span class="line">  private static final Logger logger &#x3D; Logger.getLogger(RouteGuideServer.class.getName());</span><br><span class="line"></span><br><span class="line">  private final int port;</span><br><span class="line">  private final Server server;</span><br><span class="line"></span><br><span class="line">  public RouteGuideServer(int port) throws IOException &#123;</span><br><span class="line">    this(port, RouteGuideUtil.getDefaultFeaturesFile());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Create a RouteGuide server listening on &#123;@code port&#125; using &#123;@code featureFile&#125; database. *&#x2F;</span><br><span class="line">  public RouteGuideServer(int port, URL featureFile) throws IOException &#123;</span><br><span class="line">    this(ServerBuilder.forPort(port), port, RouteGuideUtil.parseFeatures(featureFile));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Create a RouteGuide server using serverBuilder as a base and features as data. *&#x2F;</span><br><span class="line">  public RouteGuideServer(ServerBuilder&lt;?&gt; serverBuilder, int port, Collection&lt;Feature&gt; features) &#123;</span><br><span class="line">    this.port &#x3D; port;</span><br><span class="line">    server &#x3D; serverBuilder.addService(new RouteGuideService(features))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Start serving requests. *&#x2F;</span><br><span class="line">  public void start() throws IOException &#123;</span><br><span class="line">    server.start();</span><br><span class="line">    logger.info(&quot;Server started, listening on &quot; + port);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(new Thread() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; Use stderr here since the logger may have been reset by its JVM shutdown hook.</span><br><span class="line">        System.err.println(&quot;*** shutting down gRPC server since JVM is shutting down&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">          RouteGuideServer.this.stop();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(&quot;*** server shut down&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Stop serving requests and shutdown resources. *&#x2F;</span><br><span class="line">  public void stop() throws InterruptedException &#123;</span><br><span class="line">    if (server !&#x3D; null) &#123;</span><br><span class="line">      server.shutdown().awaitTermination(30, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Await termination on the main thread since the grpc library uses daemon threads.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  private void blockUntilShutdown() throws InterruptedException &#123;</span><br><span class="line">    if (server !&#x3D; null) &#123;</span><br><span class="line">      server.awaitTermination();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Main method.  This comment makes the linter happy.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    RouteGuideServer server &#x3D; new RouteGuideServer(8980);</span><br><span class="line">    server.start();</span><br><span class="line">    server.blockUntilShutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 我们的服务器有一个实现了生成的 RouteGuideGrpc.Service 接口的 RouteGuideService 类：</span><br><span class="line">   *</span><br><span class="line">   * &lt;p&gt;See route_guide.proto for details of the methods.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  private static class RouteGuideService extends RouteGuideGrpc.RouteGuideImplBase &#123;</span><br><span class="line">    private final Collection&lt;Feature&gt; features;</span><br><span class="line">    private final ConcurrentMap&lt;Point, List&lt;RouteNote&gt;&gt; routeNotes &#x3D;</span><br><span class="line">        new ConcurrentHashMap&lt;Point, List&lt;RouteNote&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    RouteGuideService(Collection&lt;Feature&gt; features) &#123;</span><br><span class="line">      this.features &#x3D; features;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 简单 RPC</span><br><span class="line">     * 1. 如在我们的服务定义中指定的那样，我们组织并填充一个 Feature 应答对象返回给客户端。在这个 例子中，我们通过一个单独的私有方法checkFeature()来实现。</span><br><span class="line">     * 2. 我们使用应答观察者的 onNext() 方法返回 Feature。</span><br><span class="line">     * 3. 我们使用应答观察者的 onCompleted() 方法来指出我们已经完成了和 RPC的交互。</span><br><span class="line">     * @param request the requested location for the feature. 请求</span><br><span class="line">     * @param responseObserver the observer that will receive the feature at the requested point.一个应答的观察者，实际上是服务器调用它应答的一个特殊接口。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void getFeature(Point request, StreamObserver&lt;Feature&gt; responseObserver) &#123;</span><br><span class="line">      responseObserver.onNext(checkFeature(request));</span><br><span class="line">      responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 服务器端流式 RPC</span><br><span class="line">     * 这次我们得到了需要返回给客户端的足够多的 Feature 对象（在这个场景下，我们根据他们是否在我们的 Rectangle 请求中，从服务的特性集合中选择他们），并且使用 onNext() 方法轮流往响应观察* 者写入。最后，和简单 RPC 的例子一样，我们使用响应观察者的 onCompleted() 方法去告诉 gRPC 写入应答已完成。</span><br><span class="line">     * @param request the bounding rectangle for the requested features.</span><br><span class="line">     * @param responseObserver the observer that will receive the features.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void listFeatures(Rectangle request, StreamObserver&lt;Feature&gt; responseObserver) &#123;</span><br><span class="line">      int left &#x3D; min(request.getLo().getLongitude(), request.getHi().getLongitude());</span><br><span class="line">      int right &#x3D; max(request.getLo().getLongitude(), request.getHi().getLongitude());</span><br><span class="line">      int top &#x3D; max(request.getLo().getLatitude(), request.getHi().getLatitude());</span><br><span class="line">      int bottom &#x3D; min(request.getLo().getLatitude(), request.getHi().getLatitude());</span><br><span class="line"></span><br><span class="line">      for (Feature feature : features) &#123;</span><br><span class="line">        if (!RouteGuideUtil.exists(feature)) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int lat &#x3D; feature.getLocation().getLatitude();</span><br><span class="line">        int lon &#x3D; feature.getLocation().getLongitude();</span><br><span class="line">        if (lon &gt;&#x3D; left &amp;&amp; lon &lt;&#x3D; right &amp;&amp; lat &gt;&#x3D; bottom &amp;&amp; lat &lt;&#x3D; top) &#123;</span><br><span class="line">          responseObserver.onNext(feature);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 客户端流式 RPC</span><br><span class="line">     * 如你所见，我们的方法和前面的方法类型相似，拿到一个 StreamObserver 应答观察者参数，但是这次它返回一个 StreamObserver 以便客户端写入它的 Point。</span><br><span class="line">     * 在这个方法体中，我们返回了一个匿名 StreamObserver 实例，其中我们：</span><br><span class="line">     * 覆写了 onNext() 方法，每次客户端写入一个 Point 到消息流时，拿到特性和其它信息。</span><br><span class="line">     * 覆写了 onCompleted() 方法（在 客户端 结束写入消息时调用），用来填充和构建我们的 RouteSummary。然后我们用 RouteSummary 调用方法自己的的响应观察者的 onNext()，之后调用它的 onCompleted() 方法，结束服务器端的调用。</span><br><span class="line">     *</span><br><span class="line">     * @param responseObserver an observer to receive the response summary.</span><br><span class="line">     * @return an observer to receive the requested route points.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public StreamObserver&lt;Point&gt; recordRoute(final StreamObserver&lt;RouteSummary&gt; responseObserver) &#123;</span><br><span class="line">      return new StreamObserver&lt;Point&gt;() &#123;</span><br><span class="line">        int pointCount;</span><br><span class="line">        int featureCount;</span><br><span class="line">        int distance;</span><br><span class="line">        Point previous;</span><br><span class="line">        final long startTime &#x3D; System.nanoTime();</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(Point point) &#123;</span><br><span class="line">          pointCount++;</span><br><span class="line">          if (RouteGuideUtil.exists(checkFeature(point))) &#123;</span><br><span class="line">            featureCount++;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; For each point after the first, add the incremental distance from the previous point to</span><br><span class="line">          &#x2F;&#x2F; the total distance value.</span><br><span class="line">          if (previous !&#x3D; null) &#123;</span><br><span class="line">            distance +&#x3D; calcDistance(previous, point);</span><br><span class="line">          &#125;</span><br><span class="line">          previous &#x3D; point;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable t) &#123;</span><br><span class="line">          logger.log(Level.WARNING, &quot;recordRoute cancelled&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line">          long seconds &#x3D; NANOSECONDS.toSeconds(System.nanoTime() - startTime);</span><br><span class="line">          responseObserver.onNext(RouteSummary.newBuilder().setPointCount(pointCount)</span><br><span class="line">              .setFeatureCount(featureCount).setDistance(distance)</span><br><span class="line">              .setElapsedTime((int) seconds).build());</span><br><span class="line">          responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 双向流式RPC(与客户端流的差别主要是在responseObserver.onNext()方法的调用位置，这个调用位置位于onNext()方法中。而客户端流是在onComplete()方法中，意味着需要把客户端流处理完成后，才能调用onNext方法处理并立即结束。)</span><br><span class="line">     * 和我们的客户端流的例子一样，我们拿到和返回一个 StreamObserver 应答观察者，除了这次我们在客户端仍然写入消息到 它们的 消息流时通过我们方法的应答观察者返回值。这里读写的语法和客户端流以及服务器流方法一样。虽然每一端都会按照它们写入的顺序拿到另一端的消息，客户端和服务器都可以任意顺序读写——流的操作是互不依赖的。</span><br><span class="line">     *</span><br><span class="line">     * @param responseObserver an observer to receive the stream of previous messages.</span><br><span class="line">     * @return an observer to handle requested message&#x2F;location pairs.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public StreamObserver&lt;RouteNote&gt; routeChat(final StreamObserver&lt;RouteNote&gt; responseObserver) &#123;</span><br><span class="line">      return new StreamObserver&lt;RouteNote&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(RouteNote note) &#123;</span><br><span class="line">          List&lt;RouteNote&gt; notes &#x3D; getOrCreateNotes(note.getLocation());</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; Respond with all previous notes at this location.</span><br><span class="line">          for (RouteNote prevNote : notes.toArray(new RouteNote[0])) &#123;</span><br><span class="line">            responseObserver.onNext(prevNote);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; Now add the new note to the list</span><br><span class="line">          notes.add(note);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable t) &#123;</span><br><span class="line">          logger.log(Level.WARNING, &quot;routeChat cancelled&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line">          responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Get the notes list for the given location. If missing, create it.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private List&lt;RouteNote&gt; getOrCreateNotes(Point location) &#123;</span><br><span class="line">      List&lt;RouteNote&gt; notes &#x3D; Collections.synchronizedList(new ArrayList&lt;RouteNote&gt;());</span><br><span class="line">      List&lt;RouteNote&gt; prevNotes &#x3D; routeNotes.putIfAbsent(location, notes);</span><br><span class="line">      return prevNotes !&#x3D; null ? prevNotes : notes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Gets the feature at the given point.</span><br><span class="line">     *</span><br><span class="line">     * @param location the location to check.</span><br><span class="line">     * @return The feature object at the point. Note that an empty name indicates no feature.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Feature checkFeature(Point location) &#123;</span><br><span class="line">      for (Feature feature : features) &#123;</span><br><span class="line">        if (feature.getLocation().getLatitude() &#x3D;&#x3D; location.getLatitude()</span><br><span class="line">            &amp;&amp; feature.getLocation().getLongitude() &#x3D;&#x3D; location.getLongitude()) &#123;</span><br><span class="line">          return feature;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; No feature was found, return an unnamed feature.</span><br><span class="line">      return Feature.newBuilder().setName(&quot;&quot;).setLocation(location).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Calculate the distance between two points using the &quot;haversine&quot; formula.</span><br><span class="line">     * The formula is based on http:&#x2F;&#x2F;mathforum.org&#x2F;library&#x2F;drmath&#x2F;view&#x2F;51879.html.</span><br><span class="line">     *</span><br><span class="line">     * @param start The starting point</span><br><span class="line">     * @param end The end point</span><br><span class="line">     * @return The distance between the points in meters</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static int calcDistance(Point start, Point end) &#123;</span><br><span class="line">      int r &#x3D; 6371000; &#x2F;&#x2F; earth radius in meters</span><br><span class="line">      double lat1 &#x3D; toRadians(RouteGuideUtil.getLatitude(start));</span><br><span class="line">      double lat2 &#x3D; toRadians(RouteGuideUtil.getLatitude(end));</span><br><span class="line">      double lon1 &#x3D; toRadians(RouteGuideUtil.getLongitude(start));</span><br><span class="line">      double lon2 &#x3D; toRadians(RouteGuideUtil.getLongitude(end));</span><br><span class="line">      double deltaLat &#x3D; lat2 - lat1;</span><br><span class="line">      double deltaLon &#x3D; lon2 - lon1;</span><br><span class="line"></span><br><span class="line">      double a &#x3D; sin(deltaLat &#x2F; 2) * sin(deltaLat &#x2F; 2)</span><br><span class="line">          + cos(lat1) * cos(lat2) * sin(deltaLon &#x2F; 2) * sin(deltaLon &#x2F; 2);</span><br><span class="line">      double c &#x3D; 2 * atan2(sqrt(a), sqrt(1 - a));</span><br><span class="line"></span><br><span class="line">      return (int) (r * c);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">  gRpcServer &#x3D; NettyServerBuilder.forPort(port)</span><br><span class="line">      .addService(RouteGuideGrpc.bindService(new RouteGuideService(features)))</span><br><span class="line">      .build().start();</span><br><span class="line">  logger.info(&quot;Server started, listening on &quot; + port);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了做到这个，我们需要：</p>
<ul>
<li>创建我们服务实现类 RouteGuideService 的一个实例并且将其传给生成的 RouteGuideGrpc 类的静态方法 bindService() 去获得服务定义。</li>
<li>使用生成器的 forPort() 方法指定地址以及期望客户端请求监听的端口。</li>
<li>通过传入将 bindService() 返回的服务定义，用生成器注册我们的服务实现到生成器的 addService() 方法。</li>
<li>调用生成器上的 build() 和 start() 方法为我们的服务创建和启动一个 RPC 服务器。</li>
</ul>
<h2 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h2><h3 id="创建存根"><a href="#创建存根" class="headerlink" title="创建存根"></a>创建存根</h3><p>为了调用服务方法，我们需要首先创建一个 存根，或者两个存根：</p>
<ul>
<li>一个 阻塞/同步 存根：这意味着 RPC 调用等待服务器响应，并且要么返回应答，要么造成异常。</li>
<li>一个 非阻塞/异步 存根可以向服务器发起非阻塞调用，应答会异步返回。你可以使用异步存根去发起特定类型的流式调用。</li>
</ul>
<p>我们首先为存根创建一个 gRPC channel，指明服务器地址和我们想连接的端口号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel &#x3D; NettyChannelBuilder.forAddress(host, port)</span><br><span class="line">       .negotiationType(NegotiationType.PLAINTEXT)</span><br><span class="line">       .build();</span><br></pre></td></tr></table></figure>

<p>如你所见，我们用一个 NettyServerBuilder 构建和启动服务器。这个服务器的生成器基于 Netty 传输框架。<br>我们使用 Netty 传输框架，所以我们用一个 NettyServerBuilder 启动服务器。<br>现在我们可以通过从 .proto 中生成的 RouteGuideGrpc 类的 newStub 和 newBlockingStub 方法，使用频道去创建我们的存根。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blockingStub &#x3D; RouteGuideGrpc.newBlockingStub(channel);</span><br><span class="line">asyncStub &#x3D; RouteGuideGrpc.newStub(channel);</span><br></pre></td></tr></table></figure>

<h3 id="调用服务方法"><a href="#调用服务方法" class="headerlink" title="调用服务方法"></a>调用服务方法</h3><h4 id="简单-RPC"><a href="#简单-RPC" class="headerlink" title="简单 RPC"></a>简单 RPC</h4><p>在阻塞存根上调用简单 RPC GetFeature 几乎是和调用一个本地方法一样直观。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point request &#x3D; Point.newBuilder().setLatitude(lat).setLongitude(lon).build();</span><br><span class="line">Feature feature &#x3D; blockingStub.getFeature(request);</span><br></pre></td></tr></table></figure>

<p>我们创建和填充了一个请求 protocol buffer 对象（在这个场景下是 Point），在我们的阻塞存根上将其传给 getFeature() 方法，拿回一个 Feature。</p>
<h4 id="服务器端流式-RPC"><a href="#服务器端流式-RPC" class="headerlink" title="服务器端流式 RPC"></a>服务器端流式 RPC</h4><p>接下来，让我们看一个对于 ListFeatures 的服务器端流式调用，这个调用会返回一个地理性的 Feature 流：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rectangle request &#x3D;</span><br><span class="line">    Rectangle.newBuilder()</span><br><span class="line">        .setLo(Point.newBuilder().setLatitude(lowLat).setLongitude(lowLon).build())</span><br><span class="line">        .setHi(Point.newBuilder().setLatitude(hiLat).setLongitude(hiLon).build()).build();</span><br><span class="line">Iterator&lt;Feature&gt; features &#x3D; blockingStub.listFeatures(request);</span><br></pre></td></tr></table></figure>

<p>如你所见，这和我们刚看过的简单 RPC 很相似，除了方法返回客户端用来读取所有返回的 Feature 的 一个 Iterator，而不是单个的 Feature。</p>
<h4 id="客户端流式-RPC"><a href="#客户端流式-RPC" class="headerlink" title="客户端流式 RPC"></a>客户端流式 RPC</h4><p>现在看看稍微复杂点的东西：我们在客户端流方法 RecordRoute 中发送了一个 Point 流给服务器并且拿到一个 RouteSummary。为了这个方法，我们需要使用异步存根。如果你已经阅读了<br>创建服务器，一些部分看起来很相近——异步流式 RPC 是在两端通过相似的方式实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public void recordRoute(List&lt;Feature&gt; features, int numPoints) throws Exception &#123;</span><br><span class="line">    info(&quot;*** RecordRoute&quot;);</span><br><span class="line">    final SettableFuture&lt;Void&gt; finishFuture &#x3D; SettableFuture.create();</span><br><span class="line">    StreamObserver&lt;RouteSummary&gt; responseObserver &#x3D; new StreamObserver&lt;RouteSummary&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onNext(RouteSummary summary) &#123;</span><br><span class="line">        info(&quot;Finished trip with &#123;0&#125; points. Passed &#123;1&#125; features. &quot;</span><br><span class="line">            + &quot;Travelled &#123;2&#125; meters. It took &#123;3&#125; seconds.&quot;, summary.getPointCount(),</span><br><span class="line">            summary.getFeatureCount(), summary.getDistance(), summary.getElapsedTime());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void onError(Throwable t) &#123;</span><br><span class="line">        finishFuture.setException(t);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void onCompleted() &#123;</span><br><span class="line">        finishFuture.set(null);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    StreamObserver&lt;Point&gt; requestObserver &#x3D; asyncStub.recordRoute(responseObserver);</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; Send numPoints points randomly selected from the features list.</span><br><span class="line">      StringBuilder numMsg &#x3D; new StringBuilder();</span><br><span class="line">      Random rand &#x3D; new Random();</span><br><span class="line">      for (int i &#x3D; 0; i &lt; numPoints; ++i) &#123;</span><br><span class="line">        int index &#x3D; rand.nextInt(features.size());</span><br><span class="line">        Point point &#x3D; features.get(index).getLocation();</span><br><span class="line">        info(&quot;Visiting point &#123;0&#125;, &#123;1&#125;&quot;, RouteGuideUtil.getLatitude(point),</span><br><span class="line">            RouteGuideUtil.getLongitude(point));</span><br><span class="line">        requestObserver.onNext(point);</span><br><span class="line">        &#x2F;&#x2F; Sleep for a bit before sending the next one.</span><br><span class="line">        Thread.sleep(rand.nextInt(1000) + 500);</span><br><span class="line">        if (finishFuture.isDone()) &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      info(numMsg.toString());</span><br><span class="line">      requestObserver.onCompleted();</span><br><span class="line"></span><br><span class="line">      finishFuture.get();</span><br><span class="line">      info(&quot;Finished RecordRoute&quot;);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      requestObserver.onError(e);</span><br><span class="line">      logger.log(Level.WARNING, &quot;RecordRoute Failed&quot;, e);</span><br><span class="line">      throw e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，为了调用这个方法我们需要创建一个 StreamObserver，它为了服务器用它的 RouteSummary 应答实现了一个特殊的接口。在 StreamObserver 中，我们：</p>
<p>覆写了 onNext() 方法，在服务器把 RouteSummary 写入到消息流时，打印出返回的信息。<br>覆写了 onCompleted() 方法（在 服务器 完成自己的调用时调用）去设置 SettableFuture，这样我们可以检查服务器是不是完成写入。<br>之后，我们将 StreamObserver 传给异步存根的 recordRoute() 方法，拿到我们自己的 StreamObserver 请求观察者将 Point 发给服务器。一旦完成点的写入，我们使用请求观察者的 onCompleted() 方法告诉 gRPC 我们已经完成了客户端的写入。一旦完成，我们就检查 SettableFuture 验证服务器是否已经完成写入。</p>
<h4 id="双向流式-RPC"><a href="#双向流式-RPC" class="headerlink" title="双向流式 RPC"></a>双向流式 RPC</h4><p>最后，让我们看看双向流式 RPC RouteChat()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void routeChat() throws Exception &#123;</span><br><span class="line">    info(&quot;*** RoutChat&quot;);</span><br><span class="line">    final SettableFuture&lt;Void&gt; finishFuture &#x3D; SettableFuture.create();</span><br><span class="line">    StreamObserver&lt;RouteNote&gt; requestObserver &#x3D;</span><br><span class="line">        asyncStub.routeChat(new StreamObserver&lt;RouteNote&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void onNext(RouteNote note) &#123;</span><br><span class="line">            info(&quot;Got message \&quot;&#123;0&#125;\&quot; at &#123;1&#125;, &#123;2&#125;&quot;, note.getMessage(), note.getLocation()</span><br><span class="line">                .getLatitude(), note.getLocation().getLongitude());</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          public void onError(Throwable t) &#123;</span><br><span class="line">            finishFuture.setException(t);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          public void onCompleted() &#123;</span><br><span class="line">            finishFuture.set(null);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      RouteNote[] requests &#x3D;</span><br><span class="line">          &#123;newNote(&quot;First message&quot;, 0, 0), newNote(&quot;Second message&quot;, 0, 1),</span><br><span class="line">              newNote(&quot;Third message&quot;, 1, 0), newNote(&quot;Fourth message&quot;, 1, 1)&#125;;</span><br><span class="line"></span><br><span class="line">      for (RouteNote request : requests) &#123;</span><br><span class="line">        info(&quot;Sending message \&quot;&#123;0&#125;\&quot; at &#123;1&#125;, &#123;2&#125;&quot;, request.getMessage(), request.getLocation()</span><br><span class="line">            .getLatitude(), request.getLocation().getLongitude());</span><br><span class="line">        requestObserver.onNext(request);</span><br><span class="line">      &#125;</span><br><span class="line">      requestObserver.onCompleted();</span><br><span class="line"></span><br><span class="line">      finishFuture.get();</span><br><span class="line">      info(&quot;Finished RouteChat&quot;);</span><br><span class="line">    &#125; catch (Exception t) &#123;</span><br><span class="line">      requestObserver.onError(t);</span><br><span class="line">      logger.log(Level.WARNING, &quot;RouteChat Failed&quot;, t);</span><br><span class="line">      throw t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>和我们的客户端流的例子一样，我们拿到和返回一个 StreamObserver 应答观察者，除了这次我们在客户端仍然写入消息到 它们的 消息流时通过我们方法的应答观察者返回值。这里读写的语法和客户端流以及服务器流方法一样。虽然每一端都会按照它们写入的顺序拿到另一端的消息，客户端和服务器都可以任意顺序读写——流的操作是互不依赖的。</p>
<h1 id="ProtoBuf-存储原理"><a href="#ProtoBuf-存储原理" class="headerlink" title="ProtoBuf 存储原理"></a>ProtoBuf 存储原理</h1><p>核心是 Google 提出了“Base 128 Varints”编码,这是一种变字节长度的编码,官方描述为:varints 是用一个或多个字节序列化整形的一种方法。</p>
<h2 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h2><p>protobuf 把 message 通过一系列 key_value 对来表示。<br>Key 的算法为：(field_number &lt;&lt; 3）| wired_type<br>这里 field_number 就是具体的索引，wired_type 的值按下表查询。</p>
<table>
<thead>
<tr>
<th>wired_type</th>
<th>.proto 类型</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Varint int32, int64, uint32, uint64, sint32, sint64, bool, enum</td>
</tr>
<tr>
<td>1</td>
<td>64-bit fixed64, sfixed64, double</td>
</tr>
<tr>
<td>2</td>
<td>Length-delimited string, bytes, embedded messages, packed repeated fields</td>
</tr>
<tr>
<td>5</td>
<td>32-bit fixed32, sfixed32, float</td>
</tr>
<tr>
<td>对于 int，bool，enum 类型，value 就是 Varint。</td>
<td></td>
</tr>
</tbody></table>
<p>而对于 string，bytes，message 等等类型，value 是长度+原始内容编码。</p>
<ul>
<li><p>举例 int 类型存储(Varint 存储原理)<br>存储一个 int32 类型的数字，通常是 4 个字节。但是 Varints 最少只需要一个字节就可以了。<br>Varints 规定小于 128 的数字都可以用一个字节来表示，比如 10， 它就会用一个字节 0000 1010 来存储。<br>对于大于 128 的数字，则用更多个字节存储。<br>以 150 举例：protobuf 的存储字节是 1001 0110 0000 0001。<br>为什么会这样标识呢？首先我们了解一个字节共 8 位，表示的数字是 255，但是 Varints 只用一个字节表示小于 128 的数字，换句话说，就是 Varints 只用了 8 位中的 7 位来表示数字，而还有一位被用来干嘛了呢？<br>Varints 在官方规定中表示，每个字节的最高位是有特殊含义，当最高位为 1 的时候，代表后续的字节也是该数字的一部分。当最高位为 0 的时候，则表示结束。<br>比如过 150，二进制表示为 1001 0110。<br>先取后七位 001 0110， 作为第一个字节的内容。<br>再取余下 1 位，前面补 0 凑齐 7 位，就是 000 0001，作为第二字节。<br>对于 intel 机器，是小端字节序，低字节位于地址低的。0010110 是低字节地址，因此排在前面，因为后面的也是数字的一部分，所以高位补 1，也就成了 10010110。 同样的，高字节 000 0001，排在后面，并且它后面没有后续字节了，所以补 0，也就成了 0000 0001。<br>因此 150 在 protobuf 中的表示方式为 1001 0110 0000 0001。</p>
</li>
<li><p>举例 string 类型存储</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message Test &#123;</span><br><span class="line">required string desc &#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如把 a 设置为 “testing”的话， 那么序列化后的就是<br>12 07 74 65 73 74 69 64 67<br>其中 12 是 key。剩下的是 value。<br>怎么算的呢？先看 12， 这里的 12，是个 16 进制数字，其二进制位表示为 0001 0010。<br>0010 就是类型 string 的对应的 Type 值，根据上表，也就是 2。<br>field_number (required string desc)是 2，也就是 0010，左移三位，就成了 0001 0000。<br>按照 key 的计算公式，和 Type 值取并后就变成了 0001 0010，即 12。<br>Value 是长度加原始内容编码。<br>07 就是长度， 代表 string 总长 7 个字节。 后面 7 个数字一次代表每个字母所对应的 16 进制表示。</p>
</li>
</ul>
<h2 id="json-与-protobuf-的互转"><a href="#json-与-protobuf-的互转" class="headerlink" title="json 与 protobuf 的互转"></a>json 与 protobuf 的互转</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.google.protobuf&#x2F;protobuf-java-util --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.protobuf&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;protobuf-java-util&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.6.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>自定义的 bean 与 proto 是可以通过 Json 相互转换的，然而它们之间的转换需要第三方 JSON 转换工具和 protobuf util 的支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;to Json</span><br><span class="line">JsonFormat.Printer printer &#x3D; JsonFormat.printer();</span><br><span class="line">String print &#x3D; &quot;&quot;;</span><br><span class="line">try &#123;</span><br><span class="line">    print &#x3D; printer.print(person);</span><br><span class="line">    System.out.println(print);</span><br><span class="line">&#125; catch (InvalidProtocolBufferException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;to Object</span><br><span class="line">JsonFormat.Parser parser &#x3D; JsonFormat.parser();</span><br><span class="line">try &#123;</span><br><span class="line">    PersonProto.Person.Builder newBuilder &#x3D; PersonProto.Person.newBuilder();</span><br><span class="line">    parser.merge(print, newBuilder);</span><br><span class="line">    System.out.println(newBuilder.build());</span><br><span class="line">&#125; catch (InvalidProtocolBufferException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加java bean 此类对性数据库的字段，同时与proto类属性名相同</span><br><span class="line">public class Person implements Serializable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Boolean sex;</span><br><span class="line">    private Date dirthday;&#x2F;&#x2F;此处注意这里是时间类型而非proto类中的long类型</span><br><span class="line">    private String address;</span><br><span class="line">    private List&lt;Car&gt; cars &#x3D; new ArrayList&lt;Car&gt;();</span><br><span class="line">    private Map&lt;String, String&gt; other &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Car implements Serializable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在上面的转换中间添加以下代码,发现同样转换成功</span><br><span class="line">Person myPerson &#x3D; JsonUtil.toObject(print, Person.class);</span><br><span class="line">System.out.println(myPerson);</span><br><span class="line">print &#x3D; JsonUtil.toJson(myPerson);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/Web%E5%9F%BA%E7%A1%80+tomcat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/27/Web%E5%9F%BA%E7%A1%80+tomcat/" class="post-title-link" itemprop="url">Web基础+Tomcat</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-27 21:00:00 / Modified: 15:07:20" itemprop="dateCreated datePublished" datetime="2020-12-27T21:00:00+08:00">2020-12-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Web-基础和-tomcat"><a href="#Web-基础和-tomcat" class="headerlink" title="Web 基础和 tomcat"></a>Web 基础和 tomcat</h1><h2 id="tomcat-学艺"><a href="#tomcat-学艺" class="headerlink" title="tomcat 学艺"></a>tomcat 学艺</h2><p>JavaEE 规范：JDBC，JNDI，EJB，RMI，JSP，Servlets，XML，JMS，Java IDL，JTS，JTA，JavaMail，JAF。<br>Tomcat 只实现了俩：Servlet 和 JSP。其他服务器比如 JBoss、Weblogic 啥的都是完全支持的。所以人们往往更愿意叫 Tomcat 为轻量级的服务器，也有叫它 Servlet/JSP 容器的。所以 java 开发时不需要额外依赖 servlet 和 JSP，但是需要额外依赖 JDBC，因为 tomcat 里只实现了 Servlet 和 JSP。</p>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>服务器的主要作用:</p>
<ul>
<li>将资源对外暴露</li>
<li>配合各种传输协议进行响应输出<br>请先了解以下三个概念:</li>
<li>IP:电子设备在网络中的唯一表示，一个 IP 对应一台实体电脑。</li>
<li>端口：应用程序在计算机中的唯一标识，一个端口只能被唯一程序占用。</li>
<li>传输协议：数据传输的规则。<br>浏览器与服务器通信流程如下：<br><img src="/images/tomcat/tomcat-web-1.png"><br>实际请求时，最终还是要换算成 IP 去访问。总得来说有两种换算的途径：1.本机的 hosts 文件 2.DNS 服务器<br>DNS 解析域名得到对应的 IP 后，Request 请求里还是会带上 host。为什么？</li>
</ul>
<p>因为：域名!=IP。</p>
<p>实际上一个 IP 可以对应多个域名。也就是说一台实体服务器（大铁柜），理论上可以有多个域名（虚拟主机）。实体服务器和网站是两个概念。IP 只是对应实体服务器，而域名对应具体的网站。</p>
<p>比如上面百度服务器，虽然看起来 115.239.210.27 这个 IP 完全等同于<a href="http://www.baidu.com，但也有可能这个IP对应的服务器上配置了两个虚拟主机：www.baidu.com和tieba.baidu.com。所以即使找到了IP对应的服务器实体，Request请求还是要带上host主机名，以确定是哪个虚拟主机。">http://www.baidu.com，但也有可能这个IP对应的服务器上配置了两个虚拟主机：www.baidu.com和tieba.baidu.com。所以即使找到了IP对应的服务器实体，Request请求还是要带上host主机名，以确定是哪个虚拟主机。</a><br><img src="/images/tomcat/tomcat-web-2.png"><br>另外，如果两个域名对应同一个 IP，那么必须设置其中一个域名为默认的，不然同一台服务器有两个虚拟主机，我该访问谁？<br>已经知道 IP，就无需 DNS 解析，可直接访问服务器。若这个 IP 对应的服务器有两个虚拟主机，而用户 Request 请求行中又没有指定 host，则会访问默认主机（因此服务器要事先指定默认主机！Tomcat 默认 localhost，localhost 这个名称是一个保留域名）<br><img src="/images/tomcat/tomcat-web-3.png"><br>最后，再用 Tomcat 举个例子。比如，现在我有一台笔记本电脑（一个实体服务器），它的本机 IP 是 192.168.112.1，我在上面装了 Tomcat。如果 Tomcat 不改动配置，则默认只有一个虚拟主机 localhost（默认主机）。接着我开发了一个 JavaWeb 程序 demo1 部署到 Tomcat，然后我同事在浏览器输入下方地址。192.168.112.1:8080/demo1/index.html。访问我的电脑。虽然没有带 host，但是 localhost 是默认的，于是访问它。<br><img src="/images/tomcat/tomcat-web-4.png"></p>
<h2 id="3-个容易混淆的概念"><a href="#3-个容易混淆的概念" class="headerlink" title="3 个容易混淆的概念"></a>3 个容易混淆的概念</h2><p>其实，Tomcat 服务器 = Web 服务器 + Servlet/JSP 容器（Web 容器）。<br>Web 服务器的作用是接收客户端的请求，给客户端作出响应。但是很明显，服务器不止静态资源呀，所以客户端发起请求后，如果是动态资源，Web 服务器不可能直接把它响应回去（比如 JSP），因为浏览器只认识静态资源。所以对于 JavaWeb 程序而言，还需要 JSP/Servlet 容器，JSP/Servlet 容器的基本功能是把动态资源转换成静态资源。我们 JavaWeb 工程师需要使用 Web 服务器和 JSP/Servlet 容器，而通常这两者会集于一身，比如 Tomcat。<br><img src="/images/tomcat/tomcat-web-5.jpg"></p>
<h2 id="我们开发的-Web-应用都是半成品"><a href="#我们开发的-Web-应用都是半成品" class="headerlink" title="我们开发的 Web 应用都是半成品"></a>我们开发的 Web 应用都是半成品</h2><p>我们开发 JavaWeb 时，你操心过如何接收 HTTP 请求和响应 HTTP 请求吗？显然没有嘛！因为服务器都已经完成了。所以，我们用 Java 开发的 Web 应用只是一个半成品，类似于一个插件，而服务器则像一个收发器：<br><img src="/images/tomcat/tomcat-web-6.png"></p>
<h2 id="什么是动态资源"><a href="#什么是动态资源" class="headerlink" title="什么是动态资源"></a>什么是动态资源</h2><p>其实对于何谓动态资源，我也没有很精准的概念。要讲清楚一个东西是什么，有时是比较难的事。不如先说它不是什么。</p>
<p>首先，动态资源不等同于动态页面。所谓动态页面，就是页面会动，而会动的页面不一定是动态资源。比如我可以用 JQuery 执行一段代码，让一个 Div 不断放大缩小，但是很显然它还是一个 HTML 页面。</p>
<p>所谓动态资源，其实最显著的特征就是它能动态地生成 HTML！比如 JSP。动态资源有个“特色”：它的数据是“可拼装”的、而且“可以随时间变化”。下面用号称可以抗住 8 个明星同时出轨的新浪服务器举个例子：<br><img src="/images/tomcat/tomcat-web-7.png"></p>
<h2 id="Tomcat-架构"><a href="#Tomcat-架构" class="headerlink" title="Tomcat 架构"></a>Tomcat 架构</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><img src="/images/tomcat/tomcat-web-8.jpg"></p>
<h3 id="Tomcat-的架构"><a href="#Tomcat-的架构" class="headerlink" title="Tomcat 的架构"></a>Tomcat 的架构</h3><p><img src="/images/tomcat/tomcat-web-9.jpg"></p>
<h3 id="server-xml-配置"><a href="#server-xml-配置" class="headerlink" title="server.xml 配置"></a>server.xml 配置</h3><p><img src="/images/tomcat/tomcat-web-10.jpg"><br><img src="/images/tomcat/tomcat-web-11.jpg"><br>简略解释一下 xml 里的配置：</p>
<ul>
<li><p>Server.xml 文件中的配置结构和 Tomcat 的架构是一一对应的。根目录是<Server>，代表服务器，<Server>下面有且仅有 1 个<Service>，代表服务。<br><Service>下有两个<Connector>，代表连接（需要的话可以再加）。</Connector></Service></Service></Server></Server></p>
</li>
<li><p>其实这个 Connector 就是我们在上面讨论百度服务器时画过的端口。大家可以看到 Tomcat 默认配置了两个端口，一个是 HTTP/1.1 协议的，一个是 AJP/1.3 协议（AJP 连接器可以通过 AJP 协议和另一个 web 服务器行交互）。前者专门处理 HTTP 请求，后者可以通其他 web 服务器连接。<br><img src="/images/tomcat/tomcat-web-12.jpeg"></p>
</li>
<li><p>当我们在浏览器输入”<a target="_blank" rel="noopener" href="http://localhost:8080/demo/index.html&quot;%E6%97%B6%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E4%BB%A5HTTP%E5%8D%8F%E8%AE%AE%E5%8F%91%E9%80%81%E7%9A%84%EF%BC%8C%E5%BD%93%E8%BF%99%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%88%B0%E4%BA%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%EF%BC%8C%E4%BC%9A%E8%A2%AB%E8%AF%86%E5%88%AB%E4%B8%BAHTTP%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BA%8E%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B0%B1%E6%89%BE%E6%9D%A5%E4%B8%93%E9%97%A8%E5%A4%84%E7%90%86HTTP%E7%9A%84Connector%EF%BC%8C%E5%AE%83%E7%9A%84%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E6%AD%A3%E6%98%AF%E4%B8%8A%E9%97%A8Server.xml%E9%85%8D%E7%BD%AE%E7%9A%848080%E3%80%82">http://localhost:8080/demo/index.html&quot;时，浏览器是以HTTP协议发送的，当这个请求到了服务器后，会被识别为HTTP类型，于是服务器就找来专门处理HTTP的Connector，它的默认端口正是上门Server.xml配置的8080。</a></p>
</li>
<li><p>与 Connector 平级的还有个<Engine>（Tomcat 引擎），也就是说<Service>有两个孩子，小儿子是<Connector>，大儿子是<Engine>。Connector 的作用说穿了就是监听端口，如果用户访问地址是“localhost:8080/xx/xx”，那就由监听 8080 端口的 Connector 负责，如果是”<a target="_blank" rel="noopener" href="https://www.baidu.com&quot;,那么就是443端口处理.其实connector也不处理实际业务,它只是个孩子.但它会负责把客人(请求)带到哥哥engine那,然后engine会处理./">https://www.baidu.com&quot;，那么就是443端口处理。其实Connector也不处理实际业务，它只是个孩子。但它会负责把客人（请求）带到哥哥Engine那，然后Engine会处理。</a></Engine></Connector></Service></Engine></p>
</li>
<li><p><Engine>下面有个 Host，代表主机。一个是默认的虚拟主机 localhost,一个是虚拟主机 xxxhost。localhost 对应的 appBase 是 webapps，所以请求到达 localhost 之后，会在 webapps 文件夹下面寻找对应子目录。</Engine></p>
</li>
</ul>
<h3 id="tomcat-中的-DefaultServlet"><a href="#tomcat-中的-DefaultServlet" class="headerlink" title="tomcat 中的 DefaultServlet"></a>tomcat 中的 DefaultServlet</h3><p>实际使用 tomcat 的时候，即使没有编写 Servlet，tomcat 依然可以处理请求返回结果，是因为 tomcat 有一个 DefaultServlet。像 Tomcat 这样的 Servlet 容器来说，任何一个请求的背后肯定有个 Servlet 在默默处理：<br><img src="/images/tomcat/tomcat-web-13.png"><br>在 tomcat/conf/web.xml 中，声明了一个 DefaultServlet。我们每个动态 web 工程都有个 web.xml，而 conf 里的这个，是它们的“老爹”。它里面的配置，如果动态 web 工程没有覆盖，就会被“继承”下来。我们会发现，conf/web.xml 里配置了一个 DefaultServlet：<br><img src="/images/tomcat/tomcat-web-14.jpg"><br>DefaultServlet 的作用：最低级匹配，当没有对应的 Servlet 处理当前请求时，才轮到它处理。要么找到并响应请求的资源，要么给出 404 页面</p>
<h3 id="JSP-剖析"><a href="#JSP-剖析" class="headerlink" title="JSP 剖析"></a>JSP 剖析</h3><p>我们都知道 JSP 是“化了浓妆”的 Servlet，但是好不容易伪装成了一个 JSP，是谁帮它卸妆的呢？另外，大家仔细想想，一般来说 JavaWeb 阶段我们访问资源有三种“形式”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localhost:8080&#x2F;demo&#x2F;AServlet：很明显，我们手动写了一个AServlet处理它</span><br><span class="line">localhost:8080&#x2F;demo&#x2F;haha.html：虽然我们没写，但是Tomcat自己准备了DefaultServlet</span><br><span class="line">localhost:8080&#x2F;demo&#x2F;index.jsp：我擦，谁来处理？</span><br></pre></td></tr></table></figure>

<p>对呀，细思恐极，这*.jsp 的资源，谁来处理？其实就是 JspServlet。它的作用简而言之就是：</p>
<p>首先，根据请求路径找到 JSP<br>然后，将它“翻译成”Servlet</p>
<p>JSP 的 Servlet 也定义在 conf/web.xml。<br><img src="/images/tomcat/tomcat-web-15.png"></p>
<h3 id="tomcat-处理请求的几种方式"><a href="#tomcat-处理请求的几种方式" class="headerlink" title="tomcat 处理请求的几种方式"></a>tomcat 处理请求的几种方式</h3><p><img src="/images/tomcat/tomcat-web-16.jpg"></p>
<h3 id="tomcat-处理-http-流程"><a href="#tomcat-处理-http-流程" class="headerlink" title="tomcat 处理 http 流程"></a>tomcat 处理 http 流程</h3><p>1、用户点击网页内容，请求被发送到本机端口 8080，被在那里监听的 Coyote HTTP/1.1 Connector 获得。<br>2、Connector 把该请求交给它所在的 Service 的 Engine 来处理，并等待 Engine 的回应。<br>3、Engine 获得请求 localhost/servlet/helloServlet，匹配所有的虚拟主机 Host。<br>4、Engine 匹配到名为 localhost 的 Host（即使匹配不到也把请求交给该 Host 处理，因为该 Host 被定义为该 Engine 的默认主机），名为 localhost 的 Host 获得求/servlet/HelloServlet，匹配它所拥有的所有的 Context。Host 匹配到路径为/servlet 的 Context（如果匹配不到就把该请求交给路径名为“ ”的 Context 去处理）。<br>5、path=“/servlet”的 Context 获得请求/HelloServlet，在它的 mapping table 中寻找出对应的 Servlet。<br>6、构造 HttpServletRequest 对象和 HttpServletResponse 对象，作为参数调用 Servlet 的 doGet（）或 doPost（）.执行业务逻辑、数据存储等程序。<br>7、Context 把执行完之后的 HttpServletResponse 对象返回给 Host。<br>8、Host 把 HttpServletResponse 对象返回给 Engine。<br>9、Engine 把 HttpServletResponse 对象返回 Connector。<br>10、Connector 把 HttpServletResponse 对象返回给客户 Browser。<br><img src="/images/tomcat/tomcat-web-17.jpg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/Servlet%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/27/Servlet%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">Servlet与SpringMVC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-27 13:01:22 / Modified: 18:37:15" itemprop="dateCreated datePublished" datetime="2020-12-27T13:01:22+08:00">2020-12-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>Java Servlet 技术简称 Servlet 技术，是 Java 开发 Web 应用的底层技术。由 Sun 公司于 1996 年发布，用来代替 CGU—-当时生成 Web 动态内容的主流技术。CGI 的问题是每一个 WEB 请求都需要重新启动一个进程来处理。创建进程需要消耗不少 CPU 周期，导致难以编写刻苦鏖战的 CGI 程序，而 Servlet 在创建后（处理第一个请求时）就一直保存在内存中，这就比 CGI 有着更好的性能。</p>
<p>Servlet 是一个 Java 程序，一个 servlet 应用有一个或多个 Servlet 程序。JSP 页面会被转换和编译成 servlet 程序。</p>
<p>Servlet 程序无法独立运行，必须运行在 Servlet 容器中。Servlet 容器将用户的请求床底给 servlet 应用，并将结果返回给用户。由于大部分 Servlet 用用都包含多个 JSP 页面，因此更准确地说是“Servlet/JSP 应用”。</p>
<p>Servlet/JSP 容器是一个可以同时处理 Servlet 和静态内容的 Web 容器。过去，由于通常认为 HTTP 服务器比 Servlet/JSP 容器更加可靠，因此人们习惯将 servlet 容器当做 HTTP 服务器的一个模块，这种模式下，HTTP 服务器用来处理静态资源，Servlet 容器则负责生成动态内容。</p>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Constructor of the object.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public HelloServlet() &#123;</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Destruction of the servlet. &lt;br&gt;</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void destroy() &#123;</span><br><span class="line">		super.destroy(); &#x2F;&#x2F; Just puts &quot;destroy&quot; string in log</span><br><span class="line">		&#x2F;&#x2F; Put your code here</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * The doGet method of the servlet. &lt;br&gt;</span><br><span class="line">	 *</span><br><span class="line">	 * This method is called when a form has its tag value method equals to get.</span><br><span class="line">	 *</span><br><span class="line">	 * @param request the request send by the client to the server</span><br><span class="line">	 * @param response the response send by the server to the client</span><br><span class="line">	 * @throws ServletException if an error occurred</span><br><span class="line">	 * @throws IOException if an error occurred</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">		response.setContentType(&quot;text&#x2F;html&quot;);</span><br><span class="line">		PrintWriter out &#x3D; response.getWriter();</span><br><span class="line">		out.println(&quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN\&quot;&gt;&quot;);</span><br><span class="line">		out.println(&quot;&lt;HTML&gt;&quot;);</span><br><span class="line">		out.println(&quot;  &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;&#x2F;TITLE&gt;&lt;&#x2F;HEAD&gt;&quot;);</span><br><span class="line">		out.println(&quot;  &lt;BODY&gt;&quot;);</span><br><span class="line">		out.print(&quot;    This is &quot;);</span><br><span class="line">		out.print(this.getClass());</span><br><span class="line">		out.println(&quot;, using the GET method&quot;);</span><br><span class="line">		out.println(&quot;  &lt;&#x2F;BODY&gt;&quot;);</span><br><span class="line">		out.println(&quot;&lt;&#x2F;HTML&gt;&quot;);</span><br><span class="line">		out.flush();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * The doPost method of the servlet. &lt;br&gt;</span><br><span class="line">	 *</span><br><span class="line">	 * This method is called when a form has its tag value method equals to post.</span><br><span class="line">	 *</span><br><span class="line">	 * @param request the request send by the client to the server</span><br><span class="line">	 * @param response the response send by the server to the client</span><br><span class="line">	 * @throws ServletException if an error occurred</span><br><span class="line">	 * @throws IOException if an error occurred</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">		response.setContentType(&quot;text&#x2F;html&quot;);</span><br><span class="line">		PrintWriter out &#x3D; response.getWriter();</span><br><span class="line">		out.println(&quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN\&quot;&gt;&quot;);</span><br><span class="line">		out.println(&quot;&lt;HTML&gt;&quot;);</span><br><span class="line">		out.println(&quot;  &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;&#x2F;TITLE&gt;&lt;&#x2F;HEAD&gt;&quot;);</span><br><span class="line">		out.println(&quot;  &lt;BODY&gt;&quot;);</span><br><span class="line">		out.print(&quot;    This is &quot;);</span><br><span class="line">		out.print(this.getClass());</span><br><span class="line">		out.println(&quot;, using the POST method&quot;);</span><br><span class="line">		out.println(&quot;  &lt;&#x2F;BODY&gt;&quot;);</span><br><span class="line">		out.println(&quot;&lt;&#x2F;HTML&gt;&quot;);</span><br><span class="line">		out.flush();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Initialization of the servlet. &lt;br&gt;</span><br><span class="line">	 *</span><br><span class="line">	 * @throws ServletException if an error occurs</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void init() throws ServletException &#123;</span><br><span class="line">		&#x2F;&#x2F; Put your code here</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看见，这个 HelloServlet 继承了 HTTPServlet 类，主要有 init()、doGet（）、doPost（）、destroy()四个方法。我们在浏览器中分别用 get 和 post 访问这个 servlet。<br><img src="/images/web/servlet-1.png"><br>我们可以看到，这就是上文我们编写的 doGet 方法中的 Html 生成的页面。</p>
<h1 id="Servlet-前世今生"><a href="#Servlet-前世今生" class="headerlink" title="Servlet 前世今生"></a>Servlet 前世今生</h1><p>一个 web 请求过程：</p>
<ul>
<li>接受请求</li>
<li>处理请求</li>
<li>相应请求<br>web 服务器负责接受请求和相应请求，如果是静态资源那么 web 服务器就够用了。如果是动态资源就要处理请求，这时候就需要 servlet 了。 servlet 专门用来处理请求，编写业务逻辑。后来三层架构出现了，servlet 就把一些任务分担到 servier 和 dao，形成了 servlet(contrller)+service+dao。servlet 本身不擅长往浏览器输出 HTML 页面，所以出现了 JSP。<br>等 Spring 家族出现后，Servlet 开始退居幕后，取而代之的是 SpringMVC。SpringMVC 的核心组件 DispatcherServlet 其实本质就是一个 Servlet。但它已经自立门户，在原来 HTTPServlet 的基础上，又封装了一条逻辑。<br>Servlet 是 J2EE 规范中的一种，主要是为了扩展 java 作为 web 服务的功能，事实上，servlet 就是一个 Java 接口。<br><img src="/images/web/servlet-2.png"></li>
</ul>
<h1 id="Servlet-与-SpringMVC"><a href="#Servlet-与-SpringMVC" class="headerlink" title="Servlet 与 SpringMVC"></a>Servlet 与 SpringMVC</h1><p>参考连接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/65658315">https://zhuanlan.zhihu.com/p/65658315</a></p>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>ServletContext 对象的作用是在整个 Web 应用的动态资源（Servlet/JSP）之间共享数据。例如在 AServlet 中向 ServletContext 对象保存一个值，然后在 BServlet 中就可以获取这个值。</p>
<h2 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h2><p>这种用来装载共享数据的对象，在 JavaWeb 中共有 4 个，而且更习惯被成为“域对象”：</p>
<ul>
<li>ServletContext 域（Servlet 间共享数据）</li>
<li>Session 域（一次会话间共享数据，也可以理解为多次请求间共享数据）</li>
<li>Request 域（同一次请求共享数据）</li>
<li>Page 域（JSP 页面内共享数据）<br>它们都可以看做是 map，都有 getAttribute()/setAttribute()方法。</li>
</ul>
<h2 id="ServletContext-的方法"><a href="#ServletContext-的方法" class="headerlink" title="ServletContext 的方法"></a>ServletContext 的方法</h2><p>所以，获取 ServletContext 的方法共 5 种（page 域这里不考虑，JSP 太少用了）：</p>
<ul>
<li>ServletConfig#getServletContext();</li>
<li>GenericServlet#getServletContext();</li>
<li>HttpSession#getServletContext();</li>
<li>HttpServletRequest#getServletContext();</li>
<li>ServletContextEvent#getServletContext();</li>
</ul>
<h2 id="Filter-过滤器"><a href="#Filter-过滤器" class="headerlink" title="Filter 过滤器"></a>Filter 过滤器</h2><p>Filter 更详细的拦截其实是这样：<br>最外层那个圈，可以理解成 ServletContext，FORWARD/INCLUDE 这些都是内部请求。如果在 web.xml 中配置 Filter 时 4 种拦截方式全配上，那么服务器内部的分发跳转都会被过滤。下图中灰色的墙就是 fliter。红色字代表各种请求方式，FORWARD 和 INCLUDE 的位置相同。<br><img src="/images/web/servlet-3.png"></p>
<h2 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h2><p>对于静态资源，Tomcat 最后会交由一个叫做 DefaultServlet 的类来处理<br>对于 Servlet ，Tomcat 最后会交由一个叫做 InvokerServlet 的类来处理<br>对于 JSP，Tomcat 最后会交由一个叫做 JspServlet 的类来处理<br><img src="/images/web/servlet-5.png"></p>
<h2 id="DispatcherServlet-与-SpringMVC"><a href="#DispatcherServlet-与-SpringMVC" class="headerlink" title="DispatcherServlet 与 SpringMVC"></a>DispatcherServlet 与 SpringMVC</h2><p>tomcat 是一个 Servlet 容器，这个容器内可以存在多个 servlet，处理不同的请求。<br>加入 springmvc，它提供了一个 Servlet，可以处理.do 结尾的请求，还有静态资源的请求和其它请求。如果，我们为 springmvc 在 web.xml 配置的映射 url 为/*则代表所有请求都要走 springmvc，tomcat 中的 DefaultServlet 和 JSPServlet 都无法得到请求。因为这个两个 servlet 是在 tomcat 的 conf/web.xml 中配置的，这个 web.xml 的配置会被各个应用自己的 web.xml 覆盖，最终 tomcat 按照应用定义的 web.xml 来做映射。<br>SpringMVC 的核心控制器叫 DispatcherServlet，映射原理和我们上面山寨版的一样，因为本质还是个 Servlet。但 SpringMVC 提供了一个标签，解决上面/无法读取静态资源的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 静态资源处理  css js imgs --&gt;</span><br><span class="line">&lt;mvc:resources location&#x3D;&quot;&#x2F;resources&#x2F;**&quot; mapping&#x3D;&quot;&#x2F;resources&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>其他的我也不说了，一张图，大家体会一下 DispatcherServlet 与 SpringMVC 到底是什么关系：<br><img src="/images/web/servlet-6.jpg"><br>DispatcherServlet 确实是一个 Servlet，但它只是入口，SpringMVC 要比想象的庞大。DispatcherServlet 只是 Springmvc 的一个入口，Springmvc 内部是十分复杂的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/Servlet%E5%AF%B9%E6%AF%94CGI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/27/Servlet%E5%AF%B9%E6%AF%94CGI/" class="post-title-link" itemprop="url">Servlet与CGI</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-27 12:01:22 / Modified: 15:32:24" itemprop="dateCreated datePublished" datetime="2020-12-27T12:01:22+08:00">2020-12-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="对比-Servlt-和-CGI"><a href="#对比-Servlt-和-CGI" class="headerlink" title="对比 Servlt 和 CGI"></a>对比 Servlt 和 CGI</h1><p>java 的 servlet 实现是自己规定了一套协议，与 CGI 和 fastcgi 协议不同。<br>Servlet 与 CGI 的区别<br>对比一：当用户浏览器发出一个 Http/CGI 的请求，或者说调用一个 CGI 程序的时候，服务器端就要新启用一个进程(而且是每次都要调用)，调用 CGI 程序越多(特别是访问量高的时候)，就要消耗系统越多的处理时间，只剩下越来越少的系统资源，对于用户来说，只能是漫长的等待服务器端的返回页面了，这对于电子商务激烈发展的今天来说，不能不说是一种技术上的遗憾。</p>
<p>而 Servlet 充分发挥了服务器端的资源并高效的利用。每次调用 Servlet 时并不是新启用一个进程，而是在一个 Web 服务器的进程中共享和分离线程，而线程最大的好处在于可以共享一个数据源，使系统资源被有效利用。</p>
<p>对比二：传统的 CGI 程序，不具备平台无关性特征，系统环境发生变化，CGI 程序就要瘫痪，而 Servlet 具备 Java 的平台无关性，在系统开发过程中保持了系统的可扩展性、高效性。</p>
<p>对比三：传统技术中，一般大都为二层的系统架构，即 Web 服务器+数据库服务器，导致网站访问量大的时候，无法克服 CGI 程序与数据库建立连接时速度慢的瓶颈，从而死机、数据库死锁现象频繁发生。而 Servlet 有连接池的概念，它可以利用多线程的优点，在系统缓存中事先建立好若干与数据库的连接，到时候若想和数据库打交道可以随时跟系统”要”一个连接即可，反应速度可想而知。</p>
<p>Java Servlet 为什么不做成 FastCGI 模式？</p>
<p>1、JVM 多线程架构健壮性非常强</p>
<p>理论上多进程确实健壮性更强，但实际上，JVM 进程远比普通 C/C++进程坚固。</p>
<p>用 C/C++写程序，随便一个空指针、内存越界、内存泄漏就可能意外终止进程，更遑论很多 C/C++程序处理严重错误的方式都是很粗暴的 exit 或者 panic。</p>
<p>而用 Java 写代码，要想不小心终止进程很难。异常机制可以保证几乎没有任何 Java 代码能够直接干掉一个线程或进程，Java 程序的线程几乎跟普通 C/C++的进程一样脆弱／坚固。</p>
<p>2、Tomcat 静态文件性能并不差<br>别的 Servlet 容器不清楚，但是得益于独立的 connector 设计，较新版本的 Tomcat 有了 NIO、APR 等技术的加持，静态文件性能不会比 apache httpd 差到哪儿去。</p>
<p>“很多网站直接用 servlet 容器当 web 服务器”，因为这样很简单，而且暂时可能没遇到或不关心性能瓶颈。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/26/Tomcat%E8%BF%B7%E4%BD%A0%E7%89%88%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/26/Tomcat%E8%BF%B7%E4%BD%A0%E7%89%88%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Tomcat迷你版实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-26 23:00:00" itemprop="dateCreated datePublished" datetime="2020-12-26T23:00:00+08:00">2020-12-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-27 14:50:35" itemprop="dateModified" datetime="2020-12-27T14:50:35+08:00">2020-12-27</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Tomcat 是非常流行的 Web Server，它还是一个满足 Servlet 规范的容器。那么想一想，Tomcat 和我们的 Web 应用是什么关系？</p>
<p>从感性上来说，我们一般需要把 Web 应用打成 WAR 包部署到 Tomcat 中，在我们的 Web 应用中，我们要指明 URL 被哪个类的哪个方法所处理「不论是原始的 Servlet 开发，还是现在流行的 Spring MVC 都必须指明」。</p>
<p>由于我们的 Web 应用是运行在 Tomcat 中，请求必定是先到达 Tomcat 的。Tomcat 对于请求实际上会进行如下的处理。</p>
<p>第一，提供 Socket 服务</p>
<p>Tomcat 的启动，必然是 Socket 服务，只不过它支持 HTTP 协议而已！</p>
<p>这里其实可以扩展思考下，Tomcat 既然是基于 Socket，那么是基于 BIO or NIO or AIO 呢？</p>
<p>第二，进行请求的分发</p>
<p>要知道一个 Tomcat 可以为多个 Web 应用提供服务，很显然，Tomcat 可以把 URL 下发到不同的 Web 应用。</p>
<p>第三，需要把请求和响应封装成 request/response</p>
<p>我们在 Web 应用这一层，可从来没有封装过 request/response 的，我们都是直接使用的，这就是因为 Tomcat 已经为你做好了！</p>
<p>话不多说，先来看一眼工程截图。<br><img src="/images/tomcat/tomcat1.png"></p>
<h1 id="一、封装请求对象"><a href="#一、封装请求对象" class="headerlink" title="一、封装请求对象"></a>一、封装请求对象</h1><p><img src="/images/tomcat/tomcat2.png"><br>这里可以清楚的看到，通过输入流，对 HTTP 协议进行解析，拿到了 HTTP 请求头的方法以及 URL。</p>
<h1 id="二、封装响应对象"><a href="#二、封装响应对象" class="headerlink" title="二、封装响应对象"></a>二、封装响应对象</h1><p><img src="/images/tomcat/tomcat3.png"><br>基于 HTTP 协议的格式进行输出写入。</p>
<h1 id="三、Servlet-请求处理基类"><a href="#三、Servlet-请求处理基类" class="headerlink" title="三、Servlet 请求处理基类"></a>三、Servlet 请求处理基类</h1><p><img src="/images/tomcat/tomcat4.png"><br>前文说 Tomcat 是满足 Servlet 规范的容器，那么自然 Tomcat 需要提供 API。这里看到了 Servlet 常见的 doGet/doPost/service 方法。</p>
<p>#　四、Servlet 实现类<br><img src="/images/tomcat/tomcat5.png"><br><img src="/images/tomcat/tomcat6.png"><br>提供这 2 个具体的 Servlet 实现，只是为了后续的测试！</p>
<h1 id="五、Servlet-配置"><a href="#五、Servlet-配置" class="headerlink" title="五、Servlet 配置"></a>五、Servlet 配置</h1><p><img src="/images/tomcat/tomcat7.png"><br><img src="/images/tomcat/tomcat8.png"><br>你应该有些感觉了吧？在 servlet 开发中，会在 web.xml 中通过<servlet>和<servlet-mapping>来进行指定哪个 URL 交给哪个 servlet 进行处理。</servlet-mapping></servlet></p>
<h1 id="六、启动类"><a href="#六、启动类" class="headerlink" title="六、启动类"></a>六、启动类</h1><p><img src="/images/tomcat/tomcat9.png"><br><img src="/images/tomcat/tomcat10.png"><br><img src="/images/tomcat/tomcat11.png"><br>这里，你能够看到 Tomcat 的处理流程，即把 URL 对应处理的 Servlet 关系形成，解析 HTTP 协议，封装请求/响应对象，利用反射实例化具体的 Servlet 进行处理即可。</p>
<h1 id="七、测试"><a href="#七、测试" class="headerlink" title="七、测试"></a>七、测试</h1><p><img src="/images/tomcat/tomcat12.png"><br>实现一个简易版的 Tomcat 就这么 7 大步搞定，大家都来动手实现一下吧，代码最好不要复制，自己动手一个个敲，这样实现之后，对 Tomcat 就没那么陌生了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/26/Play%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/26/Play%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">Play框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-26 21:00:00 / Modified: 22:09:50" itemprop="dateCreated datePublished" datetime="2020-12-26T21:00:00+08:00">2020-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Play 框架架构<br>当请求从浏览器发到服务端时，会有 Routes 来处理，如我们请求 /use/1 的 URL 时。这个请求将在 Routes 找到对应的函数来处理，在 Django 中处理请求的函数叫做 URL Dispatcher。</p>
<p><img src="/images/web/play01.png"><br>这里的路由规则分为了两个部分:请求动态数据或静态资源。<br>浏览器一般先请求获得 html 页面，然后 html 内容如果有 ajax 则会再发送请求过来，请求动态数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Routes</span><br><span class="line"># This file defines all application routes (Higher priority routes first)</span><br><span class="line"># ~~~~</span><br><span class="line"></span><br><span class="line"># Home page</span><br><span class="line">GET         &#x2F;                    controllers.ApplicationController.index</span><br><span class="line">POST        &#x2F;user                controllers.ApplicationController.addUser</span><br><span class="line">GET         &#x2F;delete&#x2F;:id          controllers.ApplicationController.deleteUser(id : Long)</span><br><span class="line">GET         &#x2F;user&#x2F;:id            controllers.ApplicationController.getUser(id : Long)</span><br><span class="line">GET         &#x2F;api&#x2F;user&#x2F;:id        controllers.ApiController.getUser(id : Long)</span><br><span class="line">POST        &#x2F;api&#x2F;user            controllers.ApiController.createUser</span><br><span class="line"></span><br><span class="line"># Map static resources from the &#x2F;public folder to the &#x2F;assets URL path</span><br><span class="line">GET         &#x2F;assets&#x2F;*file        controllers.Assets.versioned(path&#x3D;&quot;&#x2F;public&quot;, file: Asset)</span><br></pre></td></tr></table></figure>

<p>随后在我们的 ApiController 中会有一个对应的 getUser 的方法来处理，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ApiController extends Controller &#123;</span><br><span class="line">  def getUser(id: Long) &#x3D; Action.async &#123; implicit request &#x3D;&gt;</span><br><span class="line">    UserService.getUser(id).map &#123;</span><br><span class="line">      case None &#x3D;&gt; NotFound(Json.obj(&quot;error&quot; -&gt; &quot;Not Found&quot;))</span><br><span class="line">      case Some(user) &#x3D;&gt; Ok(Json.toJson(user))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后还是相应的 UserService 去取相应的用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import models.&#123;User, Users&#125;</span><br><span class="line">import scala.concurrent.Future</span><br><span class="line"></span><br><span class="line">object UserService &#123;</span><br><span class="line"></span><br><span class="line">  def addUser(user: User): Future[String] &#x3D; &#123;</span><br><span class="line">    Users.add(user)</span><br><span class="line">  &#125;</span><br><span class="line">  def getUser(id: Long): Future[Option[User]] &#x3D; &#123;</span><br><span class="line">    Users.get(id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后便会执行到 model 层:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">object Users &#123;</span><br><span class="line"></span><br><span class="line">  val dbConfig &#x3D; DatabaseConfigProvider.get[JdbcProfile](Play.current)</span><br><span class="line"></span><br><span class="line">  val users &#x3D; TableQuery[UserTableDef]</span><br><span class="line"></span><br><span class="line">  def add(user: User): Future[String] &#x3D; &#123;</span><br><span class="line">    dbConfig.db.run(users +&#x3D; user).map(res &#x3D;&gt; user.toString()).recover &#123;</span><br><span class="line">      case ex: Exception &#x3D;&gt; ex.getCause.getMessage</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  def get(id: Long): Future[Option[User]] &#x3D; &#123;</span><br><span class="line">    dbConfig.db.run(users.filter(_.id &#x3D;&#x3D;&#x3D; id).result.headOption)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就取到了这个用户。如果只是从这个过程上来说，我觉得和一般的 MVC 框架并没有太大的区别。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/26/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/26/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">函数式编程与面向对象编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-26 21:00:00 / Modified: 22:51:32" itemprop="dateCreated datePublished" datetime="2020-12-26T21:00:00+08:00">2020-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="编程的本质"><a href="#编程的本质" class="headerlink" title="编程的本质"></a>编程的本质</h1><p>当写过许许多多程序后，接触了那么多编程模式、设计模式、框架、语言、算法、数据结构以后，就会发现编程的本质万变不离其宗就是，操纵一坨数据。当然操纵的方式有许多，存储的方式也五花八门，但是本质不变，就是访问数据（读取以及改变）。</p>
<p>下面谈一谈我对两种编程方式的理解，就是面向对象编程，以及函数式编程。我用 JavaScript 这种神奇的语言来解释，因为 JavaScript 既可以面向对象编程，也可以函数式编程。</p>
<h1 id="数据存放方式"><a href="#数据存放方式" class="headerlink" title="数据存放方式"></a>数据存放方式</h1><p>1、对于 OO（面向对象，下同），数据存放在对象的属性（成员变量）里面，以及静态成员（全局变量）</p>
<p>2、对于函数式，数据存放在闭包（各级作用域）里面，作用域包括全局作用域。</p>
<h1 id="数据访问方式"><a href="#数据访问方式" class="headerlink" title="数据访问方式"></a>数据访问方式</h1><p>数据存放方式决定了访问的方式。</p>
<p>1、对于 OO 来说，访问数据（全局变量除外）需要先获取对象的引用，然后再进行操作（直接访问——公共属性，或者调用成员函数/方法访问——私有属性）</p>
<p>2、对于函数式，访问数据是直接访问（通过函数入参或者作用域链查找）</p>
<p>下面上一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;OO</span><br><span class="line">class Foo &#123;</span><br><span class="line">constructor()&#123;</span><br><span class="line">this.bar &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let foo &#x3D; new Foo()</span><br><span class="line">foo.bar ++</span><br></pre></td></tr></table></figure>

<p>//函数式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let bar &#x3D; 0</span><br><span class="line">function foo()&#123;</span><br><span class="line">bar ++</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>这是随便写了一些没有用代码，只是为了展示两种风格的编程方式。</p>
<p>从中我们可以看出一些东西，OO 是通过持有，以及传递对象的方式去让别的对象来操作数据，而对象也会是其他对象的成员，层层嵌套。当你想要访问某一个数据的时候，就需要顺着对象的引用链条去找，一步步去操作。</p>
<p>函数式传递的则是函数，调用函数即操作数据，传递函数的时候其实隐含着传递了函数创建的时候所附带的作用域，这个在表面上看不出来，在底层是有的。</p>
<p>OO 所谓的对象，本质上就是函数式中的作用域。</p>
<p>为了理解这句话，我们来看高阶函数的本质</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo(x)&#123;</span><br><span class="line">let bar &#x3D; x</span><br><span class="line">return function()&#123;</span><br><span class="line">return bar</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let Bar &#x3D; foo(1)</span><br><span class="line">console.log(Bar())&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>

<p>当调用 foo(1)的时候返回一个函数，这个函数可以访问 foo 函数内部的 bar 变量，这就是高阶函数。如果翻译成 OO 思想大家就知道怎么回事了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">constructor(x)&#123;</span><br><span class="line">this.bar &#x3D; x</span><br><span class="line">&#125;</span><br><span class="line">Bar()&#123;</span><br><span class="line">return this.bar</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let foo &#x3D; new Foo(1)</span><br><span class="line">console.log(foo.Bar())</span><br></pre></td></tr></table></figure>

<p>看上去是不是差不多。其实在 C#中对 lambda 表达式的编译就是这个原理。会内部创建一些类。</p>
<p>当然高阶函数的写法肯定不会这么啰嗦，会写的比较优雅。(这就是本质区别）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let foo &#x3D; bar&#x3D;&gt;()&#x3D;&gt;bar</span><br><span class="line">let Bar &#x3D; foo(1)</span><br><span class="line">console.log(Bar())&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>

<p>所以 OO 编程，是面向作用域编程，而函数式编程，是面向功能编程。</p>
<p>函数式编程有一个巨大的优势，就是作用域链，也就是说函数可以访问的变量范围要远远大于 OO，灵活性就成几何级数上升。换句话也可以说 OO 的约束性更强。</p>
<h1 id="FP-适合数据处理，OOP-适合外包业务领域"><a href="#FP-适合数据处理，OOP-适合外包业务领域" class="headerlink" title="FP 适合数据处理，OOP 适合外包业务领域"></a>FP 适合数据处理，OOP 适合外包业务领域</h1><p>函数式编程（FP）和面向对象编程（OOP）直接相比是一种常见的误解。这种比较应该是 FP 和 OOP 支持者之间互相怼的产物。</p>
<p>事实上，FP 和 OOP 是两种不同的看待事物的方式。FP 强调“everything is lambda”，并且强调在逻辑处理中不变性的重要性。不变到什么地步呢？原教旨主义的 FP 就连普通的循环都不可以写（因为循环都有个变化的 idx 或者条件之类的变量），必须用递归实现。这样做的结果就是把一切“状态”都消除。任何“状态”都是由确定的输入经过确定的一组函数处理得到的最终结果。 FP 适合的领域是处理数据。</p>
<p>OOP 强调“everything is object”，以及 object 之间的消息传递。通过消息传递改变每个 Object 的内部状态。OOP 之父 Alan Kay 表示”OOP is all about messaging”。利用 OOP 建模，都会通过某种消息机制来模拟一些场景的处理。比如交易=下单 Object，支付 Object，积分 Object 等之间进行交互当然，实际的 OOP 的程序运行时为了效率一般会用方法调用，而不是真的传递一个物理消息。OOP 适合的领域是企业 ERP，外包业务等。</p>
<p>如果你看懂了上面两个概念，就会发现他们说的事情压根就不在一个频道里。因此各自的好处也不能证明另一方有缺点。</p>
<p>现在经常看到文章表达 FP 如何如何优于 OOP，大概原因有这么两点：第一点是，OOP 早期不切实际的吹牛皮，吹爆了。很多人谈起 OOP，都会有“用了 OOP，代码耦合就小了，就容易维护了，扩展就方便了，代码就更容易复用了等等“的第一印象。但实际上这并不一定发生。软件设计并非因为 OOP 就直接自动变好了。因此很多程序员在趟坑多年后可能会感觉“我擦，学了这么多年，全是假的“。更进一步的，像 Java 这样的“纯 OOP”语言迫使程序员并不需要 OOP 的情况下也得照着 OOP 的方式去写代码，结果啰嗦又臃肿。所以很多人越来越讨厌 OOP 其实是可以理解的。（比如这篇 Goodbye, Objected Oriented Programming)。现在的 Java 程序大量使用反射、lambda 等技术，已经不是早期那个单纯 OOP 语言了。第二点是现代程序开始往并发发展。而 FP 的不可变，没有副作用等特性恰好让并发编程变得不容易出错。并且配合多种并发模型（如 CSP、Map Reduce、Fork &amp; Join、Promise 等），可以解决很多高并发的问题，显得高、大、上、酷。</p>
<p>但是，我非常赞同《人月神话》的著名论断——没有银弹。不论 OOP 还是 FP，用好了都可以发挥作用，用不好一样吃瘪。</p>
<p>举几个例子，一个业务领域建模，其实模拟的就是现实当中的不同角色的人/机构的工作方式。因为如果是人/机构互相协作，就是通过消息来协作的。比如博士生想发文章，先得自己写，写了老板审阅，完事发给期刊编辑，编辑找同行评议，完事发表，发表的结果会收录到某个文献索引数据库。这个过程就是多个独立的“对象”在相互协作的结果。因此 OOP 在这个层面上对这个流程进行抽象是很合适的。当然你也可以说，这时我用 FP 的各种动作函数的组织来描述这个过程，也是可以的。但是如果比较一下，这个场景用 FP 和 OOP 建模，哪个更容易理解呢？</p>
<p>再比如，对一组数据做加工，先查询，然后聚合，聚合后排序，再 join，再排序，再聚合，再转换（map）得到最终的结果。这个过程，用 FP 的函数就很自然，因为这一看就是 result = func1(func2(func3…funcN(x))))这时用 OOP 呢？给每一个步骤建一个 class？然后把排序、聚合等操作放在 class 里？抽象个基类？或者弄个 XXXUtils 的静态方法集合类？当然都可以做，但是很明显这不是个好的设计。再再比如，一个业务流程，就是一组步骤：第一步如何如何，第二部如何如何……。这时用 FP 和 OOP 都不能很好的表达问题（可能 FP 接近点）。这其实是典型的“指令式编程“。如果业务逻辑如此，那么就照着一步一步做就是最好的，而不是抽取函数和不变状态；或者定义一些根本无意义的 class。</p>
<p>说了这么多，其实希望表达的意思是：到底用哪种编程模式，要看问题本身适合哪个。哪个用起来自然，和问题本身特质搭配，那就用哪个。用对了，事半功倍；用错了，就各种纠结拧巴。你希望你一个东西模拟为 Object，前提是这个东西本身容易抽象成一个 Object；你希望你一个数据可以抽象为一组函数执行的组合，前提是这样理解更自然，更舒服。此外，同一个问题可以拆解为不同的层次，不同的层次可以使用各自适合的方式。比如高层的可以 OOP，具体到某个执行逻辑里可以用 FP 或者指令编程。</p>
<h1 id="对比面向过程，面向对象，函数式编程"><a href="#对比面向过程，面向对象，函数式编程" class="headerlink" title="对比面向过程，面向对象，函数式编程"></a>对比面向过程，面向对象，函数式编程</h1><p>函数式编程、面向对象编程和面向过程编程都是思维方式，具体语言的语法不构成限制。这三者可以当作是一条光谱上不同的颜色，一头是命令式风格，一头是声明式风格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">               ↓&lt;过程式&gt;           ↓&lt;面向对象&gt;       ↓&lt;函数式&gt;</span><br><span class="line">[命令式风格] o----------------------------------------------------&gt; [声明式风格]</span><br></pre></td></tr></table></figure>

<p>箭头从左到右抽象程度逐渐上升。过程式风格有函数的概念，和纯粹的指令相比可以用简短的函数替代一段指令；面向对象风格包装了一层 class 这样的概念，允许打包的一组数据自己持有一些信息，使用者调用方法前不需要知道所有的事情；函数式风格允许把“处理过程”本身当作参数，传入的处理过程的参数就代表具体操作时遇到的实体。<br>函数式编程就是用函数的组合来解决问题，面向对象是建很多对象来互相交互解决问题，面向过程就是下一步下一步下一步。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>输入十个整数，输出大于平均值的数，然后输出排序后的十个数面向过程/<em>C</em>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int input[10];</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">int tmp;</span><br><span class="line">double average;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;input[i]);</span><br><span class="line">  sum +&#x3D; input[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">average &#x3D; sum &#x2F; 10.0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">  if (input[i] &gt; average)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, input[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;_Bubble Sort_&#x2F;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">  for (int j &#x3D; 0; j &lt; 9 - i; j++)</span><br><span class="line">  &#123;</span><br><span class="line">    if (input[j] &gt; input[j + 1])</span><br><span class="line">    &#123;</span><br><span class="line">      tmp &#x3D; input[j];</span><br><span class="line">      input[j] &#x3D; input[j + 1];</span><br><span class="line">      input[j + 1] &#x3D; tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%d\n&quot;, input[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面向对象//C++</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class solve</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    solve() noexcept;</span><br><span class="line">    void sort();</span><br><span class="line">    void show();&#x2F;&#x2F;输出大于均值的数</span><br><span class="line">    void print();&#x2F;&#x2F;打印数组</span><br><span class="line">  private:</span><br><span class="line">    int input[10];</span><br><span class="line">    int sum;</span><br><span class="line">    double average;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;具体实现省略</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  auto test &#x3D; new solve();</span><br><span class="line">  test-&gt;show();</span><br><span class="line">  test-&gt;sort();</span><br><span class="line">  test-&gt;print();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数式编程#Python</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array &#x3D; [int(input()) for i in range(10)]</span><br><span class="line">average &#x3D; sum(array) &#x2F; 10;</span><br><span class="line">print(list(filter(lambda x: x &gt; average, array)))</span><br><span class="line">print(sorted(array))</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/26/Web%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2%E5%8F%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/26/Web%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2%E5%8F%98%E5%8C%96/" class="post-title-link" itemprop="url">Web技术历史变化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-26 21:00:00" itemprop="dateCreated datePublished" datetime="2020-12-26T21:00:00+08:00">2020-12-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-27 11:47:18" itemprop="dateModified" datetime="2020-12-27T11:47:18+08:00">2020-12-27</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、简单明快的早期时代"><a href="#一、简单明快的早期时代" class="headerlink" title="一、简单明快的早期时代"></a>一、简单明快的早期时代</h1><p><img src="/images/web/1.png"><br>可称之为 Web 1.0 时代，非常适合创业型小项目，不分前后端，经常 3-5 人搞定所有开发。页面由 JSP、PHP 等工程师在服务端生成，浏览器负责展现。基本上是服务端给什么浏览器就展现什么，展现的控制在 Web Server 层。</p>
<p>这种模式的好处是：简单明快，本地起一个 Tomcat 或 Apache 就能开发，调试什么的都还好，只要业务不太复杂。</p>
<p>然而业务总会变复杂，这是好事情，否则很可能就意味着创业失败了。业务的复杂会让 Service 越来越多，参与开发的人员也很可能从几个人快速扩招到几十人。在这种情况下，会遇到一些典型问题：</p>
<p>1、Service 越来越多，调用关系变复杂，前端搭建本地环境不再是一件简单的事。考虑团队协作，往往会考虑搭建集中式的开发服务器来解决。这种解决方案对编译型的后端开发来说也许还好，但对前端开发来说并不友好。天哪，我只是想调整下按钮样式，却要本地开发、代码上传、验证生效等好几个步骤。也许习惯了也还好，但开发服务器总是不那么稳定，出问题时往往需要依赖后端开发搞定。看似仅仅是前端开发难以本地化，但这对研发效率的影响其实蛮大。</p>
<p>2、JSP 等代码的可维护性越来越差。JSP 非常强大，可以内嵌 Java 代码。这种强大使得前后端的职责不清晰，JSP 变成了一个灰色地带。经常为了赶项目，为了各种紧急需求，会在 JSP 里揉杂大量业务代码。积攒到一定阶段时，往往会带来大量维护成本。</p>
<p>这个时期，为了提高可维护性，可以通过下面的方式实现前端的组件化：</p>
<p><img src="/images/web/1.1.png"><br>理论上，如果大家都能按照最佳实践去书写代码，那么无论是 JSP 还是 PHP，可维护性都不会差。但可维护性更多是工程含义，有时候需要通过限制带来自由，需要某种约定，使得即便是新手也不会写出太糟糕的代码。</p>
<p>如何让前后端分工更合理高效，如何提高代码的可维护性，在 Web 开发中很重要。下面我们继续来看，技术架构的演变如何解决这两个问题。</p>
<h1 id="二、后端为主的-MVC-时代"><a href="#二、后端为主的-MVC-时代" class="headerlink" title="二、后端为主的 MVC 时代"></a>二、后端为主的 MVC 时代</h1><p>为了降低复杂度，以后端为出发点，有了 Web Server 层的架构升级，比如 Structs、Spring MVC 等，这是后端的 MVC 时代。</p>
<p><img src="/images/web/2.png"><br>代码可维护性得到明显好转，MVC 是个非常好的协作模式，从架构层面让开发者懂得什么代码应该写在什么地方。为了让 View 层更简单干脆，还可以选择 Velocity、Freemaker 等模板，使得模板里写不了 Java 代码。看起来是功能变弱了，但正是这种限制使得前后端分工更清晰。然而依旧并不是那么清晰，这个阶段的典型问题是：</p>
<p>1、前端开发重度依赖开发环境。这种架构下，前后端协作有两种模式：一种是前端写 demo，写好后，让后端去套模板。淘宝早期包括现在依旧有大量业务线是这种模式。好处很明显，demo 可以本地开发，很高效。不足是还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大。另一种协作模式是前端负责浏览器端的所有开发和服务器端的 View 层模板开发，支付宝是这种模式。好处是 UI 相关的代码都是前端去写就好，后端不用太关注，不足就是前端开发重度绑定后端环境，环境成为影响前端开发效率的重要因素。</p>
<p>2、前后端职责依旧纠缠不清。Velocity 模板还是蛮强大的，变量、逻辑、宏等特性，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写出不少业务代码。还有一个很大的灰色地带是 Controller，页面路由等功能本应该是前端最关注的，但却是由后端来实现。Controller 本身与 Model 往往也会纠缠不清，看了让人咬牙的代码经常会出现在 Controller 层。这些问题不能全归结于程序员的素养，否则 JSP 就够了。</p>
<p>经常会有人吐槽 Java，但 Java 在工程化开发方面真的做了大量思考和架构尝试。Java 蛮符合马云的一句话：让平凡人做非凡事。</p>
<h1 id="三、Ajax-带来的-SPA-时代"><a href="#三、Ajax-带来的-SPA-时代" class="headerlink" title="三、Ajax 带来的 SPA 时代"></a>三、Ajax 带来的 SPA 时代</h1><p>历史滚滚往前，2004 年 Gmail 像风一样的女子来到人间，很快 2005 年 Ajax 正式提出，加上 CDN 开始大量用于静态资源存储，于是出现了 JavaScript 王者归来的 SPA （Single Page Application 单页面应用）时代。</p>
<p><img src="/images/web/3.png"><br>这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口。看起来是如此美妙，但回过头来看看的话，这与 JSP 时代区别不大。复杂度从服务端的 JSP 里移到了浏览器的 JavaScript，浏览器端变得很复杂。类似 Spring MVC，这个时代开始出现浏览器端的分层架构：</p>
<p><img src="/images/web/3.1.png"><br>对于 SPA 应用，有几个很重要的挑战：</p>
<p>1、前后端接口的约定。如果后端的接口一塌糊涂，如果后端的业务模型不够稳定，那么前端开发会很痛苦。这一块在业界有 API Blueprint 等方案来约定和沉淀接口，在阿里，不少团队也有类似尝试，通过接口规则、接口平台等方式来做。有了和后端一起沉淀的接口规则，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发。相信这一块会越做越好。</p>
<p>2、前端开发的复杂度控制。SPA 应用大多以功能交互型为主，JavaScript 代码过十万行很正常。大量 JS 代码的组织，与 View 层的绑定等，都不是容易的事情。典型的解决方案是业界的 Backbone，但 Backbone 做的事还很有限，依旧存在大量空白区域需要挑战。</p>
<p>SPA 让前端看到了一丝绿色，但依旧是在荒漠中行走。</p>
<h1 id="四、前端为主的-MV-时代"><a href="#四、前端为主的-MV-时代" class="headerlink" title="四、前端为主的 MV* 时代"></a>四、前端为主的 MV* 时代</h1><p>为了降低前端开发复杂度，除了 Backbone，还有大量框架涌现，比如 EmberJS、KnockoutJS、AngularJS 等等。这些框架总的原则是先按类型分层，比如 Templates、Controllers、Models，然后再在层内做切分，如下图：</p>
<p><img src="/images/web/4.png"><br>好处很明显：</p>
<p>1、前后端职责很清晰。前端工作在浏览器端，后端工作在服务端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 RESTful 等接口。</p>
<p>2、前端开发的复杂度可控。前端代码很重，但合理的分层，让前端代码能各司其职。这一块蛮有意思的，简单如模板特性的选择，就有很多很多讲究。并非越强大越好，限制什么，留下哪些自由，代码应该如何组织，所有这一切设计，得花一本的厚度去说明。</p>
<p>3、部署相对独立，产品体验可以快速改进。</p>
<p>但依旧有不足之处：</p>
<p>代码不能复用。比如后端依旧需要对数据做各种校验，校验逻辑无法复用浏览器端的代码。如果可以复用，那么后端的数据校验可以相对简单化。<br>全异步，对 SEO 不利。往往还需要服务端做同步渲染的降级方案。<br>性能并非最佳，特别是移动互联网环境下。<br>SPA 不能满足所有需求，依旧存在大量多页面应用。URL Design 需要后端配合，前端无法完全掌控。<br>五、Node 带来的全栈时代<br>前端为主的 MV* 模式解决了很多很多问题，但如上所述，依旧存在不少不足之处。随着 Node.js 的兴起，JavaScript 开始有能力运行在服务端。这意味着可以有一种新的研发模式：</p>
<p><img src="/images/web/5.png"><br>在这种研发模式下，前后端的职责很清晰。对前端来说，两个 UI 层各司其职：</p>
<p>1、Front-end UI layer 处理浏览器层的展现逻辑。通过 CSS 渲染样式，通过 JavaScript 添加交互功能，HTML 的生成也可以放在这层，具体看应用场景。</p>
<p>2、Back-end UI layer 处理路由、模板、数据获取、cookie 等。通过路由，前端终于可以自主把控 URL Design，这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以摆脱对展现的强关注，转而可以专心于业务逻辑层的开发。</p>
<p>通过 Node，Web Server 层也是 JavaScript 代码，这意味着部分代码可前后复用，需要 SEO 的场景可以在服务端同步渲染，由于异步请求太多导致的性能问题也可以通过服务端来缓解。前一种模式的不足，通过这种模式几乎都能完美解决掉。</p>
<p>与 JSP 模式相比，全栈模式看起来是一种回归，也的确是一种向原始开发模式的回归，不过是一种螺旋上升式的回归。</p>
<h1 id="基于-Node-的全栈模式，依旧面临很多挑战："><a href="#基于-Node-的全栈模式，依旧面临很多挑战：" class="headerlink" title="基于 Node 的全栈模式，依旧面临很多挑战："></a>基于 Node 的全栈模式，依旧面临很多挑战：</h1><p>需要前端对服务端编程有更进一步的认识。比如 network/tcp、PE 等知识的掌握。<br>Node 层与 Java 层的高效通信。Node 模式下，都在服务器端，RESTful HTTP 通信未必高效，通过 SOAP 等方式通信更高效。一切需要在验证中前行。<br>对部署、运维层面的熟练了解，需要更多知识点和实操经验。<br>大量历史遗留问题如何过渡。这可能是最大最大的阻力。<br>六、小结<br>回顾历史总是让人感慨，展望未来则让人兴奋。上面讲到的研发模式，除了最后一种还在探索期，其他各种在各大公司都已有大量实践。几点小结：</p>
<p>模式没有好坏高下之分，只有合不合适。<br>Ajax 给前端开发带来了一次质的飞跃，Node 很可能是第二次。<br>SoC（关注度分离） 是一条伟大的原则。上面种种模式，都是让前后端的职责更清晰，分工更合理高效。<br>还有个原则，让合适的人做合适的事。比如 Web Server 层的 UI Layer 开发，前端是更合适的人选。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/13/%E6%B1%87%E7%BC%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/13/%E6%B1%87%E7%BC%96/" class="post-title-link" itemprop="url">汇编</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-13 16:00:00 / Modified: 15:15:19" itemprop="dateCreated datePublished" datetime="2020-12-13T16:00:00+08:00">2020-12-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="“被调用者保存”和“调用者保存”寄存器"><a href="#“被调用者保存”和“调用者保存”寄存器" class="headerlink" title="“被调用者保存”和“调用者保存”寄存器"></a>“被调用者保存”和“调用者保存”寄存器</h2><p>编译器的设计中有个概念叫做“被调用者保存”和“调用者保存”，可以近似的按子函数保存和父函数保存对应来理解，这一概念的出现完全是由于寄存器资源个数有限造成的。当父函数在调用子函数时，由于子函数可能访问到父函数用于保存数值的寄存器，为了互不干扰和造成覆盖，编译器就制定了相应的规则，%eax、%edx 和%ecx 被划分为“调用者保存”寄存器，顾名思义，这些寄存器上面存储的值，需要调用者（父函数）自己想办法先备份好，否则过会子函数直接使用这些寄存器时将无情的覆盖。如何备份？当然是事先压入栈中，等子函数调用完，再通过出栈恢复这些寄存器原本在父函数运行时的旧值；另外三个寄存器%ebx、%esi、%edi 被划分为“被调用者保存”寄存器，同样的，这些寄存器上有值，在使用前需要被调用者（子函数）自己想办法帮调用者（父函数）进行备份，具体方法就是子函数在覆盖他们之前，先进行入栈备份，等子函数返回时，再出栈还原父函数运行时这些寄存器上的旧值。</p>
<h2 id="七种寻址方式"><a href="#七种寻址方式" class="headerlink" title="七种寻址方式"></a>七种寻址方式</h2><h3 id="1-立即寻址方式"><a href="#1-立即寻址方式" class="headerlink" title="1 立即寻址方式"></a>1 立即寻址方式</h3><p>操作数作为指令的一部分而直接写在指令中，这种操作数称为立即数，这种寻址方式也就称为立即数寻址方式。</p>
<p>立即数可以是 8 位、16 位或 32 位，该数值紧跟在操作码之后。如果立即数为 16 位或 32 位，那么，它将按“高高低低”的原则进行存储。例如：</p>
<p>MOV AH, 80H 　　　 ADD AX, 1234H 　　　 MOV ECX, 123456H<br>MOV B1, 12H 　　　 MOV W1, 3456H 　　 ADD D1, 32123456H</p>
<p>其中：B1、W1 和 D1 分别是字节、字和双字单元。</p>
<p>以上指令中的第二操作数都是立即数，在汇编语言中，规定：立即数不能作为指令中的第二操作数。该规定与高级语言中“赋值语句的左边不能是常量”的规定相一致。</p>
<p>立即数寻址方式通常用于对通用寄存器或内存单元赋初值。图是指令“MOV AX, 4576H”存储形式和执行示意图。</p>
<h3 id="2-寄存器寻址方式"><a href="#2-寄存器寻址方式" class="headerlink" title="2 寄存器寻址方式"></a>2 寄存器寻址方式</h3><p>指令所要的操作数已存储在某寄存器中，或把目标操作数存入寄存器。把在指令中指出所使用寄存器(即：寄存器的助忆符)的寻址方式称为寄存器寻址方式。<br>指令中可以引用的寄存器及其符号名称如下：<br>　　 8 位寄存器有：AH、AL、BH、BL、CH、CL、DH 和 DL 等；<br>　　 16 位寄存器有：AX、BX、CX、DX、SI、DI、SP、BP 和段寄存器等；<br>　　 32 位寄存器有：EAX、EBX、ECX、EDX、ESI、EDI、ESP 和 EBP 等。<br>寄存器寻址方式是一种简单快捷的寻址方式，源和目的操作数都可以是寄存器。</p>
<p>1、源操作数是寄存器寻址方式<br>　　如：ADD VARD, EAX 　　 ADD VARW, AX 　　　 MOV VARB, BH 等。<br>　　其中：VARD、VARW 和 VARB 是双字，字和字节类型的内存变量。在第 4 章将会学到如何定义它们。</p>
<p>2、目的操作数是寄存器寻址方式<br>　　如：ADD BH, 78h 　　　　 ADD AX, 1234h 　　　 MOV EBX, 12345678H 等。</p>
<p>3、源和目的操作数都是寄存器寻址方式<br>　　如：MOV EAX, EBX 　　　 MOV AX, BX 　　　　 MOV DH, BL 等。</p>
<p>由于指令所需的操作数已存储在寄存器中，或操作的结果存入寄存器，这样，在指令执行过程中，会减少读/写存储器单元的次数，所以，使用寄存器寻址方式的指令具有较快的执行速度。通常情况下，我们提倡在编写汇编语言程序时，应尽可能地使用寄存器寻址方式，但也不要把它绝对化。</p>
<h3 id="3-七种寻址方式-直接寻址方式"><a href="#3-七种寻址方式-直接寻址方式" class="headerlink" title="3 七种寻址方式(直接寻址方式)"></a>3 七种寻址方式(直接寻址方式)</h3><p>指令所要的操作数存放在内存中，在指令中直接给出该操作数的有效地址，这种寻址方式为直接寻址方式。</p>
<p>在通常情况下，操作数存放在数据段中，所以，其物理地址将由数据段寄存器 DS 和指令中给出的有效地址直接形成，但如果使用段超越前缀，那么，操作数可存放在其它段。</p>
<p>例：假设有指令：MOV BX, [1234H]，在执行时，(DS)=2000H，内存单元 21234H 的值为 5213H。问该指令执行后，BX 的值是什么？</p>
<p>解：根据直接寻址方式的寻址规则，把该指令的具体执行过程用下图来表示。</p>
<p>从图中，可看出执行该指令要分三部分：</p>
<p>由于 1234H 是一个直接地址，它紧跟在指令的操作码之后，随取指令而被读出；</p>
<p>访问数据段的段寄存器是 DS，所以，用 DS 的值和偏移量 1234H 相加，得存储单元的物理地址：21234H；</p>
<p>取单元 21234H 的值 5213H，并按“高高低低”的原则存入寄存器 BX 中。</p>
<p>所以，在执行该指令后，BX 的值就为 5213H。</p>
<p>由于数据段的段寄存器默认为 DS，如果要指定访问其它段内的数据，可在指令中用段前缀的方式显式地书写出来。</p>
<p>下面指令的目标操作数就是带有段前缀的直接寻址方式。</p>
<p>MOV 　 ES:[1000H], AX</p>
<p>直接寻址方式常用于处理内存单元的数据，其操作数是内存变量的值，该寻址方式可在 64K 字节的段内进行寻址。</p>
<p>注意：立即寻址方式和直接寻址方式的书写格式的不同，直接寻址的地址要写在括号“[”，“]”内。在程序中，直接地址通常用内存变量名来表示，如：MOV BX, VARW，其中，VARW 是内存字变量。</p>
<p>试比较下列指令中源操作数的寻址方式(VARW 是内存字变量)：<br>　　 MOV 　 AX, 1234H MOV 　 AX, [1234H] ;前者是立即寻址，后者是直接寻址<br>　　 MOV 　 AX, VARW MOV 　 AX, [VARW] ;两者是等效的，均为直接寻址</p>
<h3 id="4-七种寻址方式-寄存器间接寻址方式"><a href="#4-七种寻址方式-寄存器间接寻址方式" class="headerlink" title="4 七种寻址方式(寄存器间接寻址方式)"></a>4 七种寻址方式(寄存器间接寻址方式)</h3><p>操作数在存储器中，操作数的有效地址用 SI、DI、BX 和 BP 等四个寄存器之一来指定，称这种寻址方式为寄存器间接寻址方式。该寻址方式物理地址的计算方法如下：</p>
<p>寄存器间接寻址方式读取存储单元的原理如图所示。</p>
<p>在不使用段超越前缀的情况下，有下列规定：</p>
<p>若有效地址用 SI、DI 和 BX 等之一来指定，则其缺省的段寄存器为 DS；<br>若有效地址用 BP 来指定，则其缺省的段寄存器为 SS(即：堆栈段)。</p>
<p>例:假设有指令：MOV BX,[DI]，在执行时，(DS)=1000H，(DI)=2345H，存储单元 12345H 的内容是 4354H。问执行指令后，BX 的值是什么？</p>
<p>解：根据寄存器间接寻址方式的规则，在执行本例指令时，寄存器 DI 的值不是操作数，而是操作数的地址。该操作数的物理地址应由 DS 和 DI 的值形成，即：</p>
<p>PA=(DS)<em>16+DI=1000H</em>16+2345H=12345H。</p>
<p>所以，该指令的执行效果是：把从物理地址为 12345H 开始的一个字的值传送给 BX。</p>
<p>其执行过程如图所示。</p>
<h3 id="5-七种寻址方式（寄存器相对寻址方式）"><a href="#5-七种寻址方式（寄存器相对寻址方式）" class="headerlink" title="5 七种寻址方式（寄存器相对寻址方式）"></a>5 七种寻址方式（寄存器相对寻址方式）</h3><p>操作数在存储器中，其有效地址是一个基址寄存器(BX、BP)或变址寄存器(SI、D</p>
<p>I)的内容和指令中的 8 位/16 位偏移量之和。其有效地址的计算公式如公式所示。</p>
<p>在不使用段超越前缀的情况下，有下列规定：</p>
<pre><code>若有效地址用SI、DI和BX等之一来指定，则其缺省的段寄存器为DS；

若有效地址用BP来指定，则其缺省的段寄存器为SS。</code></pre>
<p>指令中给出的 8 位/16 位偏移量用补码表示。在计算有效地址时，如果偏移量是 8 位，则进行符号扩展成 16 位。当所得的有效地址超过 0FFFFH，则取其 64K 的模。</p>
<p>例:假设指令：MOV BX, [SI+100H]，在执行它时，(DS)=1000H，(SI)=2345H，内存单元 12445H 的内容为 2715H，问该指令执行后，BX 的值是什么？</p>
<p>解：根据寄存器相对寻址方式的规则，在执行本例指令时，源操作数的有效地址 EA 为：</p>
<p>EA=(SI)+100H=2345H+100H=2445H</p>
<p>该操作数的物理地址应由 DS 和 EA 的值形成，即：</p>
<p>PA=(DS)<em>16+EA=1000H</em>16+2445H=12445H。</p>
<p>所以，该指令的执行效果是：把从物理地址为 12445H 开始的一个字的值传送给 BX。</p>
<p>其执行过程如图所示。</p>
<h3 id="6-七种寻址方式-基址加变址寻址方式"><a href="#6-七种寻址方式-基址加变址寻址方式" class="headerlink" title="6 七种寻址方式(基址加变址寻址方式)"></a>6 七种寻址方式(基址加变址寻址方式)</h3><p>操作数在存储器中，其有效地址是一个基址寄存器(BX、BP)和一个变址寄存器(SI、DI)的内容之和。其有效地址的计算公式如公式所示。</p>
<p>在不使用段超越前缀的情况下，规定：如果有效地址中含有 BP，则缺省的段寄存器为 SS；否则，缺省的段寄存器为 DS。</p>
<p>例:假设指令：MOV BX, [BX+SI]，在执行时，(DS)=1000H，(BX)=2100H，(SI)=0011H，内存单元 12111H 的内容为 1234H。问该指令执行后，BX 的值是什么？</p>
<p>解：根据基址加变址寻址方式的规则，在执行本例指令时，源操作数的有效地址 EA 为：</p>
<p>EA=(BX)+(SI)=2100H+0011H=2111H</p>
<p>该操作数的物理地址应由 DS 和 EA 的值形成，即：</p>
<p>PA=(DS)<em>16+EA=1000H</em>16+2111H=12111H</p>
<p>所以，该指令的执行效果是：把从物理地址为 12111H 开始的一个字的值传送给 BX。</p>
<p>其执行过程如图所示。</p>
<h3 id="7-七种寻址方式-相对基址加变址寻址方式"><a href="#7-七种寻址方式-相对基址加变址寻址方式" class="headerlink" title="7 七种寻址方式(相对基址加变址寻址方式)"></a>7 七种寻址方式(相对基址加变址寻址方式)</h3><p>操作数在存储器中，其有效地址是一个基址寄存器(BX、BP)的值、一个变址寄存器(SI、DI)的值和指令中的 8 位/16 位偏移量之和。其有效地址的计算公式如公式所示。</p>
<p>在不使用段超越前缀的情况下，规定：如果有效地址中含有 BP，则其缺省的段寄存器为 SS；否则，其缺省的段寄存器为 DS。</p>
<p>指令中给出的 8 位/16 位偏移量用补码表示。在计算有效地址时，如果偏移量是 8 位，则进行符号扩展成 16 位。当所得的有效地址超过 0FFFFH，则取其 64K 的模。</p>
<p>例:假设指令：MOV AX, [BX+SI+200H]，在执行时，(DS)=1000H，(BX)=2100H，(SI)=0010H，内存单元 12310H 的内容为 1234H。问该指令执行后，AX 的值是什么？</p>
<p>解：根据相对基址加变址寻址方式的规则，在执行本例指令时，源操作数的有效地址 EA 为：</p>
<p>EA=(BX)+(SI)+200H=2100H+0010H+200H=2310H</p>
<p>该操作数的物理地址应由 DS 和 EA 的值形成，即：</p>
<p>PA=(DS)<em>16+EA=1000H</em>16+2310H=12310H</p>
<p>所以，该指令的执行效果是：把从物理地址为 12310H 开始的一个字的值传送给 AX。其执行过程如图所示。</p>
<p>从相对基址加变址这种寻址方式来看，由于它的可变因素较多，看起来就显得复杂些，但正因为其可变因素多，它的灵活性也就很高。比如：</p>
<p>用 D1[i]来访问一维数组 D1 的第 i 个元素，它的寻址有一个自由度，用 D2[i][j]来访问二维数组 D2 的第 i 行、第 j 列的元素，其寻址有二个自由度。多一个可变的量，其寻址方式的灵活度也就相应提高了。</p>
<p>相对基址加变址寻址方式有多种等价的书写方式，下面的书写格式都是正确的，并且其寻址含义也是一致的。</p>
<p>MOV 　 AX, [BX+SI+1000H]　　　 MOV 　 AX, 1000H[BX+SI]<br>MOV 　 AX, 1000H[BX][si]　　　 MOV 　 AX, 1000H[SI][bx]</p>
<p>但书写格式 BX [1000+SI]和 SI[1000H+BX]等是错误的，即所用寄存器不能在“[“，”]”之外，该限制对寄存器相对寻址方式的书写也同样起作用。</p>
<p>相对基址加变址寻址方式是以上 7 种寻址方式中最复杂的一种寻址方式，它可变形为其它类型的存储器寻址方式。下表列举出该寻址方式与其它寻址方式之间的变形关系。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/07/KAFKA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/07/KAFKA/" class="post-title-link" itemprop="url">KAFKA</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-07 16:07:30" itemprop="dateCreated datePublished" datetime="2020-12-07T16:07:30+08:00">2020-12-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-23 17:54:43" itemprop="dateModified" datetime="2021-04-23T17:54:43+08:00">2021-04-23</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/images/kafka-1.png"></p>
<h2 id="1-根目录下的结构"><a href="#1-根目录下的结构" class="headerlink" title="1.根目录下的结构"></a>1.根目录下的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 72] ls &#x2F;</span><br><span class="line">[isr_change_notification, zookeeper, admin, consumers, cluster, config, latest_producer_id_block, controller, brokers, controller_epoch]</span><br></pre></td></tr></table></figure>

<h2 id="2-admin-的结构"><a href="#2-admin-的结构" class="headerlink" title="2. admin 的结构"></a>2. admin 的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 73] ls &#x2F;admin</span><br><span class="line">[delete_topics]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 74] ls &#x2F;admin&#x2F;delete_topics</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 75] get &#x2F;admin&#x2F;delete_topics</span><br><span class="line">null</span><br><span class="line">cZxid &#x3D; 0xe</span><br><span class="line">ctime &#x3D; Sun Sep 02 20:04:12 PDT 2018</span><br><span class="line">mZxid &#x3D; 0xe</span><br><span class="line">mtime &#x3D; Sun Sep 02 20:04:12 PDT 2018</span><br><span class="line">pZxid &#x3D; 0xe</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x0</span><br><span class="line">dataLength &#x3D; 0</span><br><span class="line">numChildren &#x3D; 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 76]</span><br></pre></td></tr></table></figure>

<h2 id="3-consumers-的结构"><a href="#3-consumers-的结构" class="headerlink" title="3.consumers 的结构"></a>3.consumers 的结构</h2><p>本环境上没有设置消费组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 78] ls &#x2F;consumers</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 79] get &#x2F;consumers</span><br><span class="line">null</span><br><span class="line">cZxid &#x3D; 0x2</span><br><span class="line">ctime &#x3D; Sun Sep 02 20:04:12 PDT 2018</span><br><span class="line">mZxid &#x3D; 0x2</span><br><span class="line">mtime &#x3D; Sun Sep 02 20:04:12 PDT 2018</span><br><span class="line">pZxid &#x3D; 0x2</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x0</span><br><span class="line">dataLength &#x3D; 0</span><br><span class="line">numChildren &#x3D; 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 80]</span><br><span class="line">## 4.config的结构</span><br><span class="line">[zk: localhost:2181(CONNECTED) 82] ls &#x2F;config</span><br><span class="line">[topics, clients, changes]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 83] ls &#x2F;config&#x2F;topics</span><br><span class="line">[__consumer_offsets, test, test2]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 84] ls &#x2F;config&#x2F;topics&#x2F;test2</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 85] get &#x2F;config&#x2F;topics&#x2F;test2</span><br><span class="line">&#123;&quot;version&quot;:1,&quot;config&quot;:&#123;&#125;&#125;</span><br><span class="line">cZxid &#x3D; 0xcc</span><br><span class="line">ctime &#x3D; Sun Sep 02 20:18:06 PDT 2018</span><br><span class="line">mZxid &#x3D; 0xcc</span><br><span class="line">mtime &#x3D; Sun Sep 02 20:18:06 PDT 2018</span><br><span class="line">pZxid &#x3D; 0xcc</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x0</span><br><span class="line">dataLength &#x3D; 25</span><br><span class="line">numChildren &#x3D; 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 86]</span><br></pre></td></tr></table></figure>

<h2 id="5-controllers-的结构"><a href="#5-controllers-的结构" class="headerlink" title="5.controllers 的结构"></a>5.controllers 的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 92] ls &#x2F;controller</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 93] get &#x2F;controller</span><br><span class="line">&#123;&quot;version&quot;:1,&quot;brokerid&quot;:0,&quot;timestamp&quot;:&quot;1535943857541&quot;&#125; &#x2F;&#x2F;表示broker0为kafka的控制节点</span><br><span class="line">cZxid &#x3D; 0x15</span><br><span class="line">ctime &#x3D; Sun Sep 02 20:04:17 PDT 2018</span><br><span class="line">mZxid &#x3D; 0x15</span><br><span class="line">mtime &#x3D; Sun Sep 02 20:04:17 PDT 2018</span><br><span class="line">pZxid &#x3D; 0x15</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x1659d6268f60000</span><br><span class="line">dataLength &#x3D; 54</span><br><span class="line">numChildren &#x3D; 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 94]</span><br><span class="line">## 6.brokers的结构</span><br><span class="line">[zk: localhost:2181(CONNECTED) 95] ls &#x2F;brokers</span><br><span class="line">[seqid, topics, ids]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 96] ls &#x2F;brokers&#x2F;ids</span><br><span class="line">[0]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 97] get &#x2F;brokers&#x2F;ids&#x2F;0</span><br><span class="line">&#123;&quot;listener_security_protocol_map&quot;:&#123;&quot;PLAINTEXT&quot;:&quot;PLAINTEXT&quot;&#125;,&quot;endpoints&quot;:[&quot;PLAINTEXT:&#x2F;&#x2F;localhost:9092&quot;],&quot;jmx_port&quot;:-1,&quot;host&quot;:&quot;localhost&quot;,&quot;timestamp&quot;:&quot;1535943859255&quot;,&quot;port&quot;:9092,&quot;version&quot;:4&#125;</span><br><span class="line">cZxid &#x3D; 0x1c</span><br><span class="line">ctime &#x3D; Sun Sep 02 20:04:19 PDT 2018</span><br><span class="line">mZxid &#x3D; 0x1c</span><br><span class="line">mtime &#x3D; Sun Sep 02 20:04:19 PDT 2018</span><br><span class="line">pZxid &#x3D; 0x1c</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x1659d6268f60000</span><br><span class="line">dataLength &#x3D; 188</span><br><span class="line">numChildren &#x3D; 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 98]</span><br><span class="line"></span><br><span class="line">------------------------------brokers&#x2F;topics----------------------</span><br><span class="line">[zk: localhost:2181(CONNECTED) 100] ls &#x2F;brokers&#x2F;topics</span><br><span class="line">[__consumer_offsets, test, test2]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 101] ls &#x2F;brokers&#x2F;topics&#x2F;test</span><br><span class="line"></span><br><span class="line">test    test2</span><br><span class="line">[zk: localhost:2181(CONNECTED) 101] ls &#x2F;brokers&#x2F;topics&#x2F;test2</span><br><span class="line">[partitions]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 102] ls &#x2F;brokers&#x2F;topics&#x2F;test2&#x2F;partitions</span><br><span class="line">[2, 1, 0]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 103] ls &#x2F;brokers&#x2F;topics&#x2F;test2&#x2F;partitions&#x2F;2</span><br><span class="line">[state]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 104] ls &#x2F;brokers&#x2F;topics&#x2F;test2&#x2F;partitions&#x2F;2&#x2F;state</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 105] get &#x2F;brokers&#x2F;topics&#x2F;test2&#x2F;partitions&#x2F;2&#x2F;state</span><br><span class="line">&#123;&quot;controller_epoch&quot;:1,&quot;leader&quot;:0,&quot;version&quot;:1,&quot;leader_epoch&quot;:0,&quot;isr&quot;:[0]&#125;</span><br><span class="line">&#x2F;&#x2F;表示partition 0 的leader是在0 broker上</span><br><span class="line">cZxid &#x3D; 0xd2</span><br><span class="line">ctime &#x3D; Sun Sep 02 20:18:06 PDT 2018</span><br><span class="line">mZxid &#x3D; 0xd2</span><br><span class="line">mtime &#x3D; Sun Sep 02 20:18:06 PDT 2018</span><br><span class="line">pZxid &#x3D; 0xd2</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x0</span><br><span class="line">dataLength &#x3D; 72</span><br><span class="line">numChildren &#x3D; 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 106]</span><br></pre></td></tr></table></figure>

<h2 id="6-深入理解生产者和消费者"><a href="#6-深入理解生产者和消费者" class="headerlink" title="6.深入理解生产者和消费者"></a>6.深入理解生产者和消费者</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mcbye/p/kafka-producer-in-detail.html">https://www.cnblogs.com/mcbye/p/kafka-producer-in-detail.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mcbye/p/kafka-consumer-in-detail.html">https://www.cnblogs.com/mcbye/p/kafka-consumer-in-detail.html</a></p>
<h2 id="7-重平衡"><a href="#7-重平衡" class="headerlink" title="7.重平衡"></a>7.重平衡</h2><p>说完消费者组，再来说说与消费者组息息相关的重平衡机制。重平衡可以说是 kafka 为人诟病最多的一个点了。</p>
<p>重平衡其实就是一个协议，它规定了如何让消费者组下的所有消费者来分配 topic 中的每一个分区。比如一个 topic 有 100 个分区，一个消费者组内有 20 个消费者，在协调者的控制下让组内每一个消费者分配到 5 个分区，这个分配的过程就是重平衡。</p>
<p>重平衡的触发条件主要有三个：</p>
<ul>
<li>消费者组内成员发生变更，这个变更包括了增加和减少消费者。注意这里的减少有很大的可能是被动的，就是某个消费者崩溃退出了</li>
<li>主题的分区数发生变更，kafka 目前只支持增加分区，当增加的时候就会触发重平衡</li>
<li>订阅的主题发生变化，当消费者组使用正则表达式订阅主题，而恰好又新建了对应的主题，就会触发重平衡</li>
</ul>
<p>为什么说重平衡为人诟病呢？因为重平衡过程中，消费者无法从 kafka 消费消息，这对 kafka 的 TPS 影响极大，而如果 kafka 集内节点较多，比如数百个，那重平衡可能会耗时极多。数分钟到数小时都有可能，而这段时间 kafka 基本处于不可用状态。所以在实际环境中，应该尽量避免重平衡发生。</p>
<p>了解了什么是重平衡，重平衡的缺点和触发条件后，我们先来看看重平衡的三种不同策略，然后说说应该如何避免重平衡发生。</p>
<h4 id="三种重平衡策略"><a href="#三种重平衡策略" class="headerlink" title="三种重平衡策略"></a>三种重平衡策略</h4><p>kafka 提供了三种重平衡分配策略，这里顺便介绍一下：</p>
<h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p>具体实现位于，package org.apache.kafka.clients.consumer.RangeAssignor。</p>
<p>这种分配是基于每个主题的分区分配，如果主题的分区分区不能平均分配给组内每个消费者，那么对该主题，某些消费者会被分配到额外的分区。我们来看看具体的例子。</p>
<p>举例：目前有两个消费者 C0 和 C1，两个主题 t0 和 t1，每个主题三个分区，分别是 t0p0，t0p1，t0p2，和 t1p0，t1p1，t1p2。</p>
<p>那么分配情况会是：</p>
<ul>
<li>C0：t0p0, t0p1, t1p0, t1p1</li>
<li>C1：t0p2, t1p2</li>
</ul>
<p>我来大概解释一下，range 这种模式，消费者被分配的单位是基于主题的，拿上面的例子来说，是主题 t0 的三个分区分配给 2 个消费者，t1 三个分区分配给消费者。于是便会出现消费者 c0 分配到主题 t0 两个分区，以及 t1 两个分区的情况（一个主题有三个分区，三个分区无法匹配两个消费者，势必有一个消费者分到两个分区），而非每个消费者分配两个主题各三个分区。</p>
<h4 id="RoundRobin"><a href="#RoundRobin" class="headerlink" title="RoundRobin"></a>RoundRobin</h4><p>具体实现位于，package org.apache.kafka.clients.consumer.RoundRobinAssignor。</p>
<p>RoundRobin 是基于全部主题的分区来进行分配的，同时这种分配也是 kafka 默认的 rebalance 分区策略。还是用刚刚的例子来看，</p>
<p>举例：两个消费者 C0 和 C1，两个主题 t0 和 t1，每个主题三个分区，分别是 t0p0，t0p1，t0p2，和 t1p0，t1p1，t1p2。</p>
<p>由于是基于全部主题的分区，那么分配情况会是：</p>
<ul>
<li>C0：t0p0, t0p1, t1p1</li>
<li>C1：t1p0, t0p2, t1p2<br>因为是基于全部主题的分区来平均分配给消费者，所以这种分配策略能更加均衡得分配分区给每一个消费者。</li>
</ul>
<p>上面说的都是同一消费者组内消费组都订阅相同主题的情况。更复杂的情况是，同一组内的消费者订阅不同的主题，那么任然可能会导致分区不均衡的情况。</p>
<p>还是举例说明，有三个消费者 C0，C1，C2 。三个主题 t0，t1，t2，分别有 1，2，3 个分区 t0p0，t1p0，t1p1，t2p0，t2p1，t2p2。</p>
<p>其中，C0 订阅 t0，C1 订阅 t0，t1。C2 订阅 t0，t1，t2。最终订阅情况如下：</p>
<ul>
<li>C0：t0p0</li>
<li>C1：t1p0</li>
<li>C2：t1p1，t2p0，t2p1，t2p2<br>这个结果乍一看有点迷，其实可以这样理解，按照序号顺序进行循环分配，t0 只有一个分区，先碰到 C0 就分配给它了。t1 有两个分区，被 C1 和 C2 订阅，那么会循环将两个分区分配出去，最后到 t2，有三个分区，却只有 C2 订阅，那么就将三个分区分配给 C2。</li>
</ul>
<h4 id="Sticky"><a href="#Sticky" class="headerlink" title="Sticky"></a>Sticky</h4><p>Sticky 分配策略是最新的也是最复杂的策略，其具体实现位于 package org.apache.kafka.clients.consumer.StickyAssignor。</p>
<p>这种分配策略是在 0.11.0 才被提出来的，主要是为了一定程度解决上面提到的重平衡非要重新分配全部分区的问题。称为粘性分配策略。</p>
<p>听名字就知道，主要是为了让目前的分配尽可能保持不变，只挪动尽可能少的分区来实现重平衡。</p>
<p>还是举例说明，有三个消费者 C0，C1，C2 。三个主题 t0，t1，t2，t3。每个主题各有两个分区， t0p0，t0p1，t1p0，t1p1，t2p0，t2p1，t3p0，t3p1。</p>
<p>现在订阅情况如下：</p>
<ul>
<li>C0：t0p0，t1p1，t3p0</li>
<li>C1：t0p1，t2p0，t3p1</li>
<li>C2：t1p0，t2p1</li>
</ul>
<p>假设现在 C1 挂掉了，如果是 RoundRobin 分配策略，那么会变成下面这样：</p>
<ul>
<li>C0：t0p0，t1p0，t2p0，t3p0</li>
<li>C2：t0p1，t1p1，t2p1，t3p1</li>
</ul>
<p>就是说它会全部重新打乱，再分配，而如何使用 Sticky 分配策略，会变成这样：</p>
<ul>
<li>C0：t0p0，t1p1，t3p0，t2p0</li>
<li>C2：t1p0，t2p1，t0p1，t3p1</li>
</ul>
<p>也就是说，尽可能保留了原来的分区情况，不去改变它，在这个基础上进行均衡分配，不过这个策略目前似乎还有些 bug，所以实际使用也不多。</p>
<h4 id="避免重平衡"><a href="#避免重平衡" class="headerlink" title="避免重平衡"></a>避免重平衡</h4><p>要说完全避免重平衡，那是不可能滴，因为你无法完全保证消费者不会故障。而消费者故障其实也是最常见的引发重平衡的地方，所以这里主要介绍如何尽力避免消费者故障。</p>
<p>而其他几种触发重平衡的方式，增加分区，或是增加订阅的主题，抑或是增加消费者，更多的是主动控制，这里也不多讨论。</p>
<p>首先要知道，如果消费者真正挂掉了，那我们是没有什么办法的，但实际中，会有一些情况，会让 kafka 错误地认为一个正常的消费者已经挂掉了，我们要的就是避免这样的情况出现。</p>
<p>当然要避免，那首先要知道哪些情况会出现错误判断挂掉的情况。在分布式系统中，通常是通过心跳来维持分布式系统的，kafka 也不例外。对这部分内容有兴趣可以看看我之前的这篇分布式系统一致性问题与 Raft 算法（上）。这里要说的是，在分布式系统中，由于网络问题你不清楚没接收到心跳，是因为对方真正挂了还是只是因为负载过重没来得及发生心跳或是网络堵塞。所以一般会约定一个时间，超时即判定对方挂了。而在 kafka 消费者场景中，session.timout.ms 参数就是规定这个超时时间是多少。</p>
<p>还有一个参数，heartbeat.interval.ms，这个参数控制发送心跳的频率，频率越高越不容易被误判，但也会消耗更多资源。</p>
<p>此外，还有最后一个参数，max.poll.interval.ms，我们都知道消费者 poll 数据后，需要一些处理，再进行拉取。如果两次拉取时间间隔超过这个参数设置的值，那么消费者就会被踢出消费者组。也就是说，拉取，然后处理，这个处理的时间不能超过 max.poll.interval.ms 这个参数的值。这个参数的默认值是 5 分钟，而如果消费者接收到数据后会执行耗时的操作，则应该将其设置得大一些。</p>
<p>小结一下，其实主要就是三个参数，session.timout.ms 控制心跳超时时间，heartbeat.interval.ms 控制心跳发送频率，以及 max.poll.interval.ms 控制 poll 的间隔。这里给出一个相对较为合理的配置，如下：</p>
<p>session.timout.ms：设置为 6s<br>heartbeat.interval.ms：设置 2s<br>max.poll.interval.ms：推荐为消费者处理消息最长耗时再加 1 分钟</p>
<h2 id="8-无法消费消息"><a href="#8-无法消费消息" class="headerlink" title="8.无法消费消息"></a>8.无法消费消息</h2><p>kafka 消费不到数据的原因，首先检查配置之类的，如是否设置了 group.id，对应的 topic 是否正确等等，这些不多说。</p>
<p>下面是我遇到的几种 kafka 消费不到数据的情况：</p>
<h4 id="8-1-重复消费"><a href="#8-1-重复消费" class="headerlink" title="8.1 重复消费"></a>8.1 重复消费</h4><p>参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d63c1576e6cc">https://www.jianshu.com/p/d63c1576e6cc</a><br>下面进行详细分析：</p>
<p>“消费确认”是所有消息中间件都要解决的一个问题，在 kafka 中涉及到两个消费位置：</p>
<p>（1）当前取消息所在的 consume offset；</p>
<p>（2）程序处理完毕发送 ack（确认字符）后所确定的 committed offset。</p>
<p>很显然，在异步模式下，committed offset 要落后于 consume offset。假如 consumer 挂了重启，那么它将从 commited offset 位置处开始重新消费，而不是 consume offset 位置，这也就意味着很可能重复消费，所以会导致一条数据也抓不到。</p>
<p>那么怎么解决这个问题呢？</p>
<p>答案就是自己保存 commited offset，而不是依赖 kafka 的集群保存 commited offset，把消息的处理和保存 offset 做成一个原子操作。</p>
<p>如何将消息的处理和保存 offset 做成一个原子操作呢，Kafka 的官方文档列举了自己保存 offset 的两种使用场景：<br><img src="/images/kafka-2.png"><br>要自己保存 committed offset，就要做到以下几个操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Configure enable.auto.commit&#x3D;false   &#x2F;&#x2F;禁用自动ack</span><br><span class="line">Use the offset provided with each ConsumerRecord to save your position. &#x2F;&#x2F;每次取到消息，把对应的offset存下来</span><br><span class="line">On restart restore the position of the consumer using seek(TopicPartition, long).&#x2F;&#x2F;下次重启，通过consumer.seek函数，定位到自己保存的offset，从那开始消费</span><br></pre></td></tr></table></figure>

<p>Kafka 本身的机制只能保证消息不漏，即”at least once”，而通过自己来保存 committed offset，我们可以实现消费端的消息不重，即”exactly once”，达到消息不重不丢的目的。</p>
<h4 id="8-2-消息被清理掉"><a href="#8-2-消息被清理掉" class="headerlink" title="8.2 消息被清理掉"></a>8.2 消息被清理掉</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sylvialucy/p/7827044.html">https://www.cnblogs.com/sylvialucy/p/7827044.html</a></p>
<p>1.长时间不消费导致 log.retention.hours 或者 log.retention.minutes 超时，清除 log，Offset.Stored 失效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.Assign(new List&lt;TopicPartitionOffset&gt;()&#123; new TopicPartitionOffset(new TopicPartition(&quot;topic&quot;, 1), new Offset(index)) &#125;);</span><br></pre></td></tr></table></figure>

<p>2.我一次加数据太多导致磁盘耗尽，kafka 管理员帮我改到 20G 内存，但是仍然有一部分数据超出，分区 offset 靠前的数据被清除，导致再次消费不到。清除掉的数据无法再次被消费，但是还保存的数据可以消费到.</p>
<p>解决办法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.Assign(new List&lt;TopicPartitionOffset&gt;()&#123; new TopicPartitionOffset(new TopicPartition(&quot;topic&quot;, 1), Offset.Beginning) &#125;);</span><br></pre></td></tr></table></figure>

<p>或者在配置中加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto.offset.reset&#x3D;smallest &#x2F;&#x2F;.NET 默认是largest</span><br><span class="line">auto.offset.reset&#x3D;earliest&#x2F;&#x2F;Java 默认是latest</span><br></pre></td></tr></table></figure>

<h4 id="8-3-kafka-手动清除-topic"><a href="#8-3-kafka-手动清除-topic" class="headerlink" title="8.3 kafka 手动清除 topic"></a>8.3 kafka 手动清除 topic</h4><p>当手动删除 Kafka 某一分片上的消息日志时，如上图蓝线所示，此是只是将 Kafka Log 中的信息清 0 了，但是 Zookeeper 中的 Partition 和 Offset 数据依然会记录。当重新启动 Kafka 后，我们会发现如下二种情况：</p>
<pre><code> A、客户端无法正常用消费；

 B、在使用Kafka Consumer Offset  Monitor工具进行Kafka监控时会发现Lag(还有多少消息数未读取(Lag=logSize-Offset))为负数；其中此种情况的删除操作需要我们重点关注，后面我们也会详细介绍其对应的操作步骤。</code></pre>
<p>一般正常情况，如果想让 Kafka 客户端正常消费，那么需要 Zookeeper 和 Kafka Log 中的记录保持如上图黄色所示。<br>二、Kafka 消息日志清除</p>
<p>操作步骤主要包括：</p>
<pre><code> 1、停止Kafka运行；

 2、删除Kafka消息日志；

 3、修改ZK的偏移量；

 4、重启Kafka;</code></pre>
<p>上述步骤重点介绍其中的关键步骤。</p>
<p>第 2 步：删除 Kafka 消息日志时，进入 Kafka 消息日志路径（可通过查看$KAFKA_HOME/config/server.properties 中的“log.dirs”知晓），删除相应 topic 文件夹下所有文件(如：“rm -rf ./topicA”)；</p>
<p>第 3 步：修改 ZK 的偏移量时，进入 ZK 的安装目录下，运行./bin/zkCli.sh -server (中间以，分割)，如果不带 server 默认修改的为本机。</p>
<p>示例如下：</p>
<pre><code> A.运行$ZOOKEEPER_HOME/bin/zkCli.sh -server Master:2181,Slave1:2181,Slave2:2181

 B.在ZK上运行ls /consumers/对应的分组/offset/对应的topic,就可以看到此topic下的所有分区了；

  通过get /consumers/对应的分组/offset/对应的topic/对应的分区号，可以查询到该分区上记录的offset;

  通过set /consumers/对应的分组/offset/对应的topic/对应的分区号 修改后的值（一般为0，重置），即可完成对offset的修改；</code></pre>
<p>（注意：B 步骤中的“/consumers”由实际配置情况决定）</p>
<p>三、重建 Topic</p>
<pre><code>操作步骤主要包括如下：

  1、删除Topic;

  2、删除log日志；

  3、删除ZK中的Topic记录</code></pre>
<p>第一步：删除 Topic</p>
<p>运行$KAFKA_HOME/bin/kafka-topics.sh -delete -zookeeper [zookeeper server] -topic [topic name]；如果 kafka 启动时加载的配置文件 server.properties 没有配置 delete.topic.enable = true,那么此时的删除并不是真正的删除。而只是把 topic 标记为：marked for deletion,此时就需要执行第 3 步的操作；</p>
<p>第三步：删除 ZK 中的 Topic 记录</p>
<p>示例如下：</p>
<pre><code> A.运行$ZOOKEEPER_HOME/bin/zkCli.sh -server Master:2181,Slave1:2181,Slave2:2181

 B.进入/admin/delete_topics目录下，找到删除的topic,删除对应的信息。</code></pre>
<p>四、重新启动 Kafka 集群</p>
<h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p>Kafka 使用 Zookeeper 的临时节点来选举控制器, 并在节点加入集群或退出集群时通知控制器。控制器负责在节点加入或离开集群时进行分区首领选举。控制器使用 epoch 来避免“脑裂” 。“脑裂 ”是指两个节点同时认为自己是 当前的控制器。</p>
<p><strong>脑裂问题</strong></p>
<ul>
<li><p>什么是脑裂？<br>kafka 中只有一个控制器 controller 负责分区的 leader 选举，同步 broker 的新增或删除消息，但有时由于网络问题，可能同时有两个 broker 认为自己是 controller，这时候其他的 broker 就会发生脑裂，不知道该听从谁的。</p>
</li>
<li><p>如何解决？controller epoch<br>每当新的 controller 产生的时候就会在 zk 中生成一个全新的、数值更大的 controller epoch 的标识，并同步给其他的 broker 进行保存，这样当第二个 controller 发送指令时，其他的 broker 就会自动忽略。</p>
</li>
<li><p>选举问题?<br>每个消息有自己的 topic 每个 topic 有多个分区 多个分区位于不同的 broker 每个分区有一个主分区和多个从分区。</p>
</li>
</ul>
<p>每个分区都有一个主分区（leader）和多个从分区（fowller) 当一个 broker 宕机时，存在与该 broker 的主分区也会停止服务，因此要重新选举新的 leader 分区。</p>
<ul>
<li>如何选举?<br>控制器会从 zk 中读取 ISR 列表 选取下一个有效的分区副本成为新的 leader</li>
</ul>
<p>Kafka 会在 Zookeeper 上针对每个 Topic 维护一个称为 ISR（in-sync replica，已同步的副本）的集合，该集合中是一些分区的副本。如果这个集合有增减，kafka 会更新 zookeeper 上的记录。</p>
<h2 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h2><p>在 kafka 架构中，通信涉及到以下几点：</p>
<ol>
<li>producer 向 broker 集群生产数据数据 push 形式；</li>
<li>consumer 从 broker 集群消费数据属于 pull 形式；</li>
<li>broker 之间在 replication.factor&gt;1 时，会存在副本之间数据同步，表现为：follower partition 从 leader partition pull 数据，来保证最大限度的拉近 partition 数据不一致。</li>
</ol>
<h2 id="Kafka-Stream"><a href="#Kafka-Stream" class="headerlink" title="Kafka Stream"></a>Kafka Stream</h2><p>支持的功能展示：</p>
<ul>
<li>字数统计这个例子用于演示 map 与 filter 模式以及简单的聚合</li>
<li>另一个股票交易试产的各种统计信息，用于演示基于时间窗口的聚合</li>
<li>最后使用填充点击事件流的例子来演示流的连接</li>
</ul>
<h3 id="KTable"><a href="#KTable" class="headerlink" title="KTable"></a>KTable</h3><p>KTable 可以存储状态，分为两种，内存和磁盘。磁盘依赖于 rockdb，内存依赖于 map。<br>KTable 具有容错功能，使用 kafka 存储事件流，用于恢复。<br>当使用基于 rockdb 的状态存储时，KTable 会优先从本地恢复，如果本地文件丢失则从 kafka 的 change log 事件流 topic 中，回放消息来恢复。<br>当使用基于内存的状态存储时，KTable 会直接从 kafka 的 change log 事件流 topic 中，回放消息来恢复。</p>
<h2 id="Kafka-Connect-有待了解？？？"><a href="#Kafka-Connect-有待了解？？？" class="headerlink" title="Kafka Connect 有待了解？？？"></a>Kafka Connect 有待了解？？？</h2><h2 id="Kafka-分区选择源码实现"><a href="#Kafka-分区选择源码实现" class="headerlink" title="Kafka 分区选择源码实现"></a>Kafka 分区选择源码实现</h2><p>消息 key 为空时，如果有缓存分区，使用缓存分区，没有缓存则随机选择<br>消息 key 不为空时，对 key 进行 HASH，然后对分区数取模<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/liangwenmail/article/details/108321143#:~:text=StickyPartitionCache%20%E6%98%AF%20Kafka%20Client%20%E5%86%85%E9%83%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%8C%E7%94%A8%E4%BA%8E%E7%AE%A1%E7%90%86%20Topic%20%E7%9A%84%E5%88%86%E5%8C%BA%E9%80%89%E6%8B%A9%E7%9A%84%E9%80%BB%E8%BE%91%E5%92%8C%E7%BC%93%E5%AD%98%E3%80%82,1%202%203%204%205%206%207%208">https://blog.csdn.net/liangwenmail/article/details/108321143#:~:text=StickyPartitionCache%20%E6%98%AF%20Kafka%20Client%20%E5%86%85%E9%83%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%8C%E7%94%A8%E4%BA%8E%E7%AE%A1%E7%90%86%20Topic%20%E7%9A%84%E5%88%86%E5%8C%BA%E9%80%89%E6%8B%A9%E7%9A%84%E9%80%BB%E8%BE%91%E5%92%8C%E7%BC%93%E5%AD%98%E3%80%82,1%202%203%204%205%206%207%208</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020515457">https://segmentfault.com/a/1190000020515457</a><br><a target="_blank" rel="noopener" href="https://www.confluent.io/blog/apache-kafka-producer-improvements-sticky-partitioner/">https://www.confluent.io/blog/apache-kafka-producer-improvements-sticky-partitioner/</a></p>
<h2 id="Kafka-消费者蛇者偏移量"><a href="#Kafka-消费者蛇者偏移量" class="headerlink" title="Kafka 消费者蛇者偏移量"></a>Kafka 消费者蛇者偏移量</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/93637932">https://blog.csdn.net/zzti_erlie/article/details/93637932</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
