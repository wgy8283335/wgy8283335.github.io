<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/page/3/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'default'
  };
</script>
<title>Hexo</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/26/Tomcat%E8%BF%B7%E4%BD%A0%E7%89%88%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/26/Tomcat%E8%BF%B7%E4%BD%A0%E7%89%88%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Tomcat迷你版实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-26 23:00:00" itemprop="dateCreated datePublished" datetime="2020-12-26T23:00:00+08:00">2020-12-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-27 14:50:35" itemprop="dateModified" datetime="2020-12-27T14:50:35+08:00">2020-12-27</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Tomcat 是非常流行的 Web Server，它还是一个满足 Servlet 规范的容器。那么想一想，Tomcat 和我们的 Web 应用是什么关系？</p>
<p>从感性上来说，我们一般需要把 Web 应用打成 WAR 包部署到 Tomcat 中，在我们的 Web 应用中，我们要指明 URL 被哪个类的哪个方法所处理「不论是原始的 Servlet 开发，还是现在流行的 Spring MVC 都必须指明」。</p>
<p>由于我们的 Web 应用是运行在 Tomcat 中，请求必定是先到达 Tomcat 的。Tomcat 对于请求实际上会进行如下的处理。</p>
<p>第一，提供 Socket 服务</p>
<p>Tomcat 的启动，必然是 Socket 服务，只不过它支持 HTTP 协议而已！</p>
<p>这里其实可以扩展思考下，Tomcat 既然是基于 Socket，那么是基于 BIO or NIO or AIO 呢？</p>
<p>第二，进行请求的分发</p>
<p>要知道一个 Tomcat 可以为多个 Web 应用提供服务，很显然，Tomcat 可以把 URL 下发到不同的 Web 应用。</p>
<p>第三，需要把请求和响应封装成 request/response</p>
<p>我们在 Web 应用这一层，可从来没有封装过 request/response 的，我们都是直接使用的，这就是因为 Tomcat 已经为你做好了！</p>
<p>话不多说，先来看一眼工程截图。<br><img src="/images/tomcat/tomcat1.png"></p>
<h1 id="一、封装请求对象"><a href="#一、封装请求对象" class="headerlink" title="一、封装请求对象"></a>一、封装请求对象</h1><p><img src="/images/tomcat/tomcat2.png"><br>这里可以清楚的看到，通过输入流，对 HTTP 协议进行解析，拿到了 HTTP 请求头的方法以及 URL。</p>
<h1 id="二、封装响应对象"><a href="#二、封装响应对象" class="headerlink" title="二、封装响应对象"></a>二、封装响应对象</h1><p><img src="/images/tomcat/tomcat3.png"><br>基于 HTTP 协议的格式进行输出写入。</p>
<h1 id="三、Servlet-请求处理基类"><a href="#三、Servlet-请求处理基类" class="headerlink" title="三、Servlet 请求处理基类"></a>三、Servlet 请求处理基类</h1><p><img src="/images/tomcat/tomcat4.png"><br>前文说 Tomcat 是满足 Servlet 规范的容器，那么自然 Tomcat 需要提供 API。这里看到了 Servlet 常见的 doGet/doPost/service 方法。</p>
<p>#　四、Servlet 实现类<br><img src="/images/tomcat/tomcat5.png"><br><img src="/images/tomcat/tomcat6.png"><br>提供这 2 个具体的 Servlet 实现，只是为了后续的测试！</p>
<h1 id="五、Servlet-配置"><a href="#五、Servlet-配置" class="headerlink" title="五、Servlet 配置"></a>五、Servlet 配置</h1><p><img src="/images/tomcat/tomcat7.png"><br><img src="/images/tomcat/tomcat8.png"><br>你应该有些感觉了吧？在 servlet 开发中，会在 web.xml 中通过<servlet>和<servlet-mapping>来进行指定哪个 URL 交给哪个 servlet 进行处理。</servlet-mapping></servlet></p>
<h1 id="六、启动类"><a href="#六、启动类" class="headerlink" title="六、启动类"></a>六、启动类</h1><p><img src="/images/tomcat/tomcat9.png"><br><img src="/images/tomcat/tomcat10.png"><br><img src="/images/tomcat/tomcat11.png"><br>这里，你能够看到 Tomcat 的处理流程，即把 URL 对应处理的 Servlet 关系形成，解析 HTTP 协议，封装请求/响应对象，利用反射实例化具体的 Servlet 进行处理即可。</p>
<h1 id="七、测试"><a href="#七、测试" class="headerlink" title="七、测试"></a>七、测试</h1><p><img src="/images/tomcat/tomcat12.png"><br>实现一个简易版的 Tomcat 就这么 7 大步搞定，大家都来动手实现一下吧，代码最好不要复制，自己动手一个个敲，这样实现之后，对 Tomcat 就没那么陌生了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/26/Play%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/26/Play%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">Play框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-26 21:00:00 / Modified: 22:09:50" itemprop="dateCreated datePublished" datetime="2020-12-26T21:00:00+08:00">2020-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Play 框架架构<br>当请求从浏览器发到服务端时，会有 Routes 来处理，如我们请求 /use/1 的 URL 时。这个请求将在 Routes 找到对应的函数来处理，在 Django 中处理请求的函数叫做 URL Dispatcher。</p>
<p><img src="/images/web/play01.png"><br>这里的路由规则分为了两个部分:请求动态数据或静态资源。<br>浏览器一般先请求获得 html 页面，然后 html 内容如果有 ajax 则会再发送请求过来，请求动态数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Routes</span><br><span class="line"># This file defines all application routes (Higher priority routes first)</span><br><span class="line"># ~~~~</span><br><span class="line"></span><br><span class="line"># Home page</span><br><span class="line">GET         &#x2F;                    controllers.ApplicationController.index</span><br><span class="line">POST        &#x2F;user                controllers.ApplicationController.addUser</span><br><span class="line">GET         &#x2F;delete&#x2F;:id          controllers.ApplicationController.deleteUser(id : Long)</span><br><span class="line">GET         &#x2F;user&#x2F;:id            controllers.ApplicationController.getUser(id : Long)</span><br><span class="line">GET         &#x2F;api&#x2F;user&#x2F;:id        controllers.ApiController.getUser(id : Long)</span><br><span class="line">POST        &#x2F;api&#x2F;user            controllers.ApiController.createUser</span><br><span class="line"></span><br><span class="line"># Map static resources from the &#x2F;public folder to the &#x2F;assets URL path</span><br><span class="line">GET         &#x2F;assets&#x2F;*file        controllers.Assets.versioned(path&#x3D;&quot;&#x2F;public&quot;, file: Asset)</span><br></pre></td></tr></table></figure>

<p>随后在我们的 ApiController 中会有一个对应的 getUser 的方法来处理，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ApiController extends Controller &#123;</span><br><span class="line">  def getUser(id: Long) &#x3D; Action.async &#123; implicit request &#x3D;&gt;</span><br><span class="line">    UserService.getUser(id).map &#123;</span><br><span class="line">      case None &#x3D;&gt; NotFound(Json.obj(&quot;error&quot; -&gt; &quot;Not Found&quot;))</span><br><span class="line">      case Some(user) &#x3D;&gt; Ok(Json.toJson(user))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后还是相应的 UserService 去取相应的用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import models.&#123;User, Users&#125;</span><br><span class="line">import scala.concurrent.Future</span><br><span class="line"></span><br><span class="line">object UserService &#123;</span><br><span class="line"></span><br><span class="line">  def addUser(user: User): Future[String] &#x3D; &#123;</span><br><span class="line">    Users.add(user)</span><br><span class="line">  &#125;</span><br><span class="line">  def getUser(id: Long): Future[Option[User]] &#x3D; &#123;</span><br><span class="line">    Users.get(id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后便会执行到 model 层:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">object Users &#123;</span><br><span class="line"></span><br><span class="line">  val dbConfig &#x3D; DatabaseConfigProvider.get[JdbcProfile](Play.current)</span><br><span class="line"></span><br><span class="line">  val users &#x3D; TableQuery[UserTableDef]</span><br><span class="line"></span><br><span class="line">  def add(user: User): Future[String] &#x3D; &#123;</span><br><span class="line">    dbConfig.db.run(users +&#x3D; user).map(res &#x3D;&gt; user.toString()).recover &#123;</span><br><span class="line">      case ex: Exception &#x3D;&gt; ex.getCause.getMessage</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  def get(id: Long): Future[Option[User]] &#x3D; &#123;</span><br><span class="line">    dbConfig.db.run(users.filter(_.id &#x3D;&#x3D;&#x3D; id).result.headOption)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就取到了这个用户。如果只是从这个过程上来说，我觉得和一般的 MVC 框架并没有太大的区别。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/26/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/26/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">函数式编程与面向对象编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-26 21:00:00 / Modified: 22:51:32" itemprop="dateCreated datePublished" datetime="2020-12-26T21:00:00+08:00">2020-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="编程的本质"><a href="#编程的本质" class="headerlink" title="编程的本质"></a>编程的本质</h1><p>当写过许许多多程序后，接触了那么多编程模式、设计模式、框架、语言、算法、数据结构以后，就会发现编程的本质万变不离其宗就是，操纵一坨数据。当然操纵的方式有许多，存储的方式也五花八门，但是本质不变，就是访问数据（读取以及改变）。</p>
<p>下面谈一谈我对两种编程方式的理解，就是面向对象编程，以及函数式编程。我用 JavaScript 这种神奇的语言来解释，因为 JavaScript 既可以面向对象编程，也可以函数式编程。</p>
<h1 id="数据存放方式"><a href="#数据存放方式" class="headerlink" title="数据存放方式"></a>数据存放方式</h1><p>1、对于 OO（面向对象，下同），数据存放在对象的属性（成员变量）里面，以及静态成员（全局变量）</p>
<p>2、对于函数式，数据存放在闭包（各级作用域）里面，作用域包括全局作用域。</p>
<h1 id="数据访问方式"><a href="#数据访问方式" class="headerlink" title="数据访问方式"></a>数据访问方式</h1><p>数据存放方式决定了访问的方式。</p>
<p>1、对于 OO 来说，访问数据（全局变量除外）需要先获取对象的引用，然后再进行操作（直接访问——公共属性，或者调用成员函数/方法访问——私有属性）</p>
<p>2、对于函数式，访问数据是直接访问（通过函数入参或者作用域链查找）</p>
<p>下面上一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;OO</span><br><span class="line">class Foo &#123;</span><br><span class="line">constructor()&#123;</span><br><span class="line">this.bar &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let foo &#x3D; new Foo()</span><br><span class="line">foo.bar ++</span><br></pre></td></tr></table></figure>

<p>//函数式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let bar &#x3D; 0</span><br><span class="line">function foo()&#123;</span><br><span class="line">bar ++</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>这是随便写了一些没有用代码，只是为了展示两种风格的编程方式。</p>
<p>从中我们可以看出一些东西，OO 是通过持有，以及传递对象的方式去让别的对象来操作数据，而对象也会是其他对象的成员，层层嵌套。当你想要访问某一个数据的时候，就需要顺着对象的引用链条去找，一步步去操作。</p>
<p>函数式传递的则是函数，调用函数即操作数据，传递函数的时候其实隐含着传递了函数创建的时候所附带的作用域，这个在表面上看不出来，在底层是有的。</p>
<p>OO 所谓的对象，本质上就是函数式中的作用域。</p>
<p>为了理解这句话，我们来看高阶函数的本质</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo(x)&#123;</span><br><span class="line">let bar &#x3D; x</span><br><span class="line">return function()&#123;</span><br><span class="line">return bar</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let Bar &#x3D; foo(1)</span><br><span class="line">console.log(Bar())&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>

<p>当调用 foo(1)的时候返回一个函数，这个函数可以访问 foo 函数内部的 bar 变量，这就是高阶函数。如果翻译成 OO 思想大家就知道怎么回事了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">constructor(x)&#123;</span><br><span class="line">this.bar &#x3D; x</span><br><span class="line">&#125;</span><br><span class="line">Bar()&#123;</span><br><span class="line">return this.bar</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let foo &#x3D; new Foo(1)</span><br><span class="line">console.log(foo.Bar())</span><br></pre></td></tr></table></figure>

<p>看上去是不是差不多。其实在 C#中对 lambda 表达式的编译就是这个原理。会内部创建一些类。</p>
<p>当然高阶函数的写法肯定不会这么啰嗦，会写的比较优雅。(这就是本质区别）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let foo &#x3D; bar&#x3D;&gt;()&#x3D;&gt;bar</span><br><span class="line">let Bar &#x3D; foo(1)</span><br><span class="line">console.log(Bar())&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>

<p>所以 OO 编程，是面向作用域编程，而函数式编程，是面向功能编程。</p>
<p>函数式编程有一个巨大的优势，就是作用域链，也就是说函数可以访问的变量范围要远远大于 OO，灵活性就成几何级数上升。换句话也可以说 OO 的约束性更强。</p>
<h1 id="FP-适合数据处理，OOP-适合外包业务领域"><a href="#FP-适合数据处理，OOP-适合外包业务领域" class="headerlink" title="FP 适合数据处理，OOP 适合外包业务领域"></a>FP 适合数据处理，OOP 适合外包业务领域</h1><p>函数式编程（FP）和面向对象编程（OOP）直接相比是一种常见的误解。这种比较应该是 FP 和 OOP 支持者之间互相怼的产物。</p>
<p>事实上，FP 和 OOP 是两种不同的看待事物的方式。FP 强调“everything is lambda”，并且强调在逻辑处理中不变性的重要性。不变到什么地步呢？原教旨主义的 FP 就连普通的循环都不可以写（因为循环都有个变化的 idx 或者条件之类的变量），必须用递归实现。这样做的结果就是把一切“状态”都消除。任何“状态”都是由确定的输入经过确定的一组函数处理得到的最终结果。 FP 适合的领域是处理数据。</p>
<p>OOP 强调“everything is object”，以及 object 之间的消息传递。通过消息传递改变每个 Object 的内部状态。OOP 之父 Alan Kay 表示”OOP is all about messaging”。利用 OOP 建模，都会通过某种消息机制来模拟一些场景的处理。比如交易=下单 Object，支付 Object，积分 Object 等之间进行交互当然，实际的 OOP 的程序运行时为了效率一般会用方法调用，而不是真的传递一个物理消息。OOP 适合的领域是企业 ERP，外包业务等。</p>
<p>如果你看懂了上面两个概念，就会发现他们说的事情压根就不在一个频道里。因此各自的好处也不能证明另一方有缺点。</p>
<p>现在经常看到文章表达 FP 如何如何优于 OOP，大概原因有这么两点：第一点是，OOP 早期不切实际的吹牛皮，吹爆了。很多人谈起 OOP，都会有“用了 OOP，代码耦合就小了，就容易维护了，扩展就方便了，代码就更容易复用了等等“的第一印象。但实际上这并不一定发生。软件设计并非因为 OOP 就直接自动变好了。因此很多程序员在趟坑多年后可能会感觉“我擦，学了这么多年，全是假的“。更进一步的，像 Java 这样的“纯 OOP”语言迫使程序员并不需要 OOP 的情况下也得照着 OOP 的方式去写代码，结果啰嗦又臃肿。所以很多人越来越讨厌 OOP 其实是可以理解的。（比如这篇 Goodbye, Objected Oriented Programming)。现在的 Java 程序大量使用反射、lambda 等技术，已经不是早期那个单纯 OOP 语言了。第二点是现代程序开始往并发发展。而 FP 的不可变，没有副作用等特性恰好让并发编程变得不容易出错。并且配合多种并发模型（如 CSP、Map Reduce、Fork &amp; Join、Promise 等），可以解决很多高并发的问题，显得高、大、上、酷。</p>
<p>但是，我非常赞同《人月神话》的著名论断——没有银弹。不论 OOP 还是 FP，用好了都可以发挥作用，用不好一样吃瘪。</p>
<p>举几个例子，一个业务领域建模，其实模拟的就是现实当中的不同角色的人/机构的工作方式。因为如果是人/机构互相协作，就是通过消息来协作的。比如博士生想发文章，先得自己写，写了老板审阅，完事发给期刊编辑，编辑找同行评议，完事发表，发表的结果会收录到某个文献索引数据库。这个过程就是多个独立的“对象”在相互协作的结果。因此 OOP 在这个层面上对这个流程进行抽象是很合适的。当然你也可以说，这时我用 FP 的各种动作函数的组织来描述这个过程，也是可以的。但是如果比较一下，这个场景用 FP 和 OOP 建模，哪个更容易理解呢？</p>
<p>再比如，对一组数据做加工，先查询，然后聚合，聚合后排序，再 join，再排序，再聚合，再转换（map）得到最终的结果。这个过程，用 FP 的函数就很自然，因为这一看就是 result = func1(func2(func3…funcN(x))))这时用 OOP 呢？给每一个步骤建一个 class？然后把排序、聚合等操作放在 class 里？抽象个基类？或者弄个 XXXUtils 的静态方法集合类？当然都可以做，但是很明显这不是个好的设计。再再比如，一个业务流程，就是一组步骤：第一步如何如何，第二部如何如何……。这时用 FP 和 OOP 都不能很好的表达问题（可能 FP 接近点）。这其实是典型的“指令式编程“。如果业务逻辑如此，那么就照着一步一步做就是最好的，而不是抽取函数和不变状态；或者定义一些根本无意义的 class。</p>
<p>说了这么多，其实希望表达的意思是：到底用哪种编程模式，要看问题本身适合哪个。哪个用起来自然，和问题本身特质搭配，那就用哪个。用对了，事半功倍；用错了，就各种纠结拧巴。你希望你一个东西模拟为 Object，前提是这个东西本身容易抽象成一个 Object；你希望你一个数据可以抽象为一组函数执行的组合，前提是这样理解更自然，更舒服。此外，同一个问题可以拆解为不同的层次，不同的层次可以使用各自适合的方式。比如高层的可以 OOP，具体到某个执行逻辑里可以用 FP 或者指令编程。</p>
<h1 id="对比面向过程，面向对象，函数式编程"><a href="#对比面向过程，面向对象，函数式编程" class="headerlink" title="对比面向过程，面向对象，函数式编程"></a>对比面向过程，面向对象，函数式编程</h1><p>函数式编程、面向对象编程和面向过程编程都是思维方式，具体语言的语法不构成限制。这三者可以当作是一条光谱上不同的颜色，一头是命令式风格，一头是声明式风格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">               ↓&lt;过程式&gt;           ↓&lt;面向对象&gt;       ↓&lt;函数式&gt;</span><br><span class="line">[命令式风格] o----------------------------------------------------&gt; [声明式风格]</span><br></pre></td></tr></table></figure>

<p>箭头从左到右抽象程度逐渐上升。过程式风格有函数的概念，和纯粹的指令相比可以用简短的函数替代一段指令；面向对象风格包装了一层 class 这样的概念，允许打包的一组数据自己持有一些信息，使用者调用方法前不需要知道所有的事情；函数式风格允许把“处理过程”本身当作参数，传入的处理过程的参数就代表具体操作时遇到的实体。<br>函数式编程就是用函数的组合来解决问题，面向对象是建很多对象来互相交互解决问题，面向过程就是下一步下一步下一步。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>输入十个整数，输出大于平均值的数，然后输出排序后的十个数面向过程/<em>C</em>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int input[10];</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">int tmp;</span><br><span class="line">double average;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;input[i]);</span><br><span class="line">  sum +&#x3D; input[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">average &#x3D; sum &#x2F; 10.0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">  if (input[i] &gt; average)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, input[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;_Bubble Sort_&#x2F;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 9; i++)</span><br><span class="line">&#123;</span><br><span class="line">  for (int j &#x3D; 0; j &lt; 9 - i; j++)</span><br><span class="line">  &#123;</span><br><span class="line">    if (input[j] &gt; input[j + 1])</span><br><span class="line">    &#123;</span><br><span class="line">      tmp &#x3D; input[j];</span><br><span class="line">      input[j] &#x3D; input[j + 1];</span><br><span class="line">      input[j + 1] &#x3D; tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%d\n&quot;, input[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面向对象//C++</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class solve</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    solve() noexcept;</span><br><span class="line">    void sort();</span><br><span class="line">    void show();&#x2F;&#x2F;输出大于均值的数</span><br><span class="line">    void print();&#x2F;&#x2F;打印数组</span><br><span class="line">  private:</span><br><span class="line">    int input[10];</span><br><span class="line">    int sum;</span><br><span class="line">    double average;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;具体实现省略</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  auto test &#x3D; new solve();</span><br><span class="line">  test-&gt;show();</span><br><span class="line">  test-&gt;sort();</span><br><span class="line">  test-&gt;print();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数式编程#Python</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array &#x3D; [int(input()) for i in range(10)]</span><br><span class="line">average &#x3D; sum(array) &#x2F; 10;</span><br><span class="line">print(list(filter(lambda x: x &gt; average, array)))</span><br><span class="line">print(sorted(array))</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/26/Web%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2%E5%8F%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/26/Web%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2%E5%8F%98%E5%8C%96/" class="post-title-link" itemprop="url">Web技术历史变化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-26 21:00:00" itemprop="dateCreated datePublished" datetime="2020-12-26T21:00:00+08:00">2020-12-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-27 11:47:18" itemprop="dateModified" datetime="2020-12-27T11:47:18+08:00">2020-12-27</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、简单明快的早期时代"><a href="#一、简单明快的早期时代" class="headerlink" title="一、简单明快的早期时代"></a>一、简单明快的早期时代</h1><p><img src="/images/web/1.png"><br>可称之为 Web 1.0 时代，非常适合创业型小项目，不分前后端，经常 3-5 人搞定所有开发。页面由 JSP、PHP 等工程师在服务端生成，浏览器负责展现。基本上是服务端给什么浏览器就展现什么，展现的控制在 Web Server 层。</p>
<p>这种模式的好处是：简单明快，本地起一个 Tomcat 或 Apache 就能开发，调试什么的都还好，只要业务不太复杂。</p>
<p>然而业务总会变复杂，这是好事情，否则很可能就意味着创业失败了。业务的复杂会让 Service 越来越多，参与开发的人员也很可能从几个人快速扩招到几十人。在这种情况下，会遇到一些典型问题：</p>
<p>1、Service 越来越多，调用关系变复杂，前端搭建本地环境不再是一件简单的事。考虑团队协作，往往会考虑搭建集中式的开发服务器来解决。这种解决方案对编译型的后端开发来说也许还好，但对前端开发来说并不友好。天哪，我只是想调整下按钮样式，却要本地开发、代码上传、验证生效等好几个步骤。也许习惯了也还好，但开发服务器总是不那么稳定，出问题时往往需要依赖后端开发搞定。看似仅仅是前端开发难以本地化，但这对研发效率的影响其实蛮大。</p>
<p>2、JSP 等代码的可维护性越来越差。JSP 非常强大，可以内嵌 Java 代码。这种强大使得前后端的职责不清晰，JSP 变成了一个灰色地带。经常为了赶项目，为了各种紧急需求，会在 JSP 里揉杂大量业务代码。积攒到一定阶段时，往往会带来大量维护成本。</p>
<p>这个时期，为了提高可维护性，可以通过下面的方式实现前端的组件化：</p>
<p><img src="/images/web/1.1.png"><br>理论上，如果大家都能按照最佳实践去书写代码，那么无论是 JSP 还是 PHP，可维护性都不会差。但可维护性更多是工程含义，有时候需要通过限制带来自由，需要某种约定，使得即便是新手也不会写出太糟糕的代码。</p>
<p>如何让前后端分工更合理高效，如何提高代码的可维护性，在 Web 开发中很重要。下面我们继续来看，技术架构的演变如何解决这两个问题。</p>
<h1 id="二、后端为主的-MVC-时代"><a href="#二、后端为主的-MVC-时代" class="headerlink" title="二、后端为主的 MVC 时代"></a>二、后端为主的 MVC 时代</h1><p>为了降低复杂度，以后端为出发点，有了 Web Server 层的架构升级，比如 Structs、Spring MVC 等，这是后端的 MVC 时代。</p>
<p><img src="/images/web/2.png"><br>代码可维护性得到明显好转，MVC 是个非常好的协作模式，从架构层面让开发者懂得什么代码应该写在什么地方。为了让 View 层更简单干脆，还可以选择 Velocity、Freemaker 等模板，使得模板里写不了 Java 代码。看起来是功能变弱了，但正是这种限制使得前后端分工更清晰。然而依旧并不是那么清晰，这个阶段的典型问题是：</p>
<p>1、前端开发重度依赖开发环境。这种架构下，前后端协作有两种模式：一种是前端写 demo，写好后，让后端去套模板。淘宝早期包括现在依旧有大量业务线是这种模式。好处很明显，demo 可以本地开发，很高效。不足是还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大。另一种协作模式是前端负责浏览器端的所有开发和服务器端的 View 层模板开发，支付宝是这种模式。好处是 UI 相关的代码都是前端去写就好，后端不用太关注，不足就是前端开发重度绑定后端环境，环境成为影响前端开发效率的重要因素。</p>
<p>2、前后端职责依旧纠缠不清。Velocity 模板还是蛮强大的，变量、逻辑、宏等特性，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写出不少业务代码。还有一个很大的灰色地带是 Controller，页面路由等功能本应该是前端最关注的，但却是由后端来实现。Controller 本身与 Model 往往也会纠缠不清，看了让人咬牙的代码经常会出现在 Controller 层。这些问题不能全归结于程序员的素养，否则 JSP 就够了。</p>
<p>经常会有人吐槽 Java，但 Java 在工程化开发方面真的做了大量思考和架构尝试。Java 蛮符合马云的一句话：让平凡人做非凡事。</p>
<h1 id="三、Ajax-带来的-SPA-时代"><a href="#三、Ajax-带来的-SPA-时代" class="headerlink" title="三、Ajax 带来的 SPA 时代"></a>三、Ajax 带来的 SPA 时代</h1><p>历史滚滚往前，2004 年 Gmail 像风一样的女子来到人间，很快 2005 年 Ajax 正式提出，加上 CDN 开始大量用于静态资源存储，于是出现了 JavaScript 王者归来的 SPA （Single Page Application 单页面应用）时代。</p>
<p><img src="/images/web/3.png"><br>这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口。看起来是如此美妙，但回过头来看看的话，这与 JSP 时代区别不大。复杂度从服务端的 JSP 里移到了浏览器的 JavaScript，浏览器端变得很复杂。类似 Spring MVC，这个时代开始出现浏览器端的分层架构：</p>
<p><img src="/images/web/3.1.png"><br>对于 SPA 应用，有几个很重要的挑战：</p>
<p>1、前后端接口的约定。如果后端的接口一塌糊涂，如果后端的业务模型不够稳定，那么前端开发会很痛苦。这一块在业界有 API Blueprint 等方案来约定和沉淀接口，在阿里，不少团队也有类似尝试，通过接口规则、接口平台等方式来做。有了和后端一起沉淀的接口规则，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发。相信这一块会越做越好。</p>
<p>2、前端开发的复杂度控制。SPA 应用大多以功能交互型为主，JavaScript 代码过十万行很正常。大量 JS 代码的组织，与 View 层的绑定等，都不是容易的事情。典型的解决方案是业界的 Backbone，但 Backbone 做的事还很有限，依旧存在大量空白区域需要挑战。</p>
<p>SPA 让前端看到了一丝绿色，但依旧是在荒漠中行走。</p>
<h1 id="四、前端为主的-MV-时代"><a href="#四、前端为主的-MV-时代" class="headerlink" title="四、前端为主的 MV* 时代"></a>四、前端为主的 MV* 时代</h1><p>为了降低前端开发复杂度，除了 Backbone，还有大量框架涌现，比如 EmberJS、KnockoutJS、AngularJS 等等。这些框架总的原则是先按类型分层，比如 Templates、Controllers、Models，然后再在层内做切分，如下图：</p>
<p><img src="/images/web/4.png"><br>好处很明显：</p>
<p>1、前后端职责很清晰。前端工作在浏览器端，后端工作在服务端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 RESTful 等接口。</p>
<p>2、前端开发的复杂度可控。前端代码很重，但合理的分层，让前端代码能各司其职。这一块蛮有意思的，简单如模板特性的选择，就有很多很多讲究。并非越强大越好，限制什么，留下哪些自由，代码应该如何组织，所有这一切设计，得花一本的厚度去说明。</p>
<p>3、部署相对独立，产品体验可以快速改进。</p>
<p>但依旧有不足之处：</p>
<p>代码不能复用。比如后端依旧需要对数据做各种校验，校验逻辑无法复用浏览器端的代码。如果可以复用，那么后端的数据校验可以相对简单化。<br>全异步，对 SEO 不利。往往还需要服务端做同步渲染的降级方案。<br>性能并非最佳，特别是移动互联网环境下。<br>SPA 不能满足所有需求，依旧存在大量多页面应用。URL Design 需要后端配合，前端无法完全掌控。<br>五、Node 带来的全栈时代<br>前端为主的 MV* 模式解决了很多很多问题，但如上所述，依旧存在不少不足之处。随着 Node.js 的兴起，JavaScript 开始有能力运行在服务端。这意味着可以有一种新的研发模式：</p>
<p><img src="/images/web/5.png"><br>在这种研发模式下，前后端的职责很清晰。对前端来说，两个 UI 层各司其职：</p>
<p>1、Front-end UI layer 处理浏览器层的展现逻辑。通过 CSS 渲染样式，通过 JavaScript 添加交互功能，HTML 的生成也可以放在这层，具体看应用场景。</p>
<p>2、Back-end UI layer 处理路由、模板、数据获取、cookie 等。通过路由，前端终于可以自主把控 URL Design，这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以摆脱对展现的强关注，转而可以专心于业务逻辑层的开发。</p>
<p>通过 Node，Web Server 层也是 JavaScript 代码，这意味着部分代码可前后复用，需要 SEO 的场景可以在服务端同步渲染，由于异步请求太多导致的性能问题也可以通过服务端来缓解。前一种模式的不足，通过这种模式几乎都能完美解决掉。</p>
<p>与 JSP 模式相比，全栈模式看起来是一种回归，也的确是一种向原始开发模式的回归，不过是一种螺旋上升式的回归。</p>
<h1 id="基于-Node-的全栈模式，依旧面临很多挑战："><a href="#基于-Node-的全栈模式，依旧面临很多挑战：" class="headerlink" title="基于 Node 的全栈模式，依旧面临很多挑战："></a>基于 Node 的全栈模式，依旧面临很多挑战：</h1><p>需要前端对服务端编程有更进一步的认识。比如 network/tcp、PE 等知识的掌握。<br>Node 层与 Java 层的高效通信。Node 模式下，都在服务器端，RESTful HTTP 通信未必高效，通过 SOAP 等方式通信更高效。一切需要在验证中前行。<br>对部署、运维层面的熟练了解，需要更多知识点和实操经验。<br>大量历史遗留问题如何过渡。这可能是最大最大的阻力。<br>六、小结<br>回顾历史总是让人感慨，展望未来则让人兴奋。上面讲到的研发模式，除了最后一种还在探索期，其他各种在各大公司都已有大量实践。几点小结：</p>
<p>模式没有好坏高下之分，只有合不合适。<br>Ajax 给前端开发带来了一次质的飞跃，Node 很可能是第二次。<br>SoC（关注度分离） 是一条伟大的原则。上面种种模式，都是让前后端的职责更清晰，分工更合理高效。<br>还有个原则，让合适的人做合适的事。比如 Web Server 层的 UI Layer 开发，前端是更合适的人选。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/13/%E6%B1%87%E7%BC%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/13/%E6%B1%87%E7%BC%96/" class="post-title-link" itemprop="url">汇编</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-13 16:00:00 / Modified: 15:15:19" itemprop="dateCreated datePublished" datetime="2020-12-13T16:00:00+08:00">2020-12-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="“被调用者保存”和“调用者保存”寄存器"><a href="#“被调用者保存”和“调用者保存”寄存器" class="headerlink" title="“被调用者保存”和“调用者保存”寄存器"></a>“被调用者保存”和“调用者保存”寄存器</h2><p>编译器的设计中有个概念叫做“被调用者保存”和“调用者保存”，可以近似的按子函数保存和父函数保存对应来理解，这一概念的出现完全是由于寄存器资源个数有限造成的。当父函数在调用子函数时，由于子函数可能访问到父函数用于保存数值的寄存器，为了互不干扰和造成覆盖，编译器就制定了相应的规则，%eax、%edx 和%ecx 被划分为“调用者保存”寄存器，顾名思义，这些寄存器上面存储的值，需要调用者（父函数）自己想办法先备份好，否则过会子函数直接使用这些寄存器时将无情的覆盖。如何备份？当然是事先压入栈中，等子函数调用完，再通过出栈恢复这些寄存器原本在父函数运行时的旧值；另外三个寄存器%ebx、%esi、%edi 被划分为“被调用者保存”寄存器，同样的，这些寄存器上有值，在使用前需要被调用者（子函数）自己想办法帮调用者（父函数）进行备份，具体方法就是子函数在覆盖他们之前，先进行入栈备份，等子函数返回时，再出栈还原父函数运行时这些寄存器上的旧值。</p>
<h2 id="七种寻址方式"><a href="#七种寻址方式" class="headerlink" title="七种寻址方式"></a>七种寻址方式</h2><h3 id="1-立即寻址方式"><a href="#1-立即寻址方式" class="headerlink" title="1 立即寻址方式"></a>1 立即寻址方式</h3><p>操作数作为指令的一部分而直接写在指令中，这种操作数称为立即数，这种寻址方式也就称为立即数寻址方式。</p>
<p>立即数可以是 8 位、16 位或 32 位，该数值紧跟在操作码之后。如果立即数为 16 位或 32 位，那么，它将按“高高低低”的原则进行存储。例如：</p>
<p>MOV AH, 80H 　　　 ADD AX, 1234H 　　　 MOV ECX, 123456H<br>MOV B1, 12H 　　　 MOV W1, 3456H 　　 ADD D1, 32123456H</p>
<p>其中：B1、W1 和 D1 分别是字节、字和双字单元。</p>
<p>以上指令中的第二操作数都是立即数，在汇编语言中，规定：立即数不能作为指令中的第二操作数。该规定与高级语言中“赋值语句的左边不能是常量”的规定相一致。</p>
<p>立即数寻址方式通常用于对通用寄存器或内存单元赋初值。图是指令“MOV AX, 4576H”存储形式和执行示意图。</p>
<h3 id="2-寄存器寻址方式"><a href="#2-寄存器寻址方式" class="headerlink" title="2 寄存器寻址方式"></a>2 寄存器寻址方式</h3><p>指令所要的操作数已存储在某寄存器中，或把目标操作数存入寄存器。把在指令中指出所使用寄存器(即：寄存器的助忆符)的寻址方式称为寄存器寻址方式。<br>指令中可以引用的寄存器及其符号名称如下：<br>　　 8 位寄存器有：AH、AL、BH、BL、CH、CL、DH 和 DL 等；<br>　　 16 位寄存器有：AX、BX、CX、DX、SI、DI、SP、BP 和段寄存器等；<br>　　 32 位寄存器有：EAX、EBX、ECX、EDX、ESI、EDI、ESP 和 EBP 等。<br>寄存器寻址方式是一种简单快捷的寻址方式，源和目的操作数都可以是寄存器。</p>
<p>1、源操作数是寄存器寻址方式<br>　　如：ADD VARD, EAX 　　 ADD VARW, AX 　　　 MOV VARB, BH 等。<br>　　其中：VARD、VARW 和 VARB 是双字，字和字节类型的内存变量。在第 4 章将会学到如何定义它们。</p>
<p>2、目的操作数是寄存器寻址方式<br>　　如：ADD BH, 78h 　　　　 ADD AX, 1234h 　　　 MOV EBX, 12345678H 等。</p>
<p>3、源和目的操作数都是寄存器寻址方式<br>　　如：MOV EAX, EBX 　　　 MOV AX, BX 　　　　 MOV DH, BL 等。</p>
<p>由于指令所需的操作数已存储在寄存器中，或操作的结果存入寄存器，这样，在指令执行过程中，会减少读/写存储器单元的次数，所以，使用寄存器寻址方式的指令具有较快的执行速度。通常情况下，我们提倡在编写汇编语言程序时，应尽可能地使用寄存器寻址方式，但也不要把它绝对化。</p>
<h3 id="3-七种寻址方式-直接寻址方式"><a href="#3-七种寻址方式-直接寻址方式" class="headerlink" title="3 七种寻址方式(直接寻址方式)"></a>3 七种寻址方式(直接寻址方式)</h3><p>指令所要的操作数存放在内存中，在指令中直接给出该操作数的有效地址，这种寻址方式为直接寻址方式。</p>
<p>在通常情况下，操作数存放在数据段中，所以，其物理地址将由数据段寄存器 DS 和指令中给出的有效地址直接形成，但如果使用段超越前缀，那么，操作数可存放在其它段。</p>
<p>例：假设有指令：MOV BX, [1234H]，在执行时，(DS)=2000H，内存单元 21234H 的值为 5213H。问该指令执行后，BX 的值是什么？</p>
<p>解：根据直接寻址方式的寻址规则，把该指令的具体执行过程用下图来表示。</p>
<p>从图中，可看出执行该指令要分三部分：</p>
<p>由于 1234H 是一个直接地址，它紧跟在指令的操作码之后，随取指令而被读出；</p>
<p>访问数据段的段寄存器是 DS，所以，用 DS 的值和偏移量 1234H 相加，得存储单元的物理地址：21234H；</p>
<p>取单元 21234H 的值 5213H，并按“高高低低”的原则存入寄存器 BX 中。</p>
<p>所以，在执行该指令后，BX 的值就为 5213H。</p>
<p>由于数据段的段寄存器默认为 DS，如果要指定访问其它段内的数据，可在指令中用段前缀的方式显式地书写出来。</p>
<p>下面指令的目标操作数就是带有段前缀的直接寻址方式。</p>
<p>MOV 　 ES:[1000H], AX</p>
<p>直接寻址方式常用于处理内存单元的数据，其操作数是内存变量的值，该寻址方式可在 64K 字节的段内进行寻址。</p>
<p>注意：立即寻址方式和直接寻址方式的书写格式的不同，直接寻址的地址要写在括号“[”，“]”内。在程序中，直接地址通常用内存变量名来表示，如：MOV BX, VARW，其中，VARW 是内存字变量。</p>
<p>试比较下列指令中源操作数的寻址方式(VARW 是内存字变量)：<br>　　 MOV 　 AX, 1234H MOV 　 AX, [1234H] ;前者是立即寻址，后者是直接寻址<br>　　 MOV 　 AX, VARW MOV 　 AX, [VARW] ;两者是等效的，均为直接寻址</p>
<h3 id="4-七种寻址方式-寄存器间接寻址方式"><a href="#4-七种寻址方式-寄存器间接寻址方式" class="headerlink" title="4 七种寻址方式(寄存器间接寻址方式)"></a>4 七种寻址方式(寄存器间接寻址方式)</h3><p>操作数在存储器中，操作数的有效地址用 SI、DI、BX 和 BP 等四个寄存器之一来指定，称这种寻址方式为寄存器间接寻址方式。该寻址方式物理地址的计算方法如下：</p>
<p>寄存器间接寻址方式读取存储单元的原理如图所示。</p>
<p>在不使用段超越前缀的情况下，有下列规定：</p>
<p>若有效地址用 SI、DI 和 BX 等之一来指定，则其缺省的段寄存器为 DS；<br>若有效地址用 BP 来指定，则其缺省的段寄存器为 SS(即：堆栈段)。</p>
<p>例:假设有指令：MOV BX,[DI]，在执行时，(DS)=1000H，(DI)=2345H，存储单元 12345H 的内容是 4354H。问执行指令后，BX 的值是什么？</p>
<p>解：根据寄存器间接寻址方式的规则，在执行本例指令时，寄存器 DI 的值不是操作数，而是操作数的地址。该操作数的物理地址应由 DS 和 DI 的值形成，即：</p>
<p>PA=(DS)<em>16+DI=1000H</em>16+2345H=12345H。</p>
<p>所以，该指令的执行效果是：把从物理地址为 12345H 开始的一个字的值传送给 BX。</p>
<p>其执行过程如图所示。</p>
<h3 id="5-七种寻址方式（寄存器相对寻址方式）"><a href="#5-七种寻址方式（寄存器相对寻址方式）" class="headerlink" title="5 七种寻址方式（寄存器相对寻址方式）"></a>5 七种寻址方式（寄存器相对寻址方式）</h3><p>操作数在存储器中，其有效地址是一个基址寄存器(BX、BP)或变址寄存器(SI、D</p>
<p>I)的内容和指令中的 8 位/16 位偏移量之和。其有效地址的计算公式如公式所示。</p>
<p>在不使用段超越前缀的情况下，有下列规定：</p>
<pre><code>若有效地址用SI、DI和BX等之一来指定，则其缺省的段寄存器为DS；

若有效地址用BP来指定，则其缺省的段寄存器为SS。</code></pre>
<p>指令中给出的 8 位/16 位偏移量用补码表示。在计算有效地址时，如果偏移量是 8 位，则进行符号扩展成 16 位。当所得的有效地址超过 0FFFFH，则取其 64K 的模。</p>
<p>例:假设指令：MOV BX, [SI+100H]，在执行它时，(DS)=1000H，(SI)=2345H，内存单元 12445H 的内容为 2715H，问该指令执行后，BX 的值是什么？</p>
<p>解：根据寄存器相对寻址方式的规则，在执行本例指令时，源操作数的有效地址 EA 为：</p>
<p>EA=(SI)+100H=2345H+100H=2445H</p>
<p>该操作数的物理地址应由 DS 和 EA 的值形成，即：</p>
<p>PA=(DS)<em>16+EA=1000H</em>16+2445H=12445H。</p>
<p>所以，该指令的执行效果是：把从物理地址为 12445H 开始的一个字的值传送给 BX。</p>
<p>其执行过程如图所示。</p>
<h3 id="6-七种寻址方式-基址加变址寻址方式"><a href="#6-七种寻址方式-基址加变址寻址方式" class="headerlink" title="6 七种寻址方式(基址加变址寻址方式)"></a>6 七种寻址方式(基址加变址寻址方式)</h3><p>操作数在存储器中，其有效地址是一个基址寄存器(BX、BP)和一个变址寄存器(SI、DI)的内容之和。其有效地址的计算公式如公式所示。</p>
<p>在不使用段超越前缀的情况下，规定：如果有效地址中含有 BP，则缺省的段寄存器为 SS；否则，缺省的段寄存器为 DS。</p>
<p>例:假设指令：MOV BX, [BX+SI]，在执行时，(DS)=1000H，(BX)=2100H，(SI)=0011H，内存单元 12111H 的内容为 1234H。问该指令执行后，BX 的值是什么？</p>
<p>解：根据基址加变址寻址方式的规则，在执行本例指令时，源操作数的有效地址 EA 为：</p>
<p>EA=(BX)+(SI)=2100H+0011H=2111H</p>
<p>该操作数的物理地址应由 DS 和 EA 的值形成，即：</p>
<p>PA=(DS)<em>16+EA=1000H</em>16+2111H=12111H</p>
<p>所以，该指令的执行效果是：把从物理地址为 12111H 开始的一个字的值传送给 BX。</p>
<p>其执行过程如图所示。</p>
<h3 id="7-七种寻址方式-相对基址加变址寻址方式"><a href="#7-七种寻址方式-相对基址加变址寻址方式" class="headerlink" title="7 七种寻址方式(相对基址加变址寻址方式)"></a>7 七种寻址方式(相对基址加变址寻址方式)</h3><p>操作数在存储器中，其有效地址是一个基址寄存器(BX、BP)的值、一个变址寄存器(SI、DI)的值和指令中的 8 位/16 位偏移量之和。其有效地址的计算公式如公式所示。</p>
<p>在不使用段超越前缀的情况下，规定：如果有效地址中含有 BP，则其缺省的段寄存器为 SS；否则，其缺省的段寄存器为 DS。</p>
<p>指令中给出的 8 位/16 位偏移量用补码表示。在计算有效地址时，如果偏移量是 8 位，则进行符号扩展成 16 位。当所得的有效地址超过 0FFFFH，则取其 64K 的模。</p>
<p>例:假设指令：MOV AX, [BX+SI+200H]，在执行时，(DS)=1000H，(BX)=2100H，(SI)=0010H，内存单元 12310H 的内容为 1234H。问该指令执行后，AX 的值是什么？</p>
<p>解：根据相对基址加变址寻址方式的规则，在执行本例指令时，源操作数的有效地址 EA 为：</p>
<p>EA=(BX)+(SI)+200H=2100H+0010H+200H=2310H</p>
<p>该操作数的物理地址应由 DS 和 EA 的值形成，即：</p>
<p>PA=(DS)<em>16+EA=1000H</em>16+2310H=12310H</p>
<p>所以，该指令的执行效果是：把从物理地址为 12310H 开始的一个字的值传送给 AX。其执行过程如图所示。</p>
<p>从相对基址加变址这种寻址方式来看，由于它的可变因素较多，看起来就显得复杂些，但正因为其可变因素多，它的灵活性也就很高。比如：</p>
<p>用 D1[i]来访问一维数组 D1 的第 i 个元素，它的寻址有一个自由度，用 D2[i][j]来访问二维数组 D2 的第 i 行、第 j 列的元素，其寻址有二个自由度。多一个可变的量，其寻址方式的灵活度也就相应提高了。</p>
<p>相对基址加变址寻址方式有多种等价的书写方式，下面的书写格式都是正确的，并且其寻址含义也是一致的。</p>
<p>MOV 　 AX, [BX+SI+1000H]　　　 MOV 　 AX, 1000H[BX+SI]<br>MOV 　 AX, 1000H[BX][si]　　　 MOV 　 AX, 1000H[SI][bx]</p>
<p>但书写格式 BX [1000+SI]和 SI[1000H+BX]等是错误的，即所用寄存器不能在“[“，”]”之外，该限制对寄存器相对寻址方式的书写也同样起作用。</p>
<p>相对基址加变址寻址方式是以上 7 种寻址方式中最复杂的一种寻址方式，它可变形为其它类型的存储器寻址方式。下表列举出该寻址方式与其它寻址方式之间的变形关系。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/07/KAFKA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/07/KAFKA/" class="post-title-link" itemprop="url">KAFKA</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-07 16:07:30" itemprop="dateCreated datePublished" datetime="2020-12-07T16:07:30+08:00">2020-12-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-02-21 14:40:13" itemprop="dateModified" datetime="2021-02-21T14:40:13+08:00">2021-02-21</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/images/kafka-1.png"></p>
<h2 id="1-根目录下的结构"><a href="#1-根目录下的结构" class="headerlink" title="1.根目录下的结构"></a>1.根目录下的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 72] ls &#x2F;</span><br><span class="line">[isr_change_notification, zookeeper, admin, consumers, cluster, config, latest_producer_id_block, controller, brokers, controller_epoch]</span><br></pre></td></tr></table></figure>

<h2 id="2-admin-的结构"><a href="#2-admin-的结构" class="headerlink" title="2. admin 的结构"></a>2. admin 的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 73] ls &#x2F;admin</span><br><span class="line">[delete_topics]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 74] ls &#x2F;admin&#x2F;delete_topics</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 75] get &#x2F;admin&#x2F;delete_topics</span><br><span class="line">null</span><br><span class="line">cZxid &#x3D; 0xe</span><br><span class="line">ctime &#x3D; Sun Sep 02 20:04:12 PDT 2018</span><br><span class="line">mZxid &#x3D; 0xe</span><br><span class="line">mtime &#x3D; Sun Sep 02 20:04:12 PDT 2018</span><br><span class="line">pZxid &#x3D; 0xe</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x0</span><br><span class="line">dataLength &#x3D; 0</span><br><span class="line">numChildren &#x3D; 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 76]</span><br></pre></td></tr></table></figure>

<h2 id="3-consumers-的结构"><a href="#3-consumers-的结构" class="headerlink" title="3.consumers 的结构"></a>3.consumers 的结构</h2><p>本环境上没有设置消费组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 78] ls &#x2F;consumers</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 79] get &#x2F;consumers</span><br><span class="line">null</span><br><span class="line">cZxid &#x3D; 0x2</span><br><span class="line">ctime &#x3D; Sun Sep 02 20:04:12 PDT 2018</span><br><span class="line">mZxid &#x3D; 0x2</span><br><span class="line">mtime &#x3D; Sun Sep 02 20:04:12 PDT 2018</span><br><span class="line">pZxid &#x3D; 0x2</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x0</span><br><span class="line">dataLength &#x3D; 0</span><br><span class="line">numChildren &#x3D; 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 80]</span><br><span class="line">## 4.config的结构</span><br><span class="line">[zk: localhost:2181(CONNECTED) 82] ls &#x2F;config</span><br><span class="line">[topics, clients, changes]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 83] ls &#x2F;config&#x2F;topics</span><br><span class="line">[__consumer_offsets, test, test2]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 84] ls &#x2F;config&#x2F;topics&#x2F;test2</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 85] get &#x2F;config&#x2F;topics&#x2F;test2</span><br><span class="line">&#123;&quot;version&quot;:1,&quot;config&quot;:&#123;&#125;&#125;</span><br><span class="line">cZxid &#x3D; 0xcc</span><br><span class="line">ctime &#x3D; Sun Sep 02 20:18:06 PDT 2018</span><br><span class="line">mZxid &#x3D; 0xcc</span><br><span class="line">mtime &#x3D; Sun Sep 02 20:18:06 PDT 2018</span><br><span class="line">pZxid &#x3D; 0xcc</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x0</span><br><span class="line">dataLength &#x3D; 25</span><br><span class="line">numChildren &#x3D; 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 86]</span><br></pre></td></tr></table></figure>

<h2 id="5-controllers-的结构"><a href="#5-controllers-的结构" class="headerlink" title="5.controllers 的结构"></a>5.controllers 的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 92] ls &#x2F;controller</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 93] get &#x2F;controller</span><br><span class="line">&#123;&quot;version&quot;:1,&quot;brokerid&quot;:0,&quot;timestamp&quot;:&quot;1535943857541&quot;&#125; &#x2F;&#x2F;表示broker0为kafka的控制节点</span><br><span class="line">cZxid &#x3D; 0x15</span><br><span class="line">ctime &#x3D; Sun Sep 02 20:04:17 PDT 2018</span><br><span class="line">mZxid &#x3D; 0x15</span><br><span class="line">mtime &#x3D; Sun Sep 02 20:04:17 PDT 2018</span><br><span class="line">pZxid &#x3D; 0x15</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x1659d6268f60000</span><br><span class="line">dataLength &#x3D; 54</span><br><span class="line">numChildren &#x3D; 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 94]</span><br><span class="line">## 6.brokers的结构</span><br><span class="line">[zk: localhost:2181(CONNECTED) 95] ls &#x2F;brokers</span><br><span class="line">[seqid, topics, ids]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 96] ls &#x2F;brokers&#x2F;ids</span><br><span class="line">[0]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 97] get &#x2F;brokers&#x2F;ids&#x2F;0</span><br><span class="line">&#123;&quot;listener_security_protocol_map&quot;:&#123;&quot;PLAINTEXT&quot;:&quot;PLAINTEXT&quot;&#125;,&quot;endpoints&quot;:[&quot;PLAINTEXT:&#x2F;&#x2F;localhost:9092&quot;],&quot;jmx_port&quot;:-1,&quot;host&quot;:&quot;localhost&quot;,&quot;timestamp&quot;:&quot;1535943859255&quot;,&quot;port&quot;:9092,&quot;version&quot;:4&#125;</span><br><span class="line">cZxid &#x3D; 0x1c</span><br><span class="line">ctime &#x3D; Sun Sep 02 20:04:19 PDT 2018</span><br><span class="line">mZxid &#x3D; 0x1c</span><br><span class="line">mtime &#x3D; Sun Sep 02 20:04:19 PDT 2018</span><br><span class="line">pZxid &#x3D; 0x1c</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x1659d6268f60000</span><br><span class="line">dataLength &#x3D; 188</span><br><span class="line">numChildren &#x3D; 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 98]</span><br><span class="line"></span><br><span class="line">------------------------------brokers&#x2F;topics----------------------</span><br><span class="line">[zk: localhost:2181(CONNECTED) 100] ls &#x2F;brokers&#x2F;topics</span><br><span class="line">[__consumer_offsets, test, test2]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 101] ls &#x2F;brokers&#x2F;topics&#x2F;test</span><br><span class="line"></span><br><span class="line">test    test2</span><br><span class="line">[zk: localhost:2181(CONNECTED) 101] ls &#x2F;brokers&#x2F;topics&#x2F;test2</span><br><span class="line">[partitions]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 102] ls &#x2F;brokers&#x2F;topics&#x2F;test2&#x2F;partitions</span><br><span class="line">[2, 1, 0]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 103] ls &#x2F;brokers&#x2F;topics&#x2F;test2&#x2F;partitions&#x2F;2</span><br><span class="line">[state]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 104] ls &#x2F;brokers&#x2F;topics&#x2F;test2&#x2F;partitions&#x2F;2&#x2F;state</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 105] get &#x2F;brokers&#x2F;topics&#x2F;test2&#x2F;partitions&#x2F;2&#x2F;state</span><br><span class="line">&#123;&quot;controller_epoch&quot;:1,&quot;leader&quot;:0,&quot;version&quot;:1,&quot;leader_epoch&quot;:0,&quot;isr&quot;:[0]&#125;</span><br><span class="line">&#x2F;&#x2F;表示partition 0 的leader是在0 broker上</span><br><span class="line">cZxid &#x3D; 0xd2</span><br><span class="line">ctime &#x3D; Sun Sep 02 20:18:06 PDT 2018</span><br><span class="line">mZxid &#x3D; 0xd2</span><br><span class="line">mtime &#x3D; Sun Sep 02 20:18:06 PDT 2018</span><br><span class="line">pZxid &#x3D; 0xd2</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x0</span><br><span class="line">dataLength &#x3D; 72</span><br><span class="line">numChildren &#x3D; 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 106]</span><br></pre></td></tr></table></figure>

<h2 id="6-深入理解生产者和消费者"><a href="#6-深入理解生产者和消费者" class="headerlink" title="6.深入理解生产者和消费者"></a>6.深入理解生产者和消费者</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mcbye/p/kafka-producer-in-detail.html">https://www.cnblogs.com/mcbye/p/kafka-producer-in-detail.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mcbye/p/kafka-consumer-in-detail.html">https://www.cnblogs.com/mcbye/p/kafka-consumer-in-detail.html</a></p>
<h2 id="7-重平衡"><a href="#7-重平衡" class="headerlink" title="7.重平衡"></a>7.重平衡</h2><p>说完消费者组，再来说说与消费者组息息相关的重平衡机制。重平衡可以说是 kafka 为人诟病最多的一个点了。</p>
<p>重平衡其实就是一个协议，它规定了如何让消费者组下的所有消费者来分配 topic 中的每一个分区。比如一个 topic 有 100 个分区，一个消费者组内有 20 个消费者，在协调者的控制下让组内每一个消费者分配到 5 个分区，这个分配的过程就是重平衡。</p>
<p>重平衡的触发条件主要有三个：</p>
<ul>
<li>消费者组内成员发生变更，这个变更包括了增加和减少消费者。注意这里的减少有很大的可能是被动的，就是某个消费者崩溃退出了</li>
<li>主题的分区数发生变更，kafka 目前只支持增加分区，当增加的时候就会触发重平衡</li>
<li>订阅的主题发生变化，当消费者组使用正则表达式订阅主题，而恰好又新建了对应的主题，就会触发重平衡</li>
</ul>
<p>为什么说重平衡为人诟病呢？因为重平衡过程中，消费者无法从 kafka 消费消息，这对 kafka 的 TPS 影响极大，而如果 kafka 集内节点较多，比如数百个，那重平衡可能会耗时极多。数分钟到数小时都有可能，而这段时间 kafka 基本处于不可用状态。所以在实际环境中，应该尽量避免重平衡发生。</p>
<p>了解了什么是重平衡，重平衡的缺点和触发条件后，我们先来看看重平衡的三种不同策略，然后说说应该如何避免重平衡发生。</p>
<h4 id="三种重平衡策略"><a href="#三种重平衡策略" class="headerlink" title="三种重平衡策略"></a>三种重平衡策略</h4><p>kafka 提供了三种重平衡分配策略，这里顺便介绍一下：</p>
<h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p>具体实现位于，package org.apache.kafka.clients.consumer.RangeAssignor。</p>
<p>这种分配是基于每个主题的分区分配，如果主题的分区分区不能平均分配给组内每个消费者，那么对该主题，某些消费者会被分配到额外的分区。我们来看看具体的例子。</p>
<p>举例：目前有两个消费者 C0 和 C1，两个主题 t0 和 t1，每个主题三个分区，分别是 t0p0，t0p1，t0p2，和 t1p0，t1p1，t1p2。</p>
<p>那么分配情况会是：</p>
<ul>
<li>C0：t0p0, t0p1, t1p0, t1p1</li>
<li>C1：t0p2, t1p2</li>
</ul>
<p>我来大概解释一下，range 这种模式，消费者被分配的单位是基于主题的，拿上面的例子来说，是主题 t0 的三个分区分配给 2 个消费者，t1 三个分区分配给消费者。于是便会出现消费者 c0 分配到主题 t0 两个分区，以及 t1 两个分区的情况（一个主题有三个分区，三个分区无法匹配两个消费者，势必有一个消费者分到两个分区），而非每个消费者分配两个主题各三个分区。</p>
<h4 id="RoundRobin"><a href="#RoundRobin" class="headerlink" title="RoundRobin"></a>RoundRobin</h4><p>具体实现位于，package org.apache.kafka.clients.consumer.RoundRobinAssignor。</p>
<p>RoundRobin 是基于全部主题的分区来进行分配的，同时这种分配也是 kafka 默认的 rebalance 分区策略。还是用刚刚的例子来看，</p>
<p>举例：两个消费者 C0 和 C1，两个主题 t0 和 t1，每个主题三个分区，分别是 t0p0，t0p1，t0p2，和 t1p0，t1p1，t1p2。</p>
<p>由于是基于全部主题的分区，那么分配情况会是：</p>
<ul>
<li>C0：t0p0, t0p1, t1p1</li>
<li>C1：t1p0, t0p2, t1p2<br>因为是基于全部主题的分区来平均分配给消费者，所以这种分配策略能更加均衡得分配分区给每一个消费者。</li>
</ul>
<p>上面说的都是同一消费者组内消费组都订阅相同主题的情况。更复杂的情况是，同一组内的消费者订阅不同的主题，那么任然可能会导致分区不均衡的情况。</p>
<p>还是举例说明，有三个消费者 C0，C1，C2 。三个主题 t0，t1，t2，分别有 1，2，3 个分区 t0p0，t1p0，t1p1，t2p0，t2p1，t2p2。</p>
<p>其中，C0 订阅 t0，C1 订阅 t0，t1。C2 订阅 t0，t1，t2。最终订阅情况如下：</p>
<ul>
<li>C0：t0p0</li>
<li>C1：t1p0</li>
<li>C2：t1p1，t2p0，t2p1，t2p2<br>这个结果乍一看有点迷，其实可以这样理解，按照序号顺序进行循环分配，t0 只有一个分区，先碰到 C0 就分配给它了。t1 有两个分区，被 C1 和 C2 订阅，那么会循环将两个分区分配出去，最后到 t2，有三个分区，却只有 C2 订阅，那么就将三个分区分配给 C2。</li>
</ul>
<h4 id="Sticky"><a href="#Sticky" class="headerlink" title="Sticky"></a>Sticky</h4><p>Sticky 分配策略是最新的也是最复杂的策略，其具体实现位于 package org.apache.kafka.clients.consumer.StickyAssignor。</p>
<p>这种分配策略是在 0.11.0 才被提出来的，主要是为了一定程度解决上面提到的重平衡非要重新分配全部分区的问题。称为粘性分配策略。</p>
<p>听名字就知道，主要是为了让目前的分配尽可能保持不变，只挪动尽可能少的分区来实现重平衡。</p>
<p>还是举例说明，有三个消费者 C0，C1，C2 。三个主题 t0，t1，t2，t3。每个主题各有两个分区， t0p0，t0p1，t1p0，t1p1，t2p0，t2p1，t3p0，t3p1。</p>
<p>现在订阅情况如下：</p>
<ul>
<li>C0：t0p0，t1p1，t3p0</li>
<li>C1：t0p1，t2p0，t3p1</li>
<li>C2：t1p0，t2p1</li>
</ul>
<p>假设现在 C1 挂掉了，如果是 RoundRobin 分配策略，那么会变成下面这样：</p>
<ul>
<li>C0：t0p0，t1p0，t2p0，t3p0</li>
<li>C2：t0p1，t1p1，t2p1，t3p1</li>
</ul>
<p>就是说它会全部重新打乱，再分配，而如何使用 Sticky 分配策略，会变成这样：</p>
<ul>
<li>C0：t0p0，t1p1，t3p0，t2p0</li>
<li>C2：t1p0，t2p1，t0p1，t3p1</li>
</ul>
<p>也就是说，尽可能保留了原来的分区情况，不去改变它，在这个基础上进行均衡分配，不过这个策略目前似乎还有些 bug，所以实际使用也不多。</p>
<h4 id="避免重平衡"><a href="#避免重平衡" class="headerlink" title="避免重平衡"></a>避免重平衡</h4><p>要说完全避免重平衡，那是不可能滴，因为你无法完全保证消费者不会故障。而消费者故障其实也是最常见的引发重平衡的地方，所以这里主要介绍如何尽力避免消费者故障。</p>
<p>而其他几种触发重平衡的方式，增加分区，或是增加订阅的主题，抑或是增加消费者，更多的是主动控制，这里也不多讨论。</p>
<p>首先要知道，如果消费者真正挂掉了，那我们是没有什么办法的，但实际中，会有一些情况，会让 kafka 错误地认为一个正常的消费者已经挂掉了，我们要的就是避免这样的情况出现。</p>
<p>当然要避免，那首先要知道哪些情况会出现错误判断挂掉的情况。在分布式系统中，通常是通过心跳来维持分布式系统的，kafka 也不例外。对这部分内容有兴趣可以看看我之前的这篇分布式系统一致性问题与 Raft 算法（上）。这里要说的是，在分布式系统中，由于网络问题你不清楚没接收到心跳，是因为对方真正挂了还是只是因为负载过重没来得及发生心跳或是网络堵塞。所以一般会约定一个时间，超时即判定对方挂了。而在 kafka 消费者场景中，session.timout.ms 参数就是规定这个超时时间是多少。</p>
<p>还有一个参数，heartbeat.interval.ms，这个参数控制发送心跳的频率，频率越高越不容易被误判，但也会消耗更多资源。</p>
<p>此外，还有最后一个参数，max.poll.interval.ms，我们都知道消费者 poll 数据后，需要一些处理，再进行拉取。如果两次拉取时间间隔超过这个参数设置的值，那么消费者就会被踢出消费者组。也就是说，拉取，然后处理，这个处理的时间不能超过 max.poll.interval.ms 这个参数的值。这个参数的默认值是 5 分钟，而如果消费者接收到数据后会执行耗时的操作，则应该将其设置得大一些。</p>
<p>小结一下，其实主要就是三个参数，session.timout.ms 控制心跳超时时间，heartbeat.interval.ms 控制心跳发送频率，以及 max.poll.interval.ms 控制 poll 的间隔。这里给出一个相对较为合理的配置，如下：</p>
<p>session.timout.ms：设置为 6s<br>heartbeat.interval.ms：设置 2s<br>max.poll.interval.ms：推荐为消费者处理消息最长耗时再加 1 分钟</p>
<h2 id="8-无法消费消息"><a href="#8-无法消费消息" class="headerlink" title="8.无法消费消息"></a>8.无法消费消息</h2><p>kafka 消费不到数据的原因，首先检查配置之类的，如是否设置了 group.id，对应的 topic 是否正确等等，这些不多说。</p>
<p>下面是我遇到的几种 kafka 消费不到数据的情况：</p>
<h4 id="8-1-重复消费"><a href="#8-1-重复消费" class="headerlink" title="8.1 重复消费"></a>8.1 重复消费</h4><p>参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d63c1576e6cc">https://www.jianshu.com/p/d63c1576e6cc</a><br>下面进行详细分析：</p>
<p>“消费确认”是所有消息中间件都要解决的一个问题，在 kafka 中涉及到两个消费位置：</p>
<p>（1）当前取消息所在的 consume offset；</p>
<p>（2）程序处理完毕发送 ack（确认字符）后所确定的 committed offset。</p>
<p>很显然，在异步模式下，committed offset 要落后于 consume offset。假如 consumer 挂了重启，那么它将从 commited offset 位置处开始重新消费，而不是 consume offset 位置，这也就意味着很可能重复消费，所以会导致一条数据也抓不到。</p>
<p>那么怎么解决这个问题呢？</p>
<p>答案就是自己保存 commited offset，而不是依赖 kafka 的集群保存 commited offset，把消息的处理和保存 offset 做成一个原子操作。</p>
<p>如何将消息的处理和保存 offset 做成一个原子操作呢，Kafka 的官方文档列举了自己保存 offset 的两种使用场景：<br><img src="/images/kafka-2.png"><br>要自己保存 committed offset，就要做到以下几个操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Configure enable.auto.commit&#x3D;false   &#x2F;&#x2F;禁用自动ack</span><br><span class="line">Use the offset provided with each ConsumerRecord to save your position. &#x2F;&#x2F;每次取到消息，把对应的offset存下来</span><br><span class="line">On restart restore the position of the consumer using seek(TopicPartition, long).&#x2F;&#x2F;下次重启，通过consumer.seek函数，定位到自己保存的offset，从那开始消费</span><br></pre></td></tr></table></figure>

<p>Kafka 本身的机制只能保证消息不漏，即”at least once”，而通过自己来保存 committed offset，我们可以实现消费端的消息不重，即”exactly once”，达到消息不重不丢的目的。</p>
<h4 id="8-2-消息被清理掉"><a href="#8-2-消息被清理掉" class="headerlink" title="8.2 消息被清理掉"></a>8.2 消息被清理掉</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sylvialucy/p/7827044.html">https://www.cnblogs.com/sylvialucy/p/7827044.html</a></p>
<p>1.长时间不消费导致 log.retention.hours 或者 log.retention.minutes 超时，清除 log，Offset.Stored 失效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.Assign(new List&lt;TopicPartitionOffset&gt;()&#123; new TopicPartitionOffset(new TopicPartition(&quot;topic&quot;, 1), new Offset(index)) &#125;);</span><br></pre></td></tr></table></figure>

<p>2.我一次加数据太多导致磁盘耗尽，kafka 管理员帮我改到 20G 内存，但是仍然有一部分数据超出，分区 offset 靠前的数据被清除，导致再次消费不到。清除掉的数据无法再次被消费，但是还保存的数据可以消费到.</p>
<p>解决办法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.Assign(new List&lt;TopicPartitionOffset&gt;()&#123; new TopicPartitionOffset(new TopicPartition(&quot;topic&quot;, 1), Offset.Beginning) &#125;);</span><br></pre></td></tr></table></figure>

<p>或者在配置中加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto.offset.reset&#x3D;smallest &#x2F;&#x2F;.NET 默认是largest</span><br><span class="line">auto.offset.reset&#x3D;earliest&#x2F;&#x2F;Java 默认是latest</span><br></pre></td></tr></table></figure>

<h4 id="8-3-kafka-手动清除-topic"><a href="#8-3-kafka-手动清除-topic" class="headerlink" title="8.3 kafka 手动清除 topic"></a>8.3 kafka 手动清除 topic</h4><p>当手动删除 Kafka 某一分片上的消息日志时，如上图蓝线所示，此是只是将 Kafka Log 中的信息清 0 了，但是 Zookeeper 中的 Partition 和 Offset 数据依然会记录。当重新启动 Kafka 后，我们会发现如下二种情况：</p>
<pre><code> A、客户端无法正常用消费；

 B、在使用Kafka Consumer Offset  Monitor工具进行Kafka监控时会发现Lag(还有多少消息数未读取(Lag=logSize-Offset))为负数；其中此种情况的删除操作需要我们重点关注，后面我们也会详细介绍其对应的操作步骤。</code></pre>
<p>一般正常情况，如果想让 Kafka 客户端正常消费，那么需要 Zookeeper 和 Kafka Log 中的记录保持如上图黄色所示。<br>二、Kafka 消息日志清除</p>
<p>操作步骤主要包括：</p>
<pre><code> 1、停止Kafka运行；

 2、删除Kafka消息日志；

 3、修改ZK的偏移量；

 4、重启Kafka;</code></pre>
<p>上述步骤重点介绍其中的关键步骤。</p>
<p>第 2 步：删除 Kafka 消息日志时，进入 Kafka 消息日志路径（可通过查看$KAFKA_HOME/config/server.properties 中的“log.dirs”知晓），删除相应 topic 文件夹下所有文件(如：“rm -rf ./topicA”)；</p>
<p>第 3 步：修改 ZK 的偏移量时，进入 ZK 的安装目录下，运行./bin/zkCli.sh -server (中间以，分割)，如果不带 server 默认修改的为本机。</p>
<p>示例如下：</p>
<pre><code> A.运行$ZOOKEEPER_HOME/bin/zkCli.sh -server Master:2181,Slave1:2181,Slave2:2181

 B.在ZK上运行ls /consumers/对应的分组/offset/对应的topic,就可以看到此topic下的所有分区了；

  通过get /consumers/对应的分组/offset/对应的topic/对应的分区号，可以查询到该分区上记录的offset;

  通过set /consumers/对应的分组/offset/对应的topic/对应的分区号 修改后的值（一般为0，重置），即可完成对offset的修改；</code></pre>
<p>（注意：B 步骤中的“/consumers”由实际配置情况决定）</p>
<p>三、重建 Topic</p>
<pre><code>操作步骤主要包括如下：

  1、删除Topic;

  2、删除log日志；

  3、删除ZK中的Topic记录</code></pre>
<p>第一步：删除 Topic</p>
<p>运行$KAFKA_HOME/bin/kafka-topics.sh -delete -zookeeper [zookeeper server] -topic [topic name]；如果 kafka 启动时加载的配置文件 server.properties 没有配置 delete.topic.enable = true,那么此时的删除并不是真正的删除。而只是把 topic 标记为：marked for deletion,此时就需要执行第 3 步的操作；</p>
<p>第三步：删除 ZK 中的 Topic 记录</p>
<p>示例如下：</p>
<pre><code> A.运行$ZOOKEEPER_HOME/bin/zkCli.sh -server Master:2181,Slave1:2181,Slave2:2181

 B.进入/admin/delete_topics目录下，找到删除的topic,删除对应的信息。</code></pre>
<p>四、重新启动 Kafka 集群</p>
<h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p>Kafka 使用 Zookeeper 的临时节点来选举控制器, 并在节点加入集群或退出集群时通知控制器。控制器负责在节点加入或离开集群时进行分区首领选举。控制器使用 epoch 来避免“脑裂” 。“脑裂 ”是指两个节点同时认为自己是 当前的控制器。</p>
<p><strong>脑裂问题</strong></p>
<ul>
<li><p>什么是脑裂？<br>kafka 中只有一个控制器 controller 负责分区的 leader 选举，同步 broker 的新增或删除消息，但有时由于网络问题，可能同时有两个 broker 认为自己是 controller，这时候其他的 broker 就会发生脑裂，不知道该听从谁的。</p>
</li>
<li><p>如何解决？controller epoch<br>每当新的 controller 产生的时候就会在 zk 中生成一个全新的、数值更大的 controller epoch 的标识，并同步给其他的 broker 进行保存，这样当第二个 controller 发送指令时，其他的 broker 就会自动忽略。</p>
</li>
<li><p>选举问题?<br>每个消息有自己的 topic 每个 topic 有多个分区 多个分区位于不同的 broker 每个分区有一个主分区和多个从分区。</p>
</li>
</ul>
<p>每个分区都有一个主分区（leader）和多个从分区（fowller) 当一个 broker 宕机时，存在与该 broker 的主分区也会停止服务，因此要重新选举新的 leader 分区。</p>
<ul>
<li>如何选举?<br>控制器会从 zk 中读取 ISR 列表 选取下一个有效的分区副本成为新的 leader</li>
</ul>
<p>Kafka 会在 Zookeeper 上针对每个 Topic 维护一个称为 ISR（in-sync replica，已同步的副本）的集合，该集合中是一些分区的副本。如果这个集合有增减，kafka 会更新 zookeeper 上的记录。</p>
<h2 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h2><p>在 kafka 架构中，通信涉及到以下几点：</p>
<ol>
<li>producer 向 broker 集群生产数据数据 push 形式；</li>
<li>consumer 从 broker 集群消费数据属于 pull 形式；</li>
<li>broker 之间在 replication.factor&gt;1 时，会存在副本之间数据同步，表现为：follower partition 从 leader partition pull 数据，来保证最大限度的拉近 partition 数据不一致。</li>
</ol>
<h2 id="Kafka-Stream"><a href="#Kafka-Stream" class="headerlink" title="Kafka Stream"></a>Kafka Stream</h2><p>支持的功能展示：</p>
<ul>
<li>字数统计这个例子用于演示 map 与 filter 模式以及简单的聚合</li>
<li>另一个股票交易试产的各种统计信息，用于演示基于时间窗口的聚合</li>
<li>最后使用填充点击事件流的例子来演示流的连接</li>
</ul>
<h3 id="KTable"><a href="#KTable" class="headerlink" title="KTable"></a>KTable</h3><p>KTable 可以存储状态，分为两种，内存和磁盘。磁盘依赖于 rockdb，内存依赖于 map。<br>KTable 具有容错功能，使用 kafka 存储事件流，用于恢复。<br>当使用基于 rockdb 的状态存储时，KTable 会优先从本地恢复，如果本地文件丢失则从 kafka 的 change log 事件流 topic 中，回放消息来恢复。<br>当使用基于内存的状态存储时，KTable 会直接从 kafka 的 change log 事件流 topic 中，回放消息来恢复。</p>
<h2 id="Kafka-Connect-有待了解？？？"><a href="#Kafka-Connect-有待了解？？？" class="headerlink" title="Kafka Connect 有待了解？？？"></a>Kafka Connect 有待了解？？？</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/06/tmux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/06/tmux/" class="post-title-link" itemprop="url">tmux相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-06 16:07:30 / Modified: 11:54:02" itemprop="dateCreated datePublished" datetime="2020-12-06T16:07:30+08:00">2020-12-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>tmux 是 Linux 中窗口管理程序，适用于终端复用，尤其适合远程连接。最近，我正苦闷与 ssh 自动超时退出和 broken pipe，决定投入 tmux 怀抱。<br>使用 tmux 最直接的好处，便是可以在一个远程连接中开启多个控制台，而不用浪费额外的终端来连接远程主机。更不用说 tmux 方便的 attach/detach,随时保存工作状态，还有方便的复制粘贴功能。</p>
<p>基本使用<br>tmux 的主要元素分为三层：</p>
<p>Session: 一组窗口的集合，通常用来概括同一个任务。session 可以有自己的名字便于任务之间的切换。<br>Window: 单个可见窗口。Windows 有自己的编号，也可以认为和 ITerm2 中的 Tab 类似。<br>Pane: 窗格，被划分成小块的窗口，类似于 Vim 中 C-w +v 后的效果。</p>
<p>在安装好 tmux 后，直接在终端中输入 tmux 并回车，就进入了一个全新的 tmux 会话，输入 exit 即可退出。<br>可以在一台计算机上创建多个会话，并且通过为每个会话指定一个唯一的名称来管理它们：<br>tmux new-session -s basic<br>此命令可简化为：tmux new -s basic。<br>由于我们的程序是在 tmux 环境里运行的，因此需要一种方式来告诉 tmux 当前所输入的命令是为了让 tmux 去执行而不是 tmux 里的应用程序去执行，这就是命令前缀的作用。tmux 中默认的命令前缀是 CTRL-b 组合键，但 CTRL-b 组合键使用不是很方便，可将其修改为 CTRL-a 组合键。按下命令前缀组合键，松开，再按相应键，即发送 tmux 命令。</p>
<p>tmux 创建会话</p>
<ul>
<li>tmux new-session 创建一个未命名的会话。可以简写为 tmux new 或者就一个简单的 tmux</li>
<li>tmux new -s development 创建一个名为 development 的会话</li>
<li>tmux new -s development -n editor 创建一个名为 development 的会话并把该会话的第一个窗口命名为 editor</li>
<li>tmux attach -t development 连接到一个名为 development 的会话</li>
</ul>
<p>tmux 会话、窗口和面板的默认快捷键</p>
<ul>
<li>PREFIX d 从一个会话中分离，让该会话在后台运行。</li>
<li>PREFIX : 进入命令模式</li>
<li>PREFIX c 在当前 tmux 会话创建一个新的窗口，是 new-window 命令的简写</li>
<li>PREFIX 0…9 根据窗口的编号选择窗口</li>
<li>PREFIX w 显示当前会话中所有窗口的可选择列表</li>
<li>PREFIX , 显示一个提示符来重命名一个窗口</li>
<li>PREFIX &amp; 杀死当前窗口，带有确认提示</li>
<li>PREFIX % 把当前窗口垂直地一分为二，分割后的两个面板各占 50% 大小</li>
<li>PREFIX “ 把当前窗口水平地一分为二，分割后的两个面板各占 50% 大小</li>
<li>PREFIX o 在已打开的面板之间循环移动当前焦点</li>
<li>PREFIX q 短暂地显示每个面板的编号</li>
<li>PREFIX x 关闭当前面板，带有确认提示</li>
<li>PREFIX SPACE 循环地使用 tmux 的几个默认面板布局</li>
</ul>
<p>tmux 复制粘贴</p>
<ul>
<li>PREFIX [ 进入复制模式</li>
<li>PREFIX ] 粘贴<br>进入复制模式后，可以用 vi 风格的快捷键进行移动（按上文的设置）。按下 sapce 就可以选择文本。回车键进行复制。然后再通过]进行粘贴。<br>也可以将复制粘贴设置为类似 vi 的模式，使用 esc 进入复制模式，v 进入粘贴模式，选择后 y 进行复制。Prefix-p 进行粘贴。</li>
</ul>
<h1 id="Copy-and-paste-like-in-vim"><a href="#Copy-and-paste-like-in-vim" class="headerlink" title="Copy and paste like in vim"></a>Copy and paste like in vim</h1><p>unbind [<br>bind Escape copy-mode<br>unbind p<br>bind p paste-buffer<br>bind -t vi-copy ‘v’ begin-selection<br>bind -t vi-copy ‘y’ copy-selection</p>
<p>所有的复制都会被记录到缓冲区，输入#或者 tmux list-buffers 查看缓冲区,同时也进入了复制模式。也可以使用”=”来选择并粘贴缓冲区内容。tmux 的缓冲区和系统剪贴板是完全独立的。</p>
<p>自主配置</p>
<h1 id="把前缀键从-C-b-更改为-C-a"><a href="#把前缀键从-C-b-更改为-C-a" class="headerlink" title="把前缀键从 C-b 更改为 C-a"></a>把前缀键从 C-b 更改为 C-a</h1><p>set -g prefix C-a</p>
<h1 id="释放之前的-Ctrl-b-前缀快捷键"><a href="#释放之前的-Ctrl-b-前缀快捷键" class="headerlink" title="释放之前的 Ctrl-b 前缀快捷键"></a>释放之前的 Ctrl-b 前缀快捷键</h1><p>unbind C-b</p>
<h1 id="设定前缀键和命令键之间的延时"><a href="#设定前缀键和命令键之间的延时" class="headerlink" title="设定前缀键和命令键之间的延时"></a>设定前缀键和命令键之间的延时</h1><p>set -sg escape-time 1</p>
<h1 id="确保可以向其它程序发送-Ctrl-A"><a href="#确保可以向其它程序发送-Ctrl-A" class="headerlink" title="确保可以向其它程序发送 Ctrl-A"></a>确保可以向其它程序发送 Ctrl-A</h1><p>bind C-a send-prefix</p>
<h1 id="把窗口的初始索引值从-0-改为-1"><a href="#把窗口的初始索引值从-0-改为-1" class="headerlink" title="把窗口的初始索引值从 0 改为 1"></a>把窗口的初始索引值从 0 改为 1</h1><p>set -g base-index 1</p>
<h1 id="把面板的初始索引值从-0-改为-1"><a href="#把面板的初始索引值从-0-改为-1" class="headerlink" title="把面板的初始索引值从 0 改为 1"></a>把面板的初始索引值从 0 改为 1</h1><p>setw -g pane-base-index 1</p>
<h1 id="使用-Prefix-r-重新加载配置文件"><a href="#使用-Prefix-r-重新加载配置文件" class="headerlink" title="使用 Prefix r 重新加载配置文件"></a>使用 Prefix r 重新加载配置文件</h1><p>bind r source-file ~/.tmux.conf ; display “Reloaded!”</p>
<h1 id="分割面板"><a href="#分割面板" class="headerlink" title="分割面板"></a>分割面板</h1><p>bind | split-window -h<br>bind - split-window -v</p>
<h1 id="在面板之间移动"><a href="#在面板之间移动" class="headerlink" title="在面板之间移动"></a>在面板之间移动</h1><p>bind h select-pane -L<br>bind j select-pane -D<br>bind k select-pane -U<br>bind l select-pane -R</p>
<h1 id="快速选择面板"><a href="#快速选择面板" class="headerlink" title="快速选择面板"></a>快速选择面板</h1><p>bind -r C-h select-window -t :-<br>bind -r C-l select-window -t :+</p>
<h1 id="调整面板大小"><a href="#调整面板大小" class="headerlink" title="调整面板大小"></a>调整面板大小</h1><p>bind -r H resize-pane -L 5<br>bind -r J resize-pane -D 5<br>bind -r K resize-pane -U 5<br>bind -r L resize-pane -R 5</p>
<h1 id="鼠标支持-如果你想使用的话把-off-改为-on"><a href="#鼠标支持-如果你想使用的话把-off-改为-on" class="headerlink" title="鼠标支持 - 如果你想使用的话把 off 改为 on"></a>鼠标支持 - 如果你想使用的话把 off 改为 on</h1><p>setw -g mode-mouse off<br>set -g mouse-select-pane off<br>set -g mouse-resize-pane off<br>set -g mouse-select-window off</p>
<h1 id="设置默认的终端模式为-256-色模式"><a href="#设置默认的终端模式为-256-色模式" class="headerlink" title="设置默认的终端模式为 256 色模式"></a>设置默认的终端模式为 256 色模式</h1><p>set -g default-terminal “screen-256color”</p>
<h1 id="开启活动通知"><a href="#开启活动通知" class="headerlink" title="开启活动通知"></a>开启活动通知</h1><p>setw -g monitor-activity on<br>set -g visual-activity on</p>
<h1 id="设置状态栏的颜色"><a href="#设置状态栏的颜色" class="headerlink" title="设置状态栏的颜色"></a>设置状态栏的颜色</h1><p>set -g status-fg white<br>set -g status-bg black</p>
<h1 id="设置窗口列表的颜色"><a href="#设置窗口列表的颜色" class="headerlink" title="设置窗口列表的颜色"></a>设置窗口列表的颜色</h1><p>setw -g window-status-fg cyan<br>setw -g window-status-bg default<br>setw -g window-status-attr dim</p>
<h1 id="设置活动窗口的颜色"><a href="#设置活动窗口的颜色" class="headerlink" title="设置活动窗口的颜色"></a>设置活动窗口的颜色</h1><p>setw -g window-status-current-fg white<br>setw -g window-status-current-bg red<br>setw -g window-status-current-attr bright</p>
<h1 id="设置面板和活动面板的颜色"><a href="#设置面板和活动面板的颜色" class="headerlink" title="设置面板和活动面板的颜色"></a>设置面板和活动面板的颜色</h1><p>set -g pane-border-fg green<br>set -g pane-border-bg black<br>set -g pane-active-border-fg white<br>set -g pane-active-border-bg yellow</p>
<h1 id="设置命令行或消息的颜色"><a href="#设置命令行或消息的颜色" class="headerlink" title="设置命令行或消息的颜色"></a>设置命令行或消息的颜色</h1><p>set -g message-fg white<br>set -g message-bg black<br>set -g message-attr bright</p>
<h1 id="设置状态栏左侧的内容和颜色"><a href="#设置状态栏左侧的内容和颜色" class="headerlink" title="设置状态栏左侧的内容和颜色"></a>设置状态栏左侧的内容和颜色</h1><p>set -g status-left-length 40<br>set -g status-left “#[fg=green]Session: #S #[fg=yellow]#I #[fg=cyan]#P”<br>set -g status-utf8 on</p>
<h1 id="设置状态栏右侧的内容和颜色"><a href="#设置状态栏右侧的内容和颜色" class="headerlink" title="设置状态栏右侧的内容和颜色"></a>设置状态栏右侧的内容和颜色</h1><h1 id="15-28-Nov-18-15"><a href="#15-28-Nov-18-15" class="headerlink" title="15% | 28 Nov 18:15"></a>15% | 28 Nov 18:15</h1><p>set -g status-right “#(~/battery Discharging) | #[fg=cyan]%d %b %R”</p>
<h1 id="每-60-秒更新一次状态栏"><a href="#每-60-秒更新一次状态栏" class="headerlink" title="每 60 秒更新一次状态栏"></a>每 60 秒更新一次状态栏</h1><p>set -g status-interval 60</p>
<h1 id="设置窗口列表居中显示"><a href="#设置窗口列表居中显示" class="headerlink" title="设置窗口列表居中显示"></a>设置窗口列表居中显示</h1><p>set -g status-justify centre</p>
<h1 id="开启-vi-按键"><a href="#开启-vi-按键" class="headerlink" title="开启 vi 按键"></a>开启 vi 按键</h1><p>setw -g mode-keys vi</p>
<h1 id="在相同目录下使用-tmux-panes-脚本开启面板"><a href="#在相同目录下使用-tmux-panes-脚本开启面板" class="headerlink" title="在相同目录下使用 tmux-panes 脚本开启面板"></a>在相同目录下使用 tmux-panes 脚本开启面板</h1><p>unbind v<br>unbind n<br>bind v send-keys “ ~/tmux-panes -h” C-m<br>bind n send-keys “ ~/tmux-panes -v” C-m</p>
<h1 id="临时最大化面板或恢复面板大小"><a href="#临时最大化面板或恢复面板大小" class="headerlink" title="临时最大化面板或恢复面板大小"></a>临时最大化面板或恢复面板大小</h1><p>unbind Up<br>bind Up new-window -d -n tmp ; swap-pane -s tmp.1 ; select-window -t tmp<br>unbind Down<br>bind Down last-window ; swap-pane -s tmp.1 ; kill-window -t tmp</p>
<h1 id="把日志输出到指定文件"><a href="#把日志输出到指定文件" class="headerlink" title="把日志输出到指定文件"></a>把日志输出到指定文件</h1><p>bind P pipe-pane -o “cat &gt;&gt;~/#W.log” ; display “Toggled logging to ~/#W.log”</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/06/mockito/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/06/mockito/" class="post-title-link" itemprop="url">Mockito相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-12-06 16:07:30 / Modified: 11:53:33" itemprop="dateCreated datePublished" datetime="2020-12-06T16:07:30+08:00">2020-12-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-Mockito-介绍"><a href="#1-Mockito-介绍" class="headerlink" title="1 Mockito 介绍"></a>1 Mockito 介绍</h1><h2 id="1-1-Mockito-是什么？"><a href="#1-1-Mockito-是什么？" class="headerlink" title="1.1 Mockito 是什么？"></a>1.1 Mockito 是什么？</h2><p>Mockito 是 mocking 框架，它让你用简洁的 API 做测试。而且 Mockito 简单易学，它可读性强和验证语法简洁。</p>
<h2 id="1-2-为什么需要-Mock"><a href="#1-2-为什么需要-Mock" class="headerlink" title="1.2 为什么需要 Mock"></a>1.2 为什么需要 Mock</h2><p>测试驱动的开发( TDD)要求我们先写单元测试，再写实现代码。在写单元测试的过程中，我们往往会遇到要测试的类有很多依赖，这些依赖的类/对象/资源又有别的依赖，从而形成一个大的依赖树，要在单元测试的环境中完整地构建这样的依赖，是一件很困难的事情。如下图所示：<br><img src="/images/mockito-1.png"><br>为了测试类 A，我们需要 Mock B 类和 C 类（用虚拟对象来代替）如下图所示：<br><img src="/images/mockito-2.png"></p>
<h2 id="1-3-Stub-和-Mock-异同-1"><a href="#1-3-Stub-和-Mock-异同-1" class="headerlink" title="1.3 Stub 和 Mock 异同[1]"></a>1.3 Stub 和 Mock 异同[1]</h2><p>相同：Stub 和 Mock 都是模拟外部依赖<br>不同：Stub 是完全模拟一个外部依赖， 而 Mock 还可以用来判断测试通过还是失败</p>
<h2 id="1-4-Mockito-资源"><a href="#1-4-Mockito-资源" class="headerlink" title="1.4 Mockito 资源"></a>1.4 Mockito 资源</h2><p>官网： <a target="_blank" rel="noopener" href="http://mockito.org/">http://mockito.org</a></p>
<p>API 文档：<a target="_blank" rel="noopener" href="http://docs.mockito.googlecode.com/hg/org/mockito/Mockito.html">http://docs.mockito.googlecode.com/hg/org/mockito/Mockito.html</a></p>
<p>项目源码：<a target="_blank" rel="noopener" href="https://github.com/mockito/mockito">https://github.com/mockito/mockito</a></p>
<h2 id="1-5-使用场景"><a href="#1-5-使用场景" class="headerlink" title="1.5 使用场景"></a>1.5 使用场景</h2><p>提前创建测试; TDD（测试驱动开发）<br>团队可以并行工作<br>你可以创建一个验证或者演示程序<br>为无法访问的资源编写测试<br>Mock 可以交给用户<br>隔离系统</p>
<h1 id="2-使用-Mockito"><a href="#2-使用-Mockito" class="headerlink" title="2 使用 Mockito"></a>2 使用 Mockito</h1><p>添加 maven 依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mockito&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mockito-all&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.9.5&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>添加 junit 依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.11&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>添加引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import static org.mockito.Mockito._;</span><br><span class="line">import static org.junit.Assert._;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-验证行为"><a href="#2-1-验证行为" class="headerlink" title="2.1 验证行为"></a>2.1 验证行为</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void verify_behaviour()&#123;</span><br><span class="line">&#x2F;&#x2F;模拟创建一个 List 对象</span><br><span class="line">List mock &#x3D; mock(List.class);</span><br><span class="line">&#x2F;&#x2F;使用 mock 的对象</span><br><span class="line">mock.add(1);</span><br><span class="line">mock.clear();</span><br><span class="line">&#x2F;&#x2F;验证 add(1)和 clear()行为是否发生</span><br><span class="line">verify(mock).add(1);</span><br><span class="line">verify(mock).clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-模拟我们所期望的结果"><a href="#2-2-模拟我们所期望的结果" class="headerlink" title="2.2 模拟我们所期望的结果"></a>2.2 模拟我们所期望的结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void when_thenReturn()&#123;</span><br><span class="line">&#x2F;&#x2F;mock 一个 Iterator 类</span><br><span class="line">Iterator iterator &#x3D; mock(Iterator.class);</span><br><span class="line">&#x2F;&#x2F;预设当 iterator 调用 next()时第一次返回 hello，第 n 次都返回 world</span><br><span class="line">when(iterator.next()).thenReturn(&quot;hello&quot;).thenReturn(&quot;world&quot;);</span><br><span class="line">&#x2F;&#x2F;使用 mock 的对象</span><br><span class="line">String result &#x3D; iterator.next() + &quot; &quot; + iterator.next() + &quot; &quot; + iterator.next();</span><br><span class="line">&#x2F;&#x2F;验证结果</span><br><span class="line">assertEquals(&quot;hello world world&quot;,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test(expected &#x3D; IOException.class)</span><br><span class="line">public void when_thenThrow() throws IOException &#123;</span><br><span class="line">OutputStream outputStream &#x3D; mock(OutputStream.class);</span><br><span class="line">OutputStreamWriter writer &#x3D; new OutputStreamWriter(outputStream);</span><br><span class="line">&#x2F;&#x2F;预设当流关闭时抛出异常</span><br><span class="line">doThrow(new IOException()).when(outputStream).close();</span><br><span class="line">outputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-RETURNS-SMART-NULLS-和-RETURNS-DEEP-STUBS"><a href="#2-3-RETURNS-SMART-NULLS-和-RETURNS-DEEP-STUBS" class="headerlink" title="2.3 RETURNS_SMART_NULLS 和 RETURNS_DEEP_STUBS"></a>2.3 RETURNS_SMART_NULLS 和 RETURNS_DEEP_STUBS</h2><p>RETURNS_SMART_NULLS 实现了 Answer 接口的对象，它是创建 mock 对象时的一个可选参数，mock(Class,Answer)。</p>
<p>在创建 mock 对象时，有的方法我们没有进行 stubbing，所以调用时会放回 Null 这样在进行操作是很可能抛出 NullPointerException。如果通过 RETURNS_SMART_NULLS 参数创建的 mock 对象在没有调用 stubbed 方法时会返回 SmartNull。例如：返回类型是 String，会返回””;是 int，会返回 0；是 List，会返回空的 List。另外，在控制台窗口中可以看到 SmartNull 的友好提示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void returnsSmartNullsTest() &#123;</span><br><span class="line">List mock &#x3D; mock(List.class, RETURNS_SMART_NULLS);</span><br><span class="line">System.out.println(mock.get(0));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用 RETURNS_SMART_NULLS 参数创建的 mock 对象，不会抛出 NullPointerException 异常。另外控制台窗口会提示信息“SmartNull returned by unstubbed get() method on mock”</span><br><span class="line">System.out.println(mock.toArray().length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RETURNS_DEEP_STUBS 也是创建 mock 对象时的备选参数</p>
<p>RETURNS_DEEP_STUBS 参数程序会自动进行 mock 所需的对象，方法 deepstubsTest 和 deepstubsTest2 是等价的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void deepstubsTest()&#123;</span><br><span class="line">Account account&#x3D;mock(Account.class,RETURNS_DEEP_STUBS);</span><br><span class="line">when(account.getRailwayTicket().getDestination()).thenReturn(&quot;Beijing&quot;);</span><br><span class="line">account.getRailwayTicket().getDestination();</span><br><span class="line">verify(account.getRailwayTicket()).getDestination();</span><br><span class="line">assertEquals(&quot;Beijing&quot;,account.getRailwayTicket().getDestination());</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void deepstubsTest2()&#123;</span><br><span class="line">Account account&#x3D;mock(Account.class);</span><br><span class="line">RailwayTicket railwayTicket&#x3D;mock(RailwayTicket.class);</span><br><span class="line"> when(account.getRailwayTicket()).thenReturn(railwayTicket);</span><br><span class="line">when(railwayTicket.getDestination()).thenReturn(&quot;Beijing&quot;);</span><br><span class="line"></span><br><span class="line">account.getRailwayTicket().getDestination();</span><br><span class="line">verify(account.getRailwayTicket()).getDestination();</span><br><span class="line"> assertEquals(&quot;Beijing&quot;,account.getRailwayTicket().getDestination());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RailwayTicket&#123;</span><br><span class="line">private String destination;</span><br><span class="line"></span><br><span class="line">        public String getDestination() &#123;</span><br><span class="line">            return destination;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setDestination(String destination) &#123;</span><br><span class="line">            this.destination &#x3D; destination;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class Account&#123;</span><br><span class="line">        private RailwayTicket railwayTicket;</span><br><span class="line"></span><br><span class="line">        public RailwayTicket getRailwayTicket() &#123;</span><br><span class="line">            return railwayTicket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setRailwayTicket(RailwayTicket railwayTicket) &#123;</span><br><span class="line">            this.railwayTicket &#x3D; railwayTicket;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-4-模拟方法体抛出异常"><a href="#2-4-模拟方法体抛出异常" class="headerlink" title="2.4 模拟方法体抛出异常"></a>2.4 模拟方法体抛出异常</h2><p>@Test(expected = RuntimeException.class)<br>public void doThrow_when(){<br>List list = mock(List.class);<br>doThrow(new RuntimeException()).when(list).add(1);<br>list.add(1);<br>}</p>
<h2 id="2-5-使用注解来快速模拟"><a href="#2-5-使用注解来快速模拟" class="headerlink" title="2.5 使用注解来快速模拟"></a>2.5 使用注解来快速模拟</h2><p>在上面的测试中我们在每个测试方法里都 mock 了一个 List 对象，为了避免重复的 mock，是测试类更具有可读性，我们可以使用下面的注解方式来快速模拟对象：</p>
<pre><code>@Mock
private List mockList;</code></pre>
<p>OK，我们再用注解的 mock 对象试试</p>
<pre><code>@Test
public void shorthand()&#123;
    mockList.add(1);
    verify(mockList).add(1);
&#125;</code></pre>
<p>运行这个测试类你会发现报错了，mock 的对象为 NULL，为此我们必须在基类中添加初始化 mock 的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MockitoExample2 &#123;</span><br><span class="line">@Mock</span><br><span class="line">private List mockList;</span><br><span class="line"></span><br><span class="line">    public MockitoExample2()&#123;</span><br><span class="line">        MockitoAnnotations.initMocks(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void shorthand()&#123;</span><br><span class="line">        mockList.add(1);</span><br><span class="line">        verify(mockList).add(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用 built-in runner：MockitoJUnitRunner</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(MockitoJUnitRunner.class)</span><br><span class="line">public class MockitoExample2 &#123;</span><br><span class="line">@Mock</span><br><span class="line">private List mockList;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void shorthand()&#123;</span><br><span class="line">        mockList.add(1);</span><br><span class="line">        verify(mockList).add(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-参数匹配"><a href="#2-6-参数匹配" class="headerlink" title="2.6 参数匹配"></a>2.6 参数匹配</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void with_arguments()&#123;</span><br><span class="line">Comparable comparable &#x3D; mock(Comparable.class);</span><br><span class="line">&#x2F;&#x2F;预设根据不同的参数返回不同的结果</span><br><span class="line">when(comparable.compareTo(&quot;Test&quot;)).thenReturn(1);</span><br><span class="line">when(comparable.compareTo(&quot;Omg&quot;)).thenReturn(2);</span><br><span class="line">assertEquals(1, comparable.compareTo(&quot;Test&quot;));</span><br><span class="line">assertEquals(2, comparable.compareTo(&quot;Omg&quot;));</span><br><span class="line">&#x2F;&#x2F;对于没有预设的情况会返回默认值</span><br><span class="line">assertEquals(0, comparable.compareTo(&quot;Not stub&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了匹配制定参数外，还可以匹配自己想要的任意参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void with_unspecified_arguments()&#123;</span><br><span class="line">List list &#x3D; mock(List.class);</span><br><span class="line">&#x2F;&#x2F;匹配任意参数</span><br><span class="line">when(list.get(anyInt())).thenReturn(1);</span><br><span class="line">when(list.contains(argThat(new IsValid()))).thenReturn(true);</span><br><span class="line">assertEquals(1, list.get(1));</span><br><span class="line">assertEquals(1, list.get(999));</span><br><span class="line">assertTrue(list.contains(1));</span><br><span class="line">assertTrue(!list.contains(3));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    private class IsValid extends ArgumentMatcher&lt;List&gt;&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean matches(Object o) &#123;</span><br><span class="line">            return o &#x3D;&#x3D; 1 || o &#x3D;&#x3D; 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：如果你使用了参数匹配，那么所有的参数都必须通过 matchers 来匹配，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void all_arguments_provided_by_matchers()&#123;</span><br><span class="line">Comparator comparator &#x3D; mock(Comparator.class);</span><br><span class="line">comparator.compare(&quot;nihao&quot;,&quot;hello&quot;);</span><br><span class="line">&#x2F;&#x2F;如果你使用了参数匹配，那么所有的参数都必须通过 matchers 来匹配</span><br><span class="line">verify(comparator).compare(anyString(),eq(&quot;hello&quot;));</span><br><span class="line">&#x2F;&#x2F;下面的为无效的参数匹配使用</span><br><span class="line">&#x2F;&#x2F;verify(comparator).compare(anyString(),&quot;hello&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7-自定义参数匹配"><a href="#2-7-自定义参数匹配" class="headerlink" title="2.7 自定义参数匹配"></a>2.7 自定义参数匹配</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void argumentMatchersTest()&#123;</span><br><span class="line">&#x2F;&#x2F;创建 mock 对象</span><br><span class="line">List&lt;String&gt; mock &#x3D; mock(List.class);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;argThat(Matches&lt;T&gt; matcher)方法用来应用自定义的规则，可以传入任何实现Matcher接口的实现类。</span><br><span class="line">        when(mock.addAll(argThat(new IsListofTwoElements()))).thenReturn(true);</span><br><span class="line"></span><br><span class="line">        mock.addAll(Arrays.asList(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;));</span><br><span class="line">        &#x2F;&#x2F;IsListofTwoElements用来匹配size为2的List，因为例子传入List为三个元素，所以此时将失败。</span><br><span class="line">        verify(mock).addAll(argThat(new IsListofTwoElements()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class IsListofTwoElements extends ArgumentMatcher&lt;List&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        public boolean matches(Object list)</span><br><span class="line">        &#123;</span><br><span class="line">            return((List)list).size()&#x3D;&#x3D;2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-8-捕获参数来进一步断言"><a href="#2-8-捕获参数来进一步断言" class="headerlink" title="2.8 捕获参数来进一步断言"></a>2.8 捕获参数来进一步断言</h2><p>较复杂的参数匹配器会降低代码的可读性，有些地方使用参数捕获器更加合适。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void capturing_args()&#123;</span><br><span class="line">PersonDao personDao &#x3D; mock(PersonDao.class);</span><br><span class="line">PersonService personService &#x3D; new PersonService(personDao);</span><br><span class="line"></span><br><span class="line">        ArgumentCaptor&lt;Person&gt; argument &#x3D; ArgumentCaptor.forClass(Person.class);</span><br><span class="line">        personService.update(1,&quot;jack&quot;);</span><br><span class="line">        verify(personDao).update(argument.capture());</span><br><span class="line">        assertEquals(1,argument.getValue().getId());</span><br><span class="line">        assertEquals(&quot;jack&quot;,argument.getValue().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     class Person&#123;</span><br><span class="line">        private int id;</span><br><span class="line">        private String name;</span><br><span class="line"></span><br><span class="line">        Person(int id, String name) &#123;</span><br><span class="line">            this.id &#x3D; id;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getId() &#123;</span><br><span class="line">            return id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface PersonDao&#123;</span><br><span class="line">        public void update(Person person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class PersonService&#123;</span><br><span class="line">        private PersonDao personDao;</span><br><span class="line"></span><br><span class="line">        PersonService(PersonDao personDao) &#123;</span><br><span class="line">            this.personDao &#x3D; personDao;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void update(int id,String name)&#123;</span><br><span class="line">            personDao.update(new Person(id,name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-9-使用方法预期回调接口生成期望值（Answer-结构）"><a href="#2-9-使用方法预期回调接口生成期望值（Answer-结构）" class="headerlink" title="2.9 使用方法预期回调接口生成期望值（Answer 结构）"></a>2.9 使用方法预期回调接口生成期望值（Answer 结构）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void answerTest()&#123;</span><br><span class="line">when(mockList.get(anyInt())).thenAnswer(new CustomAnswer());</span><br><span class="line">assertEquals(&quot;hello world:0&quot;,mockList.get(0));</span><br><span class="line">assertEquals(&quot;hello world:999&quot;,mockList.get(999));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    private class CustomAnswer implements Answer&lt;String&gt;&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String answer(InvocationOnMock invocation) throws Throwable &#123;</span><br><span class="line">            Object[] args &#x3D; invocation.getArguments();</span><br><span class="line">            return &quot;hello world:&quot;+args[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也可使用匿名内部类实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void answer_with_callback()&#123;</span><br><span class="line">&#x2F;&#x2F;使用 Answer 来生成我们我们期望的返回</span><br><span class="line">when(mockList.get(anyInt())).thenAnswer(new Answer&lt;Object&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Object answer(InvocationOnMock invocation) throws Throwable &#123;</span><br><span class="line">Object[] args &#x3D; invocation.getArguments();</span><br><span class="line">return &quot;hello world:&quot;+args[0];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">assertEquals(&quot;hello world:0&quot;,mockList.get(0));</span><br><span class="line">assertEquals(&quot;hello world:999&quot;,mockList.get(999));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-10-修改对未预设的调用返回默认期望"><a href="#2-10-修改对未预设的调用返回默认期望" class="headerlink" title="2.10 修改对未预设的调用返回默认期望"></a>2.10 修改对未预设的调用返回默认期望</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void unstubbed_invocations()&#123;</span><br><span class="line">&#x2F;&#x2F;mock 对象使用 Answer 来对未预设的调用返回默认期望值</span><br><span class="line">List mock &#x3D; mock(List.class,new Answer() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Object answer(InvocationOnMock invocation) throws Throwable &#123;</span><br><span class="line">return 999;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;下面的 get(1)没有预设，通常情况下会返回 NULL，但是使用了 Answer 改变了默认期望值</span><br><span class="line">assertEquals(999, mock.get(1));</span><br><span class="line">&#x2F;&#x2F;下面的 size()没有预设，通常情况下会返回 0，但是使用了 Answer 改变了默认期望值</span><br><span class="line">assertEquals(999,mock.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-11-用-spy-监控真实对象"><a href="#2-11-用-spy-监控真实对象" class="headerlink" title="2.11 用 spy 监控真实对象"></a>2.11 用 spy 监控真实对象</h2><p>Mock 不是真实的对象，它只是用类型的 class 创建了一个虚拟对象，并可以设置对象行为<br>Spy 是一个真实的对象，但它可以设置对象行为<br>InjectMocks 创建这个类的对象并自动将标记@Mock、@Spy 等注解的属性值注入到这个中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Test(expected &#x3D; IndexOutOfBoundsException.class)</span><br><span class="line">public void spy_on_real_objects()&#123;</span><br><span class="line">List list &#x3D; new LinkedList();</span><br><span class="line">List spy &#x3D; spy(list);</span><br><span class="line">&#x2F;&#x2F;下面预设的 spy.get(0)会报错，因为会调用真实对象的 get(0)，所以会抛出越界异常</span><br><span class="line">&#x2F;&#x2F;when(spy.get(0)).thenReturn(3);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;使用doReturn-when可以避免when-thenReturn调用真实对象api</span><br><span class="line">        doReturn(999).when(spy).get(999);</span><br><span class="line">        &#x2F;&#x2F;预设size()期望值</span><br><span class="line">        when(spy.size()).thenReturn(100);</span><br><span class="line">        &#x2F;&#x2F;调用真实对象的api</span><br><span class="line">        spy.add(1);</span><br><span class="line">        spy.add(2);</span><br><span class="line">        assertEquals(100,spy.size());</span><br><span class="line">        assertEquals(1,spy.get(0));</span><br><span class="line">        assertEquals(2,spy.get(1));</span><br><span class="line">        verify(spy).add(1);</span><br><span class="line">        verify(spy).add(2);</span><br><span class="line">        assertEquals(999,spy.get(999));</span><br><span class="line">        spy.get(2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-12-真实的部分-mock"><a href="#2-12-真实的部分-mock" class="headerlink" title="2.12 真实的部分 mock"></a>2.12 真实的部分 mock</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void real_partial_mock()&#123;</span><br><span class="line">&#x2F;&#x2F;通过 spy 来调用真实的 api</span><br><span class="line">List list &#x3D; spy(new ArrayList());</span><br><span class="line">assertEquals(0,list.size());</span><br><span class="line">A a &#x3D; mock(A.class);</span><br><span class="line">&#x2F;&#x2F;通过 thenCallRealMethod 来调用真实的 api</span><br><span class="line">when(a.doSomething(anyInt())).thenCallRealMethod();</span><br><span class="line">assertEquals(999,a.doSomething(999));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    class A&#123;</span><br><span class="line">        public int doSomething(int i)&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-13-重置-mock"><a href="#2-13-重置-mock" class="headerlink" title="2.13 重置 mock"></a>2.13 重置 mock</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void reset_mock()&#123;</span><br><span class="line">List list &#x3D; mock(List.class);</span><br><span class="line">when(list.size()).thenReturn(10);</span><br><span class="line">list.add(1);</span><br><span class="line">assertEquals(10,list.size());</span><br><span class="line">&#x2F;&#x2F;重置 mock，清除所有的互动和预设</span><br><span class="line">reset(list);</span><br><span class="line">assertEquals(0,list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-14-验证确切的调用次数"><a href="#2-14-验证确切的调用次数" class="headerlink" title="2.14 验证确切的调用次数"></a>2.14 验证确切的调用次数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void verifying_number_of_invocations()&#123;</span><br><span class="line">List list &#x3D; mock(List.class);</span><br><span class="line">list.add(1);</span><br><span class="line">list.add(2);</span><br><span class="line">list.add(2);</span><br><span class="line">list.add(3);</span><br><span class="line">list.add(3);</span><br><span class="line">list.add(3);</span><br><span class="line">&#x2F;&#x2F;验证是否被调用一次，等效于下面的 times(1)</span><br><span class="line">verify(list).add(1);</span><br><span class="line">verify(list,times(1)).add(1);</span><br><span class="line">&#x2F;&#x2F;验证是否被调用 2 次</span><br><span class="line">verify(list,times(2)).add(2);</span><br><span class="line">&#x2F;&#x2F;验证是否被调用 3 次</span><br><span class="line">verify(list,times(3)).add(3);</span><br><span class="line">&#x2F;&#x2F;验证是否从未被调用过</span><br><span class="line">verify(list,never()).add(4);</span><br><span class="line">&#x2F;&#x2F;验证至少调用一次</span><br><span class="line">verify(list,atLeastOnce()).add(1);</span><br><span class="line">&#x2F;&#x2F;验证至少调用 2 次</span><br><span class="line">verify(list,atLeast(2)).add(2);</span><br><span class="line">&#x2F;&#x2F;验证至多调用 3 次</span><br><span class="line">verify(list,atMost(3)).add(3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-15-连续调用"><a href="#2-15-连续调用" class="headerlink" title="2.15 连续调用"></a>2.15 连续调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test(expected &#x3D; RuntimeException.class)</span><br><span class="line">public void consecutive_calls()&#123;</span><br><span class="line">&#x2F;&#x2F;模拟连续调用返回期望值，如果分开，则只有最后一个有效</span><br><span class="line">when(mockList.get(0)).thenReturn(0);</span><br><span class="line">when(mockList.get(0)).thenReturn(1);</span><br><span class="line">when(mockList.get(0)).thenReturn(2);</span><br><span class="line">when(mockList.get(1)).thenReturn(0).thenReturn(1).thenThrow(new RuntimeException());</span><br><span class="line">assertEquals(2,mockList.get(0));</span><br><span class="line">assertEquals(2,mockList.get(0));</span><br><span class="line">assertEquals(0,mockList.get(1));</span><br><span class="line">assertEquals(1,mockList.get(1));</span><br><span class="line">&#x2F;&#x2F;第三次或更多调用都会抛出异常</span><br><span class="line">mockList.get(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-16-验证执行顺序"><a href="#2-16-验证执行顺序" class="headerlink" title="2.16 验证执行顺序"></a>2.16 验证执行顺序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void verification_in_order()&#123;</span><br><span class="line">List list &#x3D; mock(List.class);</span><br><span class="line">List list2 &#x3D; mock(List.class);</span><br><span class="line">list.add(1);</span><br><span class="line">list2.add(&quot;hello&quot;);</span><br><span class="line">list.add(2);</span><br><span class="line">list2.add(&quot;world&quot;);</span><br><span class="line">&#x2F;&#x2F;将需要排序的 mock 对象放入 InOrder</span><br><span class="line">InOrder inOrder &#x3D; inOrder(list,list2);</span><br><span class="line">&#x2F;&#x2F;下面的代码不能颠倒顺序，验证执行顺序</span><br><span class="line">inOrder.verify(list).add(1);</span><br><span class="line">inOrder.verify(list2).add(&quot;hello&quot;);</span><br><span class="line">inOrder.verify(list).add(2);</span><br><span class="line">inOrder.verify(list2).add(&quot;world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-17-确保模拟对象上无互动发生"><a href="#2-17-确保模拟对象上无互动发生" class="headerlink" title="2.17 确保模拟对象上无互动发生"></a>2.17 确保模拟对象上无互动发生</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void verify_interaction()&#123;</span><br><span class="line">List list &#x3D; mock(List.class);</span><br><span class="line">List list2 &#x3D; mock(List.class);</span><br><span class="line">List list3 &#x3D; mock(List.class);</span><br><span class="line">list.add(1);</span><br><span class="line">verify(list).add(1);</span><br><span class="line">verify(list,never()).add(2);</span><br><span class="line">&#x2F;&#x2F;验证零互动行为</span><br><span class="line">verifyZeroInteractions(list2,list3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-18-找出冗余的互动-即未被验证到的"><a href="#2-18-找出冗余的互动-即未被验证到的" class="headerlink" title="2.18 找出冗余的互动(即未被验证到的)"></a>2.18 找出冗余的互动(即未被验证到的)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test(expected &#x3D; NoInteractionsWanted.class)</span><br><span class="line">public void find_redundant_interaction()&#123;</span><br><span class="line">List list &#x3D; mock(List.class);</span><br><span class="line">list.add(1);</span><br><span class="line">list.add(2);</span><br><span class="line">verify(list,times(2)).add(anyInt());</span><br><span class="line">&#x2F;&#x2F;检查是否有未被验证的互动行为，因为 add(1)和 add(2)都会被上面的 anyInt()验证到，所以下面的代码会通过</span><br><span class="line">verifyNoMoreInteractions(list);</span><br><span class="line"></span><br><span class="line">        List list2 &#x3D; mock(List.class);</span><br><span class="line">        list2.add(1);</span><br><span class="line">        list2.add(2);</span><br><span class="line">        verify(list2).add(1);</span><br><span class="line">        &#x2F;&#x2F;检查是否有未被验证的互动行为，因为add(2)没有被验证，所以下面的代码会失败抛出异常</span><br><span class="line">        verifyNoMoreInteractions(list2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-Mockito-如何实现-Mock"><a href="#3-Mockito-如何实现-Mock" class="headerlink" title="3 Mockito 如何实现 Mock"></a>3 Mockito 如何实现 Mock</h1><p>Mockito 并不是创建一个真实的对象，而是模拟这个对象，他用简单的 when(mock.method(params)).thenRetrun(result)语句设置 mock 对象的行为，如下语句：</p>
<p>// 设置 mock 对象的行为 － 当调用其 get 方法获取第 0 个元素时，返回”first”<br>Mockito.when(mockedList.get(0)).thenReturn(“first”);<br>在 Mock 对象的时候，创建一个 proxy 对象，保存被调用的方法名（get），以及调用时候传递的参数（0），然后在调用 thenReturn 方法时再把“first”保存起来，这样，就有了构建一个 stub 方法所需的所有信息，构建一个 stub。当 get 方法被调用的时候，实际上调用的是之前保存的 proxy 对象的 get 方法，返回之前保存的数据。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/29/Golang%E7%9A%84%E5%8C%85%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/29/Golang%E7%9A%84%E5%8C%85%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">Golang 的包管理机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-11-29 16:07:30 / Modified: 16:30:30" itemprop="dateCreated datePublished" datetime="2020-11-29T16:07:30+08:00">2020-11-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在 Go1.5 之前用 GOPATH 以及 GOROOT 这两个环境变量来管理包的位置，GOROOT 为 Go 的安装目录，以及编译过程中使用到的系统库存放位置，如 fmt。Go1.5 到 Go1.7 开始稳定到 Vendor 方式，即依赖包需要放到 $GOPATH/src/vendor 目录下，这样每个项目都有自己的 vendor 目录，但是如果依赖同样的三方包，很容易造成资源重复，Go vendor 出现了几种主流的管理工具，包括 godep、govendor、golide 等。</p>
<p>在 Go1.11 之前，GOPATH 是开发时的工作目录，其中包含三个子目录：</p>
<p>src 目录：存放 go 项目源码和依赖源码，包括使用 go get 下载的包<br>bin 目录：通过使用 go install 命令将 go build 编译出的二进制可执行文件存放于此<br>pkg 目录：go 源码包编译生成的 lib 文件存储的地方<br>在 Go1.11 之前，import 包时的搜索路径</p>
<p>GOROOT/src: 该目录保存了 Go 标准库代码(首先搜寻导入包的地方)<br>GOPATH/src: 该目录保存了应用自身的各个包代码和第三方依赖的代码<br>./vendor ：vendor 方式第三方依赖包（如果支持 Vendor）<br>在 Unix 和类 Unix 系统上，GOPATH 默认值是 $HOME/go，Go1.11 版本后，开启 GO Modules 后，GOPATH 的作用仅仅为存放依赖的目录了。</p>
<p>在 Go 的 1.11 版本之前，GOPATH 是必需的，且所有的 Go 项目代码都要保存在 GOPATH/src 目录下，也就是如果想引用本地的包，你需要将包放在 $GOPATH/src 目录下才能找得到。Go 的 1.11 版本之后，GO 官方引入了 Go Modules，不仅仅方便的使用我们的依赖，而且还对依赖的版本进行了管理。</p>
<p>在 Go1.11 后通过 go mod vendor 和 -mod=vendor 来实现 Vendor 管理依赖方式。本来在 vgo 项目(Go Modules 前身)是要完全放弃 vendor，但是在社区反馈下还是保留了。总之就是在 Go.1.11 之后需要开启 Go Modules 条件下才能使用 Vendor，具体地感兴趣或还沿用了 Vendor 的朋友可以去了解下，不过建议以后仅使用 Go Modules 包管理方式了。</p>
<h2 id="dep-govendor-机制"><a href="#dep-govendor-机制" class="headerlink" title="dep/govendor 机制"></a>dep/govendor 机制</h2><h4 id="vendor-使用限制"><a href="#vendor-使用限制" class="headerlink" title="vendor 使用限制"></a>vendor 使用限制</h4><p>使用 vendor 来管理包的项目，必须位于$GOPATH/src 下面。</p>
<h4 id="vendor-目录和-json-文件"><a href="#vendor-目录和-json-文件" class="headerlink" title="vendor 目录和 json 文件"></a>vendor 目录和 json 文件</h4><p>该工具将项目依赖的外部包拷贝到项目下的 vendor 目录下，并通过 vendor.json 文件来记录依赖包的版本，方便用户使用相对稳定的依赖。</p>
<h4 id="vendor-机制下，如何搜索包依赖"><a href="#vendor-机制下，如何搜索包依赖" class="headerlink" title="vendor 机制下，如何搜索包依赖"></a>vendor 机制下，如何搜索包依赖</h4><p>那么查找依赖包路径的解决方案如下：</p>
<ul>
<li>当前包下的 vendor 目录。</li>
<li>向上级目录查找，直到找到 src 下的 vendor 目录。</li>
<li>在 GOPATH 下面查找依赖包。</li>
<li>在 GOROOT 目录下查找</li>
</ul>
<h4 id="如果我们已经使用-GOPATH-去存储-packages-了，问什么还需要使用-vendor-目录呢？"><a href="#如果我们已经使用-GOPATH-去存储-packages-了，问什么还需要使用-vendor-目录呢？" class="headerlink" title="如果我们已经使用 GOPATH 去存储 packages 了，问什么还需要使用 vendor 目录呢？"></a>如果我们已经使用 GOPATH 去存储 packages 了，问什么还需要使用 vendor 目录呢？</h4><p>这是一个很实战的问题。假如多个应用使用一个依赖包的不同版本？这个问题不只是 Go 应用，其他语言也会有这个问题。<br>vendor 目录允许不同的代码库拥有它自己的依赖包，并且不同于其他代码库的版本，这就很好的做到了工程的隔离。<br>每个项目都有各自的 vendor，每个 vendor 可以存放不同版本的依赖包。</p>
<h2 id="module-机制"><a href="#module-机制" class="headerlink" title="module 机制"></a>module 机制</h2><p>在 go1.11 版本中，新增了 module 管理模块功能，用来管理依赖包。要知道，在这个之前，想要对 go 语言包进行管理，只能依赖第三方库实现，比如 Vendor,GoVendor,GoDep,Dep,Glide 等等，对于初学者来说，真的是选择困难症。</p>
<h4 id="开启-module-特性"><a href="#开启-module-特性" class="headerlink" title="开启 module 特性"></a>开启 module 特性</h4><p>要开始使用 go module 的特性， 需要先设置 GO111MODULE 环境变量。<br>开启 GO111MODULE。<br>要使用 go module,首先要设置 GO111MODULE=on,这没什么可说的，如果没设置，执行命令的时候会有提示，这个大家应该都了解了</p>
<h4 id="在-GOAPTH-src-中创建项目"><a href="#在-GOAPTH-src-中创建项目" class="headerlink" title="在$GOAPTH/src 中创建项目"></a>在$GOAPTH/src 中创建项目</h4><p>在$GOPATH/src 目录下创建 github.com/cnwyt/mytest 目录，mytest 为项目目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $GOPATH&#x2F;src&#x2F;github.com&#x2F;cnwyt&#x2F;mytest</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ export GO111MODULE&#x3D;on</span><br><span class="line">$ go mod init github.com&#x2F;cnwyt&#x2F;mytest</span><br><span class="line">go: creating new go.mod: module github.com&#x2F;cnwyt&#x2F;mytest</span><br></pre></td></tr></table></figure>

<p>当然这个 go 模块可以创建在任意位置，不强制邀请放在 GOPATH 路径下。</p>
<h4 id="在-GOPATH-src-外也可以创建项目"><a href="#在-GOPATH-src-外也可以创建项目" class="headerlink" title="在$GOPATH/src 外也可以创建项目"></a>在$GOPATH/src 外也可以创建项目</h4><p>在 GOPATH 以外的模块，创建一个 helloworld 目录，用来调用刚刚创建的 mytest 模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir helloworld &amp;&amp; cd helloworld</span><br><span class="line">$ vi main.go</span><br></pre></td></tr></table></figure>

<p>创建一个 main.go 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">&#x2F;&#x2F;import &quot;github.com&#x2F;cnwyt&#x2F;mytest&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;Hello, World!&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;mytest.ShowTest1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>初始化该模块，引入 github.com/cnwyt/mytest 模块，指定版本为 latest:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init helloworld</span><br><span class="line">$ go mod edit -require github.com&#x2F;cnwyt&#x2F;mytest@latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>初始化后，会生成一个 go.mod 文件，类似 npm 里的 package.json 或者 composer 的 composer.json 的一个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module helloworld</span><br><span class="line"></span><br><span class="line">require github.com&#x2F;cnwyt&#x2F;mytest v0.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样直接执行 go test 或者 go run main.go 会报错:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go test</span><br><span class="line">build helloworld: cannot find module for path github.com&#x2F;cnwyt&#x2F;mytest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是为啥呢？ 这是因为我们虽然创建了一个名为 github.com/cnwyt/mytest 模块，在 GOPATH 路径里也有这个模块。但是，GO 模块去 Github 去找这个模块，而不是在 GOPATH 路径里去找，所以找不到。</p>
<p>那该怎么办呢?<br>有两个解决办法：<br>第一个办法，很简单，就是直接将 cnwyt/mytest 模块推送的 GitHub 上。<br>但是，如果我要修改 cnwyt/mytest 里的代码，都得先推送到 GitHub 上，才能生效，实在太麻烦了。<br>那就直接使用第二个办法， 使用 go replace:</p>
<p>直接修改 go.mod，新增一行 replace:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module helloworld</span><br><span class="line"></span><br><span class="line">require github.com&#x2F;cnwyt&#x2F;mytest v0.0.0</span><br><span class="line"></span><br><span class="line">replace github.com&#x2F;cnwyt&#x2F;mytest &#x3D;&gt; &#x2F;Users&#x2F;wangtom&#x2F;goworkspace&#x2F;mytest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意版本号必须填写，可以填 v0.0.0 或者 latest.</p>
<h4 id="调用第三方模块"><a href="#调用第三方模块" class="headerlink" title="调用第三方模块"></a>调用第三方模块</h4><p>比如项目中会用到比较流行的路由模块 gorilla/mux:</p>
<p>直接修改 go.mod，新增一行 require，不指定版本可以直接写 latest 获取最新版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require github.com&#x2F;gorilla&#x2F;mux latest</span><br></pre></td></tr></table></figure>

<p>运行 go build 或 go test 会自动从 GitHub 下载模块，并会修改 go.mod 文件。</p>
<p>比如运行后会把 latest 直接修改成目前最新的版本 v1.6.2 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module helloworld</span><br><span class="line"></span><br><span class="line">require github.com&#x2F;cnwyt&#x2F;mytest v0.0.0</span><br><span class="line">require github.com&#x2F;gorilla&#x2F;mux v1.6.2</span><br><span class="line"></span><br><span class="line">replace github.com&#x2F;cnwyt&#x2F;mytest &#x3D;&gt; &#x2F;Users&#x2F;wangtom&#x2F;goworkspace&#x2F;godict</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到模块 gorilla/mux 代码会下载到 $GOPATH/pkg/mod/ 模块下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ll &#x2F;Users&#x2F;wangtom&#x2F;goworkspace&#x2F;pkg&#x2F;mod&#x2F;github.com&#x2F;gorilla</span><br><span class="line">total 0</span><br><span class="line">dr-xr-xr-x  22 wangtom  staff 704B 12 24 22:14 mux@v1.6.2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="不使用-vendor-和-module-机制时，可以手动下载所有依赖"><a href="#不使用-vendor-和-module-机制时，可以手动下载所有依赖" class="headerlink" title="不使用 vendor 和 module 机制时，可以手动下载所有依赖"></a>不使用 vendor 和 module 机制时，可以手动下载所有依赖</h2><p>在不使用 vendor 和 module 的情况下，可以使用较原始的方式，将代码中依赖的内容全部下载并编译在$GOPATH 路径下。<br>在项目目录下，执行如下命令：<br>go get -d -v ./…</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/29/git%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/29/git%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">Git相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-11-29 16:07:30 / Modified: 16:30:33" itemprop="dateCreated datePublished" datetime="2020-11-29T16:07:30+08:00">2020-11-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Git-区域的划分与提交回滚"><a href="#Git-区域的划分与提交回滚" class="headerlink" title="Git 区域的划分与提交回滚"></a>Git 区域的划分与提交回滚</h3><p><img src="/images/git-1.png"></p>
<h3 id="区域划分"><a href="#区域划分" class="headerlink" title="区域划分"></a>区域划分</h3><p>分为工作区，本地库(暂存区和分支)，远程库。<br>工作区：分为原文件和已经修改但是未暂存的文件。<br>暂存区：存放已经 git add 添加后的文件,此区位于本地库。<br>分支：存放已经 git commit 提交后的文件，此区位于本地库<br>远程库：存放已经 git push 后的文件。</p>
<ol>
<li><p>修改本地已被跟踪文件，文件进入未暂存区域。</p>
</li>
<li><p>未暂存区域转到暂存区域 git add files</p>
</li>
<li><p>暂存区提交到本地仓库 git commit -m</p>
</li>
<li><p>直接从未暂存区提交到本地仓库<br>git commit -am<br>经测试，对已跟踪的文件可以正确执行，而对于未跟踪文件（即新增文件）则会出错</p>
</li>
<li><p>本地库回退到暂存区<br>git reset –soft hash 值<br>git reset –soft origin/master<br>一般回退到暂存区的文件作排查用，不要直接修改，不然会同时出现在暂存区和未暂存区（其实即使修改了也木有太大关系）</p>
</li>
<li><p>本地库回退到未暂存区<br>git reset –mixed hash 值<br>git reset –mixed origin/master<br>一般回退到未暂存状态就是为了进一步的修改</p>
</li>
<li><p>本地库回退到文件初始状态（即此版本的）<br>git reset –hard hash 值<br>注意这里，通常先执行一次 fetch，保证本地版本是 origin 的最新版本，然后再回退。（最厉害的是，这么操作不会有冲突，直接让文件变成和 origin 保持一致）<br>git fetch origin<br>git reset –hard origin/master<br>特别注意：这么操作会使你对文件的修改全部消失，还原成最初状态。<br>(针对上一条情况衍生讲解)通常在推送到 origin 时，先要 pull，然后再推送，一般是修改提交了的文件和 pull 下来的同一个文件产生冲突（所以建议修改代码前，一定先要 pull）<br>git pull<br>git push origin master</p>
</li>
<li><p>暂存区回退到未暂存区<br>git reset – files<br>git rest<br>撤销所有暂存区的文件</p>
</li>
<li><p>未暂存区回退到文件初始状态<br>git checkout – files</p>
</li>
<li><p>暂存区回退到文件初始状态<br>git checkout head – files</p>
</li>
</ol>
<h3 id="换一个角度看"><a href="#换一个角度看" class="headerlink" title="换一个角度看"></a>换一个角度看</h3><ul>
<li>从工作区一直到远程仓库的过程是：git add files,git commit, git push.</li>
<li>从远程仓库到工作区的过程是:git fetch/git clone/git pull,git reset – files, git checkout – files。<br>files 是指文件名。<br><img src="/images/git-2.png"></li>
</ul>
<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><img src="/images/git-3.png"></p>
<ul>
<li>git reset –soft,重置位置的同时，保留 working Tree 工作目录和 index 暂存区的内容，只让 repository 中的内容和 reset 目标节点(reset 目标节点是指 reset 命令执行后，head 所指向的节点，或者说 commit 记录)保持一致，因此原节点和 reset 节点之间的【差异变更集】会放入 index 暂存区中(Staged files)。所以效果看起来就是工作目录的内容不变，暂存区原有的内容也不变，只是原节点和 Reset 节点之间的所有差异都会放到暂存区中。</li>
<li>git reset –mixed,重置位置的同时，只保留 Working Tree 工作目录的內容，但会将 Index 暂存区 和 Repository 中的內容更改和 reset 目标节点一致，因此原节点和 Reset 节点之间的【差异变更集】会放入 Working Tree 工作目录中。所以效果看起来就是原节点和 Reset 节点之间的所有差异都会放到工作目录中。</li>
<li>git reset –hard,重置位置的同时，直接将 working Tree 工作目录、 index 暂存区及 repository 都重置成目标 Reset 节点的內容,所以效果看起来等同于清空暂存区和工作区。可以使用 **git reset –hard HEAD^ 来回退到上一次 commit 的状态。<br>此命令可以用来回退到任意版本：git reset –hard commitid **</li>
<li>git reset,用来从暂存区撤销上一次 git add 添加的修改内容。可以使用 git reset HEAD filepathname （比如： git reset HEAD readme.md）来放弃指定文件的缓存，放弃所有的缓存可以使用 git reset HEAD . 命令。不影响工作区中的内容。<br>git reset 详细解释可以参看，<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c2ec5f06cf1a">https://www.jianshu.com/p/c2ec5f06cf1a</a></li>
</ul>
<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p><img src="/images/git-4.png"></p>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>这要从 git 的分支说起，git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。git 是如何知道你当前在哪个分支上工作的呢？<br>其实答案也很简单，它保存着一个名为 HEAD 的特别指针。在 git 中，它是一个指向你正在工作中的本地分支的指针，可以将 HEAD 想象为当前分支的别名。<br><img src="/images/git-5.png"></p>
<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>git 的四个工作区<br><img src="/images/git-6.png"></p>
<p>git diff：是查看 workspace（工作区） 与 index（暂存区） 的差别的。<br>git diff –cached：是查看 index（暂存区） 与 local repositorty（本地仓库） 的差别的。<br>git diff HEAD：是查看 workspace 和 local repository 的差别的。（HEAD 指向的是 local repository 中最新提交的版本）</p>
<p>注：git diff 后跟两个参数，如果只写一个参数，表示默认跟 workspace 中的代码作比较。git diff 显示的结果为 第二个参数所指的代码在第一个参数所指代码基础上的修改。如，git diff HEAD 表示 workspace 在 最新 commit 的基础上所做的修改</p>
<h4 id="比较工作区与暂存区"><a href="#比较工作区与暂存区" class="headerlink" title="比较工作区与暂存区"></a>比较工作区与暂存区</h4><p><img src="/images/git-7.png"></p>
<h4 id="比较本地库的当前版本和上一次版本"><a href="#比较本地库的当前版本和上一次版本" class="headerlink" title="比较本地库的当前版本和上一次版本"></a>比较本地库的当前版本和上一次版本</h4><p><img src="/images/git-8.png"></p>
<h3 id="git-pull-时冲突了怎么办"><a href="#git-pull-时冲突了怎么办" class="headerlink" title="git pull 时冲突了怎么办"></a>git pull 时冲突了怎么办</h3><ol>
<li>忽略本地修改，强制拉取远程到本地</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line"></span><br><span class="line">git reset --hard origin&#x2F;dev</span><br><span class="line"></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>未 commit 先 pull，视本地修改量选择 revert 或 stash</p>
<ul>
<li>本地修改量小。<code>-&gt; revert(把自己的代码取消) -&gt; 重新pull -&gt; 在最新代码上修改 -&gt; [pull确认最新] -&gt; commit&amp;push</code></li>
<li>本地修改量大。<code>-&gt; stash save(把自己的代码隐藏存起来) -&gt; 重新pull -&gt; stash pop(把存起来的隐藏的代码取回来 ) -&gt; 代码文件会显示冲突 -&gt; 右键选择resolve conflict -&gt; 打开文件解决冲突 -&gt;commit&amp;push</code><br>git stash 能够将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录。</li>
</ul>
</li>
<li><p>已 commit 未 push，视本地修改量选择 reset 或直接 merge</p>
<ul>
<li>修改量小。<code>-&gt; reset(回退到未修改之前，选hard模式，把自己的更改取消) -&gt; 重新pull -&gt; 在最新代码上修改 -&gt; [pull确认最新] -&gt; commit&amp;push</code></li>
<li>修改量大。<code>-&gt; commit后pull显示冲突 -&gt; 手动merge解决冲突 -&gt; 重新commit -&gt; push</code></li>
</ul>
</li>
</ol>
<h3 id="git-revert-和-reset-的区别"><a href="#git-revert-和-reset-的区别" class="headerlink" title="git revert 和 reset 的区别"></a>git revert 和 reset 的区别</h3><p>git revert 和 git reset 的区别</p>
<ul>
<li>git revert 是用一次新的 commit 来回滚之前的 commit，此次提交之前的 commit 都会被保留；</li>
<li>git reset 是回到某次提交，提交及之前的 commit 都会被保留，但是此 commit id 之后的修改都会被删除</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
